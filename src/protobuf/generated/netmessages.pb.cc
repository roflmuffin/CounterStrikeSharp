// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: netmessages.proto

#include "netmessages.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

PROTOBUF_CONSTEXPR CCLCMsg_ClientInfo::CCLCMsg_ClientInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.friends_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.send_table_crc_)*/0u
  , /*decltype(_impl_.server_count_)*/0u
  , /*decltype(_impl_.is_hltv_)*/false
  , /*decltype(_impl_.friends_id_)*/0u} {}
struct CCLCMsg_ClientInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CCLCMsg_ClientInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CCLCMsg_ClientInfoDefaultTypeInternal() {}
  union {
    CCLCMsg_ClientInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CCLCMsg_ClientInfoDefaultTypeInternal _CCLCMsg_ClientInfo_default_instance_;
PROTOBUF_CONSTEXPR CCLCMsg_Move::CCLCMsg_Move(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.data_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.command_number_)*/0u
  , /*decltype(_impl_.num_commands_)*/0u} {}
struct CCLCMsg_MoveDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CCLCMsg_MoveDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CCLCMsg_MoveDefaultTypeInternal() {}
  union {
    CCLCMsg_Move _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CCLCMsg_MoveDefaultTypeInternal _CCLCMsg_Move_default_instance_;
PROTOBUF_CONSTEXPR CMsgVoiceAudio::CMsgVoiceAudio(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.packet_offsets_)*/{}
  , /*decltype(_impl_._packet_offsets_cached_byte_size_)*/{0}
  , /*decltype(_impl_.voice_data_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.format_)*/0
  , /*decltype(_impl_.sequence_bytes_)*/0
  , /*decltype(_impl_.section_number_)*/0u
  , /*decltype(_impl_.sample_rate_)*/0u
  , /*decltype(_impl_.uncompressed_sample_offset_)*/0u
  , /*decltype(_impl_.num_packets_)*/0u
  , /*decltype(_impl_.voice_level_)*/0} {}
struct CMsgVoiceAudioDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgVoiceAudioDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgVoiceAudioDefaultTypeInternal() {}
  union {
    CMsgVoiceAudio _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgVoiceAudioDefaultTypeInternal _CMsgVoiceAudio_default_instance_;
PROTOBUF_CONSTEXPR CCLCMsg_VoiceData::CCLCMsg_VoiceData(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.audio_)*/nullptr
  , /*decltype(_impl_.xuid_)*/uint64_t{0u}
  , /*decltype(_impl_.tick_)*/0u} {}
struct CCLCMsg_VoiceDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CCLCMsg_VoiceDataDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CCLCMsg_VoiceDataDefaultTypeInternal() {}
  union {
    CCLCMsg_VoiceData _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CCLCMsg_VoiceDataDefaultTypeInternal _CCLCMsg_VoiceData_default_instance_;
PROTOBUF_CONSTEXPR CCLCMsg_BaselineAck::CCLCMsg_BaselineAck(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.baseline_tick_)*/0
  , /*decltype(_impl_.baseline_nr_)*/0} {}
struct CCLCMsg_BaselineAckDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CCLCMsg_BaselineAckDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CCLCMsg_BaselineAckDefaultTypeInternal() {}
  union {
    CCLCMsg_BaselineAck _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CCLCMsg_BaselineAckDefaultTypeInternal _CCLCMsg_BaselineAck_default_instance_;
PROTOBUF_CONSTEXPR CCLCMsg_ListenEvents::CCLCMsg_ListenEvents(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.event_mask_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CCLCMsg_ListenEventsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CCLCMsg_ListenEventsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CCLCMsg_ListenEventsDefaultTypeInternal() {}
  union {
    CCLCMsg_ListenEvents _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CCLCMsg_ListenEventsDefaultTypeInternal _CCLCMsg_ListenEvents_default_instance_;
PROTOBUF_CONSTEXPR CCLCMsg_RespondCvarValue::CCLCMsg_RespondCvarValue(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.value_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.cookie_)*/0
  , /*decltype(_impl_.status_code_)*/0} {}
struct CCLCMsg_RespondCvarValueDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CCLCMsg_RespondCvarValueDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CCLCMsg_RespondCvarValueDefaultTypeInternal() {}
  union {
    CCLCMsg_RespondCvarValue _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CCLCMsg_RespondCvarValueDefaultTypeInternal _CCLCMsg_RespondCvarValue_default_instance_;
PROTOBUF_CONSTEXPR CCLCMsg_FileCRCCheck::CCLCMsg_FileCRCCheck(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.path_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.filename_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.code_path_)*/0
  , /*decltype(_impl_.code_filename_)*/0
  , /*decltype(_impl_.crc_)*/0u} {}
struct CCLCMsg_FileCRCCheckDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CCLCMsg_FileCRCCheckDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CCLCMsg_FileCRCCheckDefaultTypeInternal() {}
  union {
    CCLCMsg_FileCRCCheck _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CCLCMsg_FileCRCCheckDefaultTypeInternal _CCLCMsg_FileCRCCheck_default_instance_;
PROTOBUF_CONSTEXPR CCLCMsg_LoadingProgress::CCLCMsg_LoadingProgress(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.progress_)*/0} {}
struct CCLCMsg_LoadingProgressDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CCLCMsg_LoadingProgressDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CCLCMsg_LoadingProgressDefaultTypeInternal() {}
  union {
    CCLCMsg_LoadingProgress _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CCLCMsg_LoadingProgressDefaultTypeInternal _CCLCMsg_LoadingProgress_default_instance_;
PROTOBUF_CONSTEXPR CCLCMsg_SplitPlayerConnect::CCLCMsg_SplitPlayerConnect(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.playername_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct CCLCMsg_SplitPlayerConnectDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CCLCMsg_SplitPlayerConnectDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CCLCMsg_SplitPlayerConnectDefaultTypeInternal() {}
  union {
    CCLCMsg_SplitPlayerConnect _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CCLCMsg_SplitPlayerConnectDefaultTypeInternal _CCLCMsg_SplitPlayerConnect_default_instance_;
PROTOBUF_CONSTEXPR CCLCMsg_ClientMessage::CCLCMsg_ClientMessage(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.data_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.msg_type_)*/0} {}
struct CCLCMsg_ClientMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CCLCMsg_ClientMessageDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CCLCMsg_ClientMessageDefaultTypeInternal() {}
  union {
    CCLCMsg_ClientMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CCLCMsg_ClientMessageDefaultTypeInternal _CCLCMsg_ClientMessage_default_instance_;
PROTOBUF_CONSTEXPR CCLCMsg_SplitPlayerDisconnect::CCLCMsg_SplitPlayerDisconnect(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.slot_)*/0} {}
struct CCLCMsg_SplitPlayerDisconnectDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CCLCMsg_SplitPlayerDisconnectDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CCLCMsg_SplitPlayerDisconnectDefaultTypeInternal() {}
  union {
    CCLCMsg_SplitPlayerDisconnect _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CCLCMsg_SplitPlayerDisconnectDefaultTypeInternal _CCLCMsg_SplitPlayerDisconnect_default_instance_;
PROTOBUF_CONSTEXPR CCLCMsg_ServerStatus::CCLCMsg_ServerStatus(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.simplified_)*/false} {}
struct CCLCMsg_ServerStatusDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CCLCMsg_ServerStatusDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CCLCMsg_ServerStatusDefaultTypeInternal() {}
  union {
    CCLCMsg_ServerStatus _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CCLCMsg_ServerStatusDefaultTypeInternal _CCLCMsg_ServerStatus_default_instance_;
PROTOBUF_CONSTEXPR CCLCMsg_RequestPause::CCLCMsg_RequestPause(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.pause_type_)*/0
  , /*decltype(_impl_.pause_group_)*/0} {}
struct CCLCMsg_RequestPauseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CCLCMsg_RequestPauseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CCLCMsg_RequestPauseDefaultTypeInternal() {}
  union {
    CCLCMsg_RequestPause _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CCLCMsg_RequestPauseDefaultTypeInternal _CCLCMsg_RequestPause_default_instance_;
PROTOBUF_CONSTEXPR CCLCMsg_CmdKeyValues::CCLCMsg_CmdKeyValues(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.data_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct CCLCMsg_CmdKeyValuesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CCLCMsg_CmdKeyValuesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CCLCMsg_CmdKeyValuesDefaultTypeInternal() {}
  union {
    CCLCMsg_CmdKeyValues _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CCLCMsg_CmdKeyValuesDefaultTypeInternal _CCLCMsg_CmdKeyValues_default_instance_;
PROTOBUF_CONSTEXPR CCLCMsg_RconServerDetails::CCLCMsg_RconServerDetails(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.token_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct CCLCMsg_RconServerDetailsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CCLCMsg_RconServerDetailsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CCLCMsg_RconServerDetailsDefaultTypeInternal() {}
  union {
    CCLCMsg_RconServerDetails _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CCLCMsg_RconServerDetailsDefaultTypeInternal _CCLCMsg_RconServerDetails_default_instance_;
PROTOBUF_CONSTEXPR CSVCMsg_ServerInfo::CSVCMsg_ServerInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.game_dir_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.map_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.sky_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.host_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.addon_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.game_session_manifest_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.game_session_config_)*/nullptr
  , /*decltype(_impl_.protocol_)*/0
  , /*decltype(_impl_.server_count_)*/0
  , /*decltype(_impl_.is_dedicated_)*/false
  , /*decltype(_impl_.is_hltv_)*/false
  , /*decltype(_impl_.c_os_)*/0
  , /*decltype(_impl_.max_clients_)*/0
  , /*decltype(_impl_.max_classes_)*/0
  , /*decltype(_impl_.tick_interval_)*/0
  , /*decltype(_impl_.player_slot_)*/-1} {}
struct CSVCMsg_ServerInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CSVCMsg_ServerInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CSVCMsg_ServerInfoDefaultTypeInternal() {}
  union {
    CSVCMsg_ServerInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CSVCMsg_ServerInfoDefaultTypeInternal _CSVCMsg_ServerInfo_default_instance_;
PROTOBUF_CONSTEXPR CSVCMsg_ClassInfo_class_t::CSVCMsg_ClassInfo_class_t(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.class_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.class_id_)*/0} {}
struct CSVCMsg_ClassInfo_class_tDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CSVCMsg_ClassInfo_class_tDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CSVCMsg_ClassInfo_class_tDefaultTypeInternal() {}
  union {
    CSVCMsg_ClassInfo_class_t _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CSVCMsg_ClassInfo_class_tDefaultTypeInternal _CSVCMsg_ClassInfo_class_t_default_instance_;
PROTOBUF_CONSTEXPR CSVCMsg_ClassInfo::CSVCMsg_ClassInfo(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.classes_)*/{}
  , /*decltype(_impl_.create_on_client_)*/false} {}
struct CSVCMsg_ClassInfoDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CSVCMsg_ClassInfoDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CSVCMsg_ClassInfoDefaultTypeInternal() {}
  union {
    CSVCMsg_ClassInfo _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CSVCMsg_ClassInfoDefaultTypeInternal _CSVCMsg_ClassInfo_default_instance_;
PROTOBUF_CONSTEXPR CSVCMsg_SetPause::CSVCMsg_SetPause(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.paused_)*/false} {}
struct CSVCMsg_SetPauseDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CSVCMsg_SetPauseDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CSVCMsg_SetPauseDefaultTypeInternal() {}
  union {
    CSVCMsg_SetPause _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CSVCMsg_SetPauseDefaultTypeInternal _CSVCMsg_SetPause_default_instance_;
PROTOBUF_CONSTEXPR CSVCMsg_VoiceInit::CSVCMsg_VoiceInit(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.codec_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.quality_)*/0
  , /*decltype(_impl_.version_)*/0} {}
struct CSVCMsg_VoiceInitDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CSVCMsg_VoiceInitDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CSVCMsg_VoiceInitDefaultTypeInternal() {}
  union {
    CSVCMsg_VoiceInit _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CSVCMsg_VoiceInitDefaultTypeInternal _CSVCMsg_VoiceInit_default_instance_;
PROTOBUF_CONSTEXPR CSVCMsg_Print::CSVCMsg_Print(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.text_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct CSVCMsg_PrintDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CSVCMsg_PrintDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CSVCMsg_PrintDefaultTypeInternal() {}
  union {
    CSVCMsg_Print _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CSVCMsg_PrintDefaultTypeInternal _CSVCMsg_Print_default_instance_;
PROTOBUF_CONSTEXPR CSVCMsg_Sounds_sounddata_t::CSVCMsg_Sounds_sounddata_t(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.origin_x_)*/0
  , /*decltype(_impl_.origin_y_)*/0
  , /*decltype(_impl_.origin_z_)*/0
  , /*decltype(_impl_.volume_)*/0u
  , /*decltype(_impl_.delay_value_)*/0
  , /*decltype(_impl_.sequence_number_)*/0
  , /*decltype(_impl_.channel_)*/0
  , /*decltype(_impl_.pitch_)*/0
  , /*decltype(_impl_.flags_)*/0
  , /*decltype(_impl_.sound_num_)*/0u
  , /*decltype(_impl_.sound_num_handle_)*/0u
  , /*decltype(_impl_.speaker_entity_)*/0
  , /*decltype(_impl_.random_seed_)*/0
  , /*decltype(_impl_.sound_level_)*/0
  , /*decltype(_impl_.is_sentence_)*/false
  , /*decltype(_impl_.is_ambient_)*/false
  , /*decltype(_impl_.guid_)*/0u
  , /*decltype(_impl_.sound_resource_id_)*/uint64_t{0u}
  , /*decltype(_impl_.entity_index_)*/-1} {}
struct CSVCMsg_Sounds_sounddata_tDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CSVCMsg_Sounds_sounddata_tDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CSVCMsg_Sounds_sounddata_tDefaultTypeInternal() {}
  union {
    CSVCMsg_Sounds_sounddata_t _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CSVCMsg_Sounds_sounddata_tDefaultTypeInternal _CSVCMsg_Sounds_sounddata_t_default_instance_;
PROTOBUF_CONSTEXPR CSVCMsg_Sounds::CSVCMsg_Sounds(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.sounds_)*/{}
  , /*decltype(_impl_.reliable_sound_)*/false} {}
struct CSVCMsg_SoundsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CSVCMsg_SoundsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CSVCMsg_SoundsDefaultTypeInternal() {}
  union {
    CSVCMsg_Sounds _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CSVCMsg_SoundsDefaultTypeInternal _CSVCMsg_Sounds_default_instance_;
PROTOBUF_CONSTEXPR CSVCMsg_Prefetch::CSVCMsg_Prefetch(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.sound_index_)*/0
  , /*decltype(_impl_.resource_type_)*/0} {}
struct CSVCMsg_PrefetchDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CSVCMsg_PrefetchDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CSVCMsg_PrefetchDefaultTypeInternal() {}
  union {
    CSVCMsg_Prefetch _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CSVCMsg_PrefetchDefaultTypeInternal _CSVCMsg_Prefetch_default_instance_;
PROTOBUF_CONSTEXPR CSVCMsg_SetView::CSVCMsg_SetView(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.entity_index_)*/-1
  , /*decltype(_impl_.slot_)*/-1} {}
struct CSVCMsg_SetViewDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CSVCMsg_SetViewDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CSVCMsg_SetViewDefaultTypeInternal() {}
  union {
    CSVCMsg_SetView _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CSVCMsg_SetViewDefaultTypeInternal _CSVCMsg_SetView_default_instance_;
PROTOBUF_CONSTEXPR CSVCMsg_FixAngle::CSVCMsg_FixAngle(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.angle_)*/nullptr
  , /*decltype(_impl_.relative_)*/false} {}
struct CSVCMsg_FixAngleDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CSVCMsg_FixAngleDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CSVCMsg_FixAngleDefaultTypeInternal() {}
  union {
    CSVCMsg_FixAngle _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CSVCMsg_FixAngleDefaultTypeInternal _CSVCMsg_FixAngle_default_instance_;
PROTOBUF_CONSTEXPR CSVCMsg_CrosshairAngle::CSVCMsg_CrosshairAngle(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.angle_)*/nullptr} {}
struct CSVCMsg_CrosshairAngleDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CSVCMsg_CrosshairAngleDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CSVCMsg_CrosshairAngleDefaultTypeInternal() {}
  union {
    CSVCMsg_CrosshairAngle _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CSVCMsg_CrosshairAngleDefaultTypeInternal _CSVCMsg_CrosshairAngle_default_instance_;
PROTOBUF_CONSTEXPR CSVCMsg_BSPDecal::CSVCMsg_BSPDecal(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.pos_)*/nullptr
  , /*decltype(_impl_.decal_texture_index_)*/0
  , /*decltype(_impl_.model_index_)*/0
  , /*decltype(_impl_.low_priority_)*/false
  , /*decltype(_impl_.entity_index_)*/-1} {}
struct CSVCMsg_BSPDecalDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CSVCMsg_BSPDecalDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CSVCMsg_BSPDecalDefaultTypeInternal() {}
  union {
    CSVCMsg_BSPDecal _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CSVCMsg_BSPDecalDefaultTypeInternal _CSVCMsg_BSPDecal_default_instance_;
PROTOBUF_CONSTEXPR CSVCMsg_SplitScreen::CSVCMsg_SplitScreen(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.type_)*/0
  , /*decltype(_impl_.slot_)*/0
  , /*decltype(_impl_.player_index_)*/-1} {}
struct CSVCMsg_SplitScreenDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CSVCMsg_SplitScreenDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CSVCMsg_SplitScreenDefaultTypeInternal() {}
  union {
    CSVCMsg_SplitScreen _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CSVCMsg_SplitScreenDefaultTypeInternal _CSVCMsg_SplitScreen_default_instance_;
PROTOBUF_CONSTEXPR CSVCMsg_GetCvarValue::CSVCMsg_GetCvarValue(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.cvar_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.cookie_)*/0} {}
struct CSVCMsg_GetCvarValueDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CSVCMsg_GetCvarValueDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CSVCMsg_GetCvarValueDefaultTypeInternal() {}
  union {
    CSVCMsg_GetCvarValue _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CSVCMsg_GetCvarValueDefaultTypeInternal _CSVCMsg_GetCvarValue_default_instance_;
PROTOBUF_CONSTEXPR CSVCMsg_Menu::CSVCMsg_Menu(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.menu_key_values_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.dialog_type_)*/0} {}
struct CSVCMsg_MenuDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CSVCMsg_MenuDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CSVCMsg_MenuDefaultTypeInternal() {}
  union {
    CSVCMsg_Menu _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CSVCMsg_MenuDefaultTypeInternal _CSVCMsg_Menu_default_instance_;
PROTOBUF_CONSTEXPR CSVCMsg_UserMessage::CSVCMsg_UserMessage(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.msg_data_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.msg_type_)*/0
  , /*decltype(_impl_.passthrough_)*/0} {}
struct CSVCMsg_UserMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CSVCMsg_UserMessageDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CSVCMsg_UserMessageDefaultTypeInternal() {}
  union {
    CSVCMsg_UserMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CSVCMsg_UserMessageDefaultTypeInternal _CSVCMsg_UserMessage_default_instance_;
PROTOBUF_CONSTEXPR CSVCMsg_SendTable_sendprop_t::CSVCMsg_SendTable_sendprop_t(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.var_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.dt_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.type_)*/0
  , /*decltype(_impl_.flags_)*/0
  , /*decltype(_impl_.priority_)*/0
  , /*decltype(_impl_.num_elements_)*/0
  , /*decltype(_impl_.low_value_)*/0
  , /*decltype(_impl_.high_value_)*/0
  , /*decltype(_impl_.num_bits_)*/0} {}
struct CSVCMsg_SendTable_sendprop_tDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CSVCMsg_SendTable_sendprop_tDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CSVCMsg_SendTable_sendprop_tDefaultTypeInternal() {}
  union {
    CSVCMsg_SendTable_sendprop_t _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CSVCMsg_SendTable_sendprop_tDefaultTypeInternal _CSVCMsg_SendTable_sendprop_t_default_instance_;
PROTOBUF_CONSTEXPR CSVCMsg_SendTable::CSVCMsg_SendTable(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.props_)*/{}
  , /*decltype(_impl_.net_table_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.is_end_)*/false
  , /*decltype(_impl_.needs_decoder_)*/false} {}
struct CSVCMsg_SendTableDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CSVCMsg_SendTableDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CSVCMsg_SendTableDefaultTypeInternal() {}
  union {
    CSVCMsg_SendTable _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CSVCMsg_SendTableDefaultTypeInternal _CSVCMsg_SendTable_default_instance_;
PROTOBUF_CONSTEXPR CSVCMsg_GameEventList_key_t::CSVCMsg_GameEventList_key_t(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.type_)*/0} {}
struct CSVCMsg_GameEventList_key_tDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CSVCMsg_GameEventList_key_tDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CSVCMsg_GameEventList_key_tDefaultTypeInternal() {}
  union {
    CSVCMsg_GameEventList_key_t _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CSVCMsg_GameEventList_key_tDefaultTypeInternal _CSVCMsg_GameEventList_key_t_default_instance_;
PROTOBUF_CONSTEXPR CSVCMsg_GameEventList_descriptor_t::CSVCMsg_GameEventList_descriptor_t(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.keys_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.eventid_)*/0} {}
struct CSVCMsg_GameEventList_descriptor_tDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CSVCMsg_GameEventList_descriptor_tDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CSVCMsg_GameEventList_descriptor_tDefaultTypeInternal() {}
  union {
    CSVCMsg_GameEventList_descriptor_t _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CSVCMsg_GameEventList_descriptor_tDefaultTypeInternal _CSVCMsg_GameEventList_descriptor_t_default_instance_;
PROTOBUF_CONSTEXPR CSVCMsg_GameEventList::CSVCMsg_GameEventList(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.descriptors_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CSVCMsg_GameEventListDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CSVCMsg_GameEventListDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CSVCMsg_GameEventListDefaultTypeInternal() {}
  union {
    CSVCMsg_GameEventList _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CSVCMsg_GameEventListDefaultTypeInternal _CSVCMsg_GameEventList_default_instance_;
PROTOBUF_CONSTEXPR CSVCMsg_PacketEntities_command_queue_info_t::CSVCMsg_PacketEntities_command_queue_info_t(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.commands_queued_)*/0u
  , /*decltype(_impl_.command_queue_desired_size_)*/0u
  , /*decltype(_impl_.starved_command_ticks_)*/0u
  , /*decltype(_impl_.time_dilation_percent_)*/0
  , /*decltype(_impl_.discarded_command_ticks_)*/0u} {}
struct CSVCMsg_PacketEntities_command_queue_info_tDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CSVCMsg_PacketEntities_command_queue_info_tDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CSVCMsg_PacketEntities_command_queue_info_tDefaultTypeInternal() {}
  union {
    CSVCMsg_PacketEntities_command_queue_info_t _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CSVCMsg_PacketEntities_command_queue_info_tDefaultTypeInternal _CSVCMsg_PacketEntities_command_queue_info_t_default_instance_;
PROTOBUF_CONSTEXPR CSVCMsg_PacketEntities_alternate_baseline_t::CSVCMsg_PacketEntities_alternate_baseline_t(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.entity_index_)*/0
  , /*decltype(_impl_.baseline_index_)*/0} {}
struct CSVCMsg_PacketEntities_alternate_baseline_tDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CSVCMsg_PacketEntities_alternate_baseline_tDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CSVCMsg_PacketEntities_alternate_baseline_tDefaultTypeInternal() {}
  union {
    CSVCMsg_PacketEntities_alternate_baseline_t _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CSVCMsg_PacketEntities_alternate_baseline_tDefaultTypeInternal _CSVCMsg_PacketEntities_alternate_baseline_t_default_instance_;
PROTOBUF_CONSTEXPR CSVCMsg_PacketEntities_non_transmitted_entities_t::CSVCMsg_PacketEntities_non_transmitted_entities_t(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.data_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.header_count_)*/0} {}
struct CSVCMsg_PacketEntities_non_transmitted_entities_tDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CSVCMsg_PacketEntities_non_transmitted_entities_tDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CSVCMsg_PacketEntities_non_transmitted_entities_tDefaultTypeInternal() {}
  union {
    CSVCMsg_PacketEntities_non_transmitted_entities_t _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CSVCMsg_PacketEntities_non_transmitted_entities_tDefaultTypeInternal _CSVCMsg_PacketEntities_non_transmitted_entities_t_default_instance_;
PROTOBUF_CONSTEXPR CSVCMsg_PacketEntities::CSVCMsg_PacketEntities(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.alternate_baselines_)*/{}
  , /*decltype(_impl_.entity_data_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.serialized_entities_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.dev_padding_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.command_queue_info_)*/nullptr
  , /*decltype(_impl_.non_transmitted_entities_)*/nullptr
  , /*decltype(_impl_.max_entries_)*/0
  , /*decltype(_impl_.updated_entries_)*/0
  , /*decltype(_impl_.baseline_)*/0
  , /*decltype(_impl_.legacy_is_delta_)*/false
  , /*decltype(_impl_.update_baseline_)*/false
  , /*decltype(_impl_.pending_full_frame_)*/false
  , /*decltype(_impl_.delta_from_)*/0
  , /*decltype(_impl_.active_spawngroup_handle_)*/0u
  , /*decltype(_impl_.max_spawngroup_creationsequence_)*/0u
  , /*decltype(_impl_.last_cmd_number_executed_)*/0u
  , /*decltype(_impl_.server_tick_)*/0u
  , /*decltype(_impl_.has_pvs_vis_bits_)*/0u
  , /*decltype(_impl_.last_cmd_number_recv_delta_)*/0
  , /*decltype(_impl_.last_cmd_recv_margin_)*/0u} {}
struct CSVCMsg_PacketEntitiesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CSVCMsg_PacketEntitiesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CSVCMsg_PacketEntitiesDefaultTypeInternal() {}
  union {
    CSVCMsg_PacketEntities _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CSVCMsg_PacketEntitiesDefaultTypeInternal _CSVCMsg_PacketEntities_default_instance_;
PROTOBUF_CONSTEXPR CSVCMsg_TempEntities::CSVCMsg_TempEntities(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.entity_data_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.reliable_)*/false
  , /*decltype(_impl_.num_entries_)*/0} {}
struct CSVCMsg_TempEntitiesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CSVCMsg_TempEntitiesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CSVCMsg_TempEntitiesDefaultTypeInternal() {}
  union {
    CSVCMsg_TempEntities _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CSVCMsg_TempEntitiesDefaultTypeInternal _CSVCMsg_TempEntities_default_instance_;
PROTOBUF_CONSTEXPR CSVCMsg_CreateStringTable::CSVCMsg_CreateStringTable(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.string_data_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.num_entries_)*/0
  , /*decltype(_impl_.user_data_size_)*/0
  , /*decltype(_impl_.user_data_size_bits_)*/0
  , /*decltype(_impl_.flags_)*/0
  , /*decltype(_impl_.user_data_fixed_size_)*/false
  , /*decltype(_impl_.data_compressed_)*/false
  , /*decltype(_impl_.using_varint_bitcounts_)*/false
  , /*decltype(_impl_.uncompressed_size_)*/0} {}
struct CSVCMsg_CreateStringTableDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CSVCMsg_CreateStringTableDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CSVCMsg_CreateStringTableDefaultTypeInternal() {}
  union {
    CSVCMsg_CreateStringTable _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CSVCMsg_CreateStringTableDefaultTypeInternal _CSVCMsg_CreateStringTable_default_instance_;
PROTOBUF_CONSTEXPR CSVCMsg_UpdateStringTable::CSVCMsg_UpdateStringTable(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.string_data_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.table_id_)*/0
  , /*decltype(_impl_.num_changed_entries_)*/0} {}
struct CSVCMsg_UpdateStringTableDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CSVCMsg_UpdateStringTableDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CSVCMsg_UpdateStringTableDefaultTypeInternal() {}
  union {
    CSVCMsg_UpdateStringTable _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CSVCMsg_UpdateStringTableDefaultTypeInternal _CSVCMsg_UpdateStringTable_default_instance_;
PROTOBUF_CONSTEXPR CSVCMsg_VoiceData::CSVCMsg_VoiceData(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.audio_)*/nullptr
  , /*decltype(_impl_.xuid_)*/uint64_t{0u}
  , /*decltype(_impl_.proximity_)*/false
  , /*decltype(_impl_.audible_mask_)*/0
  , /*decltype(_impl_.tick_)*/0u
  , /*decltype(_impl_.passthrough_)*/0
  , /*decltype(_impl_.client_)*/-1} {}
struct CSVCMsg_VoiceDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CSVCMsg_VoiceDataDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CSVCMsg_VoiceDataDefaultTypeInternal() {}
  union {
    CSVCMsg_VoiceData _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CSVCMsg_VoiceDataDefaultTypeInternal _CSVCMsg_VoiceData_default_instance_;
PROTOBUF_CONSTEXPR CSVCMsg_PacketReliable::CSVCMsg_PacketReliable(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.tick_)*/0
  , /*decltype(_impl_.messagessize_)*/0
  , /*decltype(_impl_.state_)*/false} {}
struct CSVCMsg_PacketReliableDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CSVCMsg_PacketReliableDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CSVCMsg_PacketReliableDefaultTypeInternal() {}
  union {
    CSVCMsg_PacketReliable _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CSVCMsg_PacketReliableDefaultTypeInternal _CSVCMsg_PacketReliable_default_instance_;
PROTOBUF_CONSTEXPR CSVCMsg_FullFrameSplit::CSVCMsg_FullFrameSplit(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.data_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.tick_)*/0
  , /*decltype(_impl_.section_)*/0
  , /*decltype(_impl_.total_)*/0} {}
struct CSVCMsg_FullFrameSplitDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CSVCMsg_FullFrameSplitDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CSVCMsg_FullFrameSplitDefaultTypeInternal() {}
  union {
    CSVCMsg_FullFrameSplit _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CSVCMsg_FullFrameSplitDefaultTypeInternal _CSVCMsg_FullFrameSplit_default_instance_;
PROTOBUF_CONSTEXPR CSVCMsg_HLTVStatus::CSVCMsg_HLTVStatus(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.master_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.clients_)*/0
  , /*decltype(_impl_.slots_)*/0
  , /*decltype(_impl_.proxies_)*/0} {}
struct CSVCMsg_HLTVStatusDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CSVCMsg_HLTVStatusDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CSVCMsg_HLTVStatusDefaultTypeInternal() {}
  union {
    CSVCMsg_HLTVStatus _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CSVCMsg_HLTVStatusDefaultTypeInternal _CSVCMsg_HLTVStatus_default_instance_;
PROTOBUF_CONSTEXPR CSVCMsg_ServerSteamID::CSVCMsg_ServerSteamID(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.steam_id_)*/uint64_t{0u}} {}
struct CSVCMsg_ServerSteamIDDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CSVCMsg_ServerSteamIDDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CSVCMsg_ServerSteamIDDefaultTypeInternal() {}
  union {
    CSVCMsg_ServerSteamID _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CSVCMsg_ServerSteamIDDefaultTypeInternal _CSVCMsg_ServerSteamID_default_instance_;
PROTOBUF_CONSTEXPR CSVCMsg_CmdKeyValues::CSVCMsg_CmdKeyValues(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.data_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct CSVCMsg_CmdKeyValuesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CSVCMsg_CmdKeyValuesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CSVCMsg_CmdKeyValuesDefaultTypeInternal() {}
  union {
    CSVCMsg_CmdKeyValues _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CSVCMsg_CmdKeyValuesDefaultTypeInternal _CSVCMsg_CmdKeyValues_default_instance_;
PROTOBUF_CONSTEXPR CSVCMsg_RconServerDetails::CSVCMsg_RconServerDetails(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.token_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.details_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct CSVCMsg_RconServerDetailsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CSVCMsg_RconServerDetailsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CSVCMsg_RconServerDetailsDefaultTypeInternal() {}
  union {
    CSVCMsg_RconServerDetails _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CSVCMsg_RconServerDetailsDefaultTypeInternal _CSVCMsg_RconServerDetails_default_instance_;
PROTOBUF_CONSTEXPR CMsgIPCAddress::CMsgIPCAddress(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.computer_guid_)*/uint64_t{0u}
  , /*decltype(_impl_.process_id_)*/0u} {}
struct CMsgIPCAddressDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgIPCAddressDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgIPCAddressDefaultTypeInternal() {}
  union {
    CMsgIPCAddress _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgIPCAddressDefaultTypeInternal _CMsgIPCAddress_default_instance_;
PROTOBUF_CONSTEXPR CMsgServerPeer::CMsgServerPeer(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.ipc_)*/nullptr
  , /*decltype(_impl_.steamid_)*/uint64_t{0u}
  , /*decltype(_impl_.they_hear_you_)*/false
  , /*decltype(_impl_.you_hear_them_)*/false
  , /*decltype(_impl_.is_listenserver_host_)*/false
  , /*decltype(_impl_.player_slot_)*/-1} {}
struct CMsgServerPeerDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgServerPeerDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgServerPeerDefaultTypeInternal() {}
  union {
    CMsgServerPeer _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgServerPeerDefaultTypeInternal _CMsgServerPeer_default_instance_;
PROTOBUF_CONSTEXPR CSVCMsg_PeerList::CSVCMsg_PeerList(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.peer_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CSVCMsg_PeerListDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CSVCMsg_PeerListDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CSVCMsg_PeerListDefaultTypeInternal() {}
  union {
    CSVCMsg_PeerList _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CSVCMsg_PeerListDefaultTypeInternal _CSVCMsg_PeerList_default_instance_;
PROTOBUF_CONSTEXPR CSVCMsg_ClearAllStringTables::CSVCMsg_ClearAllStringTables(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.mapname_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.create_tables_skipped_)*/false} {}
struct CSVCMsg_ClearAllStringTablesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CSVCMsg_ClearAllStringTablesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CSVCMsg_ClearAllStringTablesDefaultTypeInternal() {}
  union {
    CSVCMsg_ClearAllStringTables _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CSVCMsg_ClearAllStringTablesDefaultTypeInternal _CSVCMsg_ClearAllStringTables_default_instance_;
PROTOBUF_CONSTEXPR ProtoFlattenedSerializerField_t_polymorphic_field_t::ProtoFlattenedSerializerField_t_polymorphic_field_t(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.polymorphic_field_serializer_name_sym_)*/0
  , /*decltype(_impl_.polymorphic_field_serializer_version_)*/0} {}
struct ProtoFlattenedSerializerField_t_polymorphic_field_tDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ProtoFlattenedSerializerField_t_polymorphic_field_tDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ProtoFlattenedSerializerField_t_polymorphic_field_tDefaultTypeInternal() {}
  union {
    ProtoFlattenedSerializerField_t_polymorphic_field_t _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ProtoFlattenedSerializerField_t_polymorphic_field_tDefaultTypeInternal _ProtoFlattenedSerializerField_t_polymorphic_field_t_default_instance_;
PROTOBUF_CONSTEXPR ProtoFlattenedSerializerField_t::ProtoFlattenedSerializerField_t(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.polymorphic_types_)*/{}
  , /*decltype(_impl_.var_type_sym_)*/0
  , /*decltype(_impl_.var_name_sym_)*/0
  , /*decltype(_impl_.bit_count_)*/0
  , /*decltype(_impl_.low_value_)*/0
  , /*decltype(_impl_.high_value_)*/0
  , /*decltype(_impl_.encode_flags_)*/0
  , /*decltype(_impl_.field_serializer_name_sym_)*/0
  , /*decltype(_impl_.field_serializer_version_)*/0
  , /*decltype(_impl_.send_node_sym_)*/0
  , /*decltype(_impl_.var_encoder_sym_)*/0
  , /*decltype(_impl_.var_serializer_sym_)*/0} {}
struct ProtoFlattenedSerializerField_tDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ProtoFlattenedSerializerField_tDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ProtoFlattenedSerializerField_tDefaultTypeInternal() {}
  union {
    ProtoFlattenedSerializerField_t _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ProtoFlattenedSerializerField_tDefaultTypeInternal _ProtoFlattenedSerializerField_t_default_instance_;
PROTOBUF_CONSTEXPR ProtoFlattenedSerializer_t::ProtoFlattenedSerializer_t(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.fields_index_)*/{}
  , /*decltype(_impl_.serializer_name_sym_)*/0
  , /*decltype(_impl_.serializer_version_)*/0} {}
struct ProtoFlattenedSerializer_tDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ProtoFlattenedSerializer_tDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ProtoFlattenedSerializer_tDefaultTypeInternal() {}
  union {
    ProtoFlattenedSerializer_t _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ProtoFlattenedSerializer_tDefaultTypeInternal _ProtoFlattenedSerializer_t_default_instance_;
PROTOBUF_CONSTEXPR CSVCMsg_FlattenedSerializer::CSVCMsg_FlattenedSerializer(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.serializers_)*/{}
  , /*decltype(_impl_.symbols_)*/{}
  , /*decltype(_impl_.fields_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct CSVCMsg_FlattenedSerializerDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CSVCMsg_FlattenedSerializerDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CSVCMsg_FlattenedSerializerDefaultTypeInternal() {}
  union {
    CSVCMsg_FlattenedSerializer _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CSVCMsg_FlattenedSerializerDefaultTypeInternal _CSVCMsg_FlattenedSerializer_default_instance_;
PROTOBUF_CONSTEXPR CSVCMsg_StopSound::CSVCMsg_StopSound(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.guid_)*/0u} {}
struct CSVCMsg_StopSoundDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CSVCMsg_StopSoundDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CSVCMsg_StopSoundDefaultTypeInternal() {}
  union {
    CSVCMsg_StopSound _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CSVCMsg_StopSoundDefaultTypeInternal _CSVCMsg_StopSound_default_instance_;
PROTOBUF_CONSTEXPR CBidirMsg_RebroadcastGameEvent::CBidirMsg_RebroadcastGameEvent(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.posttoserver_)*/false
  , /*decltype(_impl_.buftype_)*/0
  , /*decltype(_impl_.receivingclients_)*/uint64_t{0u}
  , /*decltype(_impl_.clientbitcount_)*/0u} {}
struct CBidirMsg_RebroadcastGameEventDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CBidirMsg_RebroadcastGameEventDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CBidirMsg_RebroadcastGameEventDefaultTypeInternal() {}
  union {
    CBidirMsg_RebroadcastGameEvent _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CBidirMsg_RebroadcastGameEventDefaultTypeInternal _CBidirMsg_RebroadcastGameEvent_default_instance_;
PROTOBUF_CONSTEXPR CBidirMsg_RebroadcastSource::CBidirMsg_RebroadcastSource(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.eventsource_)*/0} {}
struct CBidirMsg_RebroadcastSourceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CBidirMsg_RebroadcastSourceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CBidirMsg_RebroadcastSourceDefaultTypeInternal() {}
  union {
    CBidirMsg_RebroadcastSource _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CBidirMsg_RebroadcastSourceDefaultTypeInternal _CBidirMsg_RebroadcastSource_default_instance_;
PROTOBUF_CONSTEXPR CMsgServerNetworkStats_Port::CMsgServerNetworkStats_Port(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.port_)*/0} {}
struct CMsgServerNetworkStats_PortDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgServerNetworkStats_PortDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgServerNetworkStats_PortDefaultTypeInternal() {}
  union {
    CMsgServerNetworkStats_Port _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgServerNetworkStats_PortDefaultTypeInternal _CMsgServerNetworkStats_Port_default_instance_;
PROTOBUF_CONSTEXPR CMsgServerNetworkStats_Player::CMsgServerNetworkStats_Player(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.remote_addr_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.steamid_)*/uint64_t{0u}
  , /*decltype(_impl_.ping_avg_ms_)*/0
  , /*decltype(_impl_.packet_loss_pct_)*/0
  , /*decltype(_impl_.is_bot_)*/false
  , /*decltype(_impl_.loss_in_)*/0
  , /*decltype(_impl_.loss_out_)*/0
  , /*decltype(_impl_.engine_latency_ms_)*/0} {}
struct CMsgServerNetworkStats_PlayerDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgServerNetworkStats_PlayerDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgServerNetworkStats_PlayerDefaultTypeInternal() {}
  union {
    CMsgServerNetworkStats_Player _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgServerNetworkStats_PlayerDefaultTypeInternal _CMsgServerNetworkStats_Player_default_instance_;
PROTOBUF_CONSTEXPR CMsgServerNetworkStats::CMsgServerNetworkStats(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.ports_)*/{}
  , /*decltype(_impl_.players_)*/{}
  , /*decltype(_impl_.dedicated_)*/false
  , /*decltype(_impl_.cpu_usage_)*/0
  , /*decltype(_impl_.memory_used_mb_)*/0
  , /*decltype(_impl_.memory_free_mb_)*/0
  , /*decltype(_impl_.uptime_)*/0
  , /*decltype(_impl_.spawn_count_)*/0
  , /*decltype(_impl_.num_clients_)*/0
  , /*decltype(_impl_.num_bots_)*/0
  , /*decltype(_impl_.num_spectators_)*/0
  , /*decltype(_impl_.num_tv_relays_)*/0
  , /*decltype(_impl_.fps_)*/0
  , /*decltype(_impl_.avg_ping_ms_)*/0
  , /*decltype(_impl_.avg_engine_latency_out_)*/0
  , /*decltype(_impl_.avg_packets_out_)*/0
  , /*decltype(_impl_.avg_packets_in_)*/0
  , /*decltype(_impl_.avg_loss_out_)*/0
  , /*decltype(_impl_.avg_loss_in_)*/0
  , /*decltype(_impl_.avg_data_out_)*/0
  , /*decltype(_impl_.total_data_in_)*/uint64_t{0u}
  , /*decltype(_impl_.total_packets_in_)*/uint64_t{0u}
  , /*decltype(_impl_.total_data_out_)*/uint64_t{0u}
  , /*decltype(_impl_.total_packets_out_)*/uint64_t{0u}
  , /*decltype(_impl_.avg_data_in_)*/0} {}
struct CMsgServerNetworkStatsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgServerNetworkStatsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgServerNetworkStatsDefaultTypeInternal() {}
  union {
    CMsgServerNetworkStats _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgServerNetworkStatsDefaultTypeInternal _CMsgServerNetworkStats_default_instance_;
PROTOBUF_CONSTEXPR CSVCMsg_HltvReplay::CSVCMsg_HltvReplay(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.delay_)*/0
  , /*decltype(_impl_.replay_stop_at_)*/0
  , /*decltype(_impl_.replay_start_at_)*/0
  , /*decltype(_impl_.replay_slowdown_begin_)*/0
  , /*decltype(_impl_.replay_slowdown_end_)*/0
  , /*decltype(_impl_.replay_slowdown_rate_)*/0
  , /*decltype(_impl_.reason_)*/0
  , /*decltype(_impl_.primary_target_)*/-1} {}
struct CSVCMsg_HltvReplayDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CSVCMsg_HltvReplayDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CSVCMsg_HltvReplayDefaultTypeInternal() {}
  union {
    CSVCMsg_HltvReplay _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CSVCMsg_HltvReplayDefaultTypeInternal _CSVCMsg_HltvReplay_default_instance_;
PROTOBUF_CONSTEXPR CCLCMsg_HltvReplay::CCLCMsg_HltvReplay(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.request_)*/0
  , /*decltype(_impl_.slowdown_length_)*/0
  , /*decltype(_impl_.slowdown_rate_)*/0
  , /*decltype(_impl_.event_time_)*/0
  , /*decltype(_impl_.primary_target_)*/-1} {}
struct CCLCMsg_HltvReplayDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CCLCMsg_HltvReplayDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CCLCMsg_HltvReplayDefaultTypeInternal() {}
  union {
    CCLCMsg_HltvReplay _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CCLCMsg_HltvReplayDefaultTypeInternal _CCLCMsg_HltvReplay_default_instance_;
PROTOBUF_CONSTEXPR CSVCMsg_Broadcast_Command::CSVCMsg_Broadcast_Command(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.cmd_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}} {}
struct CSVCMsg_Broadcast_CommandDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CSVCMsg_Broadcast_CommandDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CSVCMsg_Broadcast_CommandDefaultTypeInternal() {}
  union {
    CSVCMsg_Broadcast_Command _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CSVCMsg_Broadcast_CommandDefaultTypeInternal _CSVCMsg_Broadcast_Command_default_instance_;
PROTOBUF_CONSTEXPR CCLCMsg_HltvFixupOperatorTick::CCLCMsg_HltvFixupOperatorTick(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.props_data_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.origin_)*/nullptr
  , /*decltype(_impl_.eye_angles_)*/nullptr
  , /*decltype(_impl_.view_offset_)*/nullptr
  , /*decltype(_impl_.tick_)*/0
  , /*decltype(_impl_.observer_mode_)*/0
  , /*decltype(_impl_.cameraman_scoreboard_)*/false
  , /*decltype(_impl_.observer_target_)*/0} {}
struct CCLCMsg_HltvFixupOperatorTickDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CCLCMsg_HltvFixupOperatorTickDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CCLCMsg_HltvFixupOperatorTickDefaultTypeInternal() {}
  union {
    CCLCMsg_HltvFixupOperatorTick _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CCLCMsg_HltvFixupOperatorTickDefaultTypeInternal _CCLCMsg_HltvFixupOperatorTick_default_instance_;
PROTOBUF_CONSTEXPR CSVCMsg_HltvFixupOperatorStatus::CSVCMsg_HltvFixupOperatorStatus(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.override_operator_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.mode_)*/0u} {}
struct CSVCMsg_HltvFixupOperatorStatusDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CSVCMsg_HltvFixupOperatorStatusDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CSVCMsg_HltvFixupOperatorStatusDefaultTypeInternal() {}
  union {
    CSVCMsg_HltvFixupOperatorStatus _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CSVCMsg_HltvFixupOperatorStatusDefaultTypeInternal _CSVCMsg_HltvFixupOperatorStatus_default_instance_;
static ::_pb::Metadata file_level_metadata_netmessages_2eproto[71];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_netmessages_2eproto[12];
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_netmessages_2eproto = nullptr;

const uint32_t TableStruct_netmessages_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_ClientInfo, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_ClientInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_ClientInfo, _impl_.send_table_crc_),
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_ClientInfo, _impl_.server_count_),
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_ClientInfo, _impl_.is_hltv_),
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_ClientInfo, _impl_.friends_id_),
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_ClientInfo, _impl_.friends_name_),
  1,
  2,
  3,
  4,
  0,
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_Move, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_Move, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_Move, _impl_.data_),
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_Move, _impl_.command_number_),
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_Move, _impl_.num_commands_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::CMsgVoiceAudio, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgVoiceAudio, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgVoiceAudio, _impl_.format_),
  PROTOBUF_FIELD_OFFSET(::CMsgVoiceAudio, _impl_.voice_data_),
  PROTOBUF_FIELD_OFFSET(::CMsgVoiceAudio, _impl_.sequence_bytes_),
  PROTOBUF_FIELD_OFFSET(::CMsgVoiceAudio, _impl_.section_number_),
  PROTOBUF_FIELD_OFFSET(::CMsgVoiceAudio, _impl_.sample_rate_),
  PROTOBUF_FIELD_OFFSET(::CMsgVoiceAudio, _impl_.uncompressed_sample_offset_),
  PROTOBUF_FIELD_OFFSET(::CMsgVoiceAudio, _impl_.num_packets_),
  PROTOBUF_FIELD_OFFSET(::CMsgVoiceAudio, _impl_.packet_offsets_),
  PROTOBUF_FIELD_OFFSET(::CMsgVoiceAudio, _impl_.voice_level_),
  1,
  0,
  2,
  3,
  4,
  5,
  6,
  ~0u,
  7,
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_VoiceData, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_VoiceData, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_VoiceData, _impl_.audio_),
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_VoiceData, _impl_.xuid_),
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_VoiceData, _impl_.tick_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_BaselineAck, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_BaselineAck, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_BaselineAck, _impl_.baseline_tick_),
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_BaselineAck, _impl_.baseline_nr_),
  0,
  1,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_ListenEvents, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_ListenEvents, _impl_.event_mask_),
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_RespondCvarValue, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_RespondCvarValue, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_RespondCvarValue, _impl_.cookie_),
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_RespondCvarValue, _impl_.status_code_),
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_RespondCvarValue, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_RespondCvarValue, _impl_.value_),
  2,
  3,
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_FileCRCCheck, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_FileCRCCheck, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_FileCRCCheck, _impl_.code_path_),
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_FileCRCCheck, _impl_.path_),
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_FileCRCCheck, _impl_.code_filename_),
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_FileCRCCheck, _impl_.filename_),
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_FileCRCCheck, _impl_.crc_),
  2,
  0,
  3,
  1,
  4,
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_LoadingProgress, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_LoadingProgress, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_LoadingProgress, _impl_.progress_),
  0,
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_SplitPlayerConnect, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_SplitPlayerConnect, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_SplitPlayerConnect, _impl_.playername_),
  0,
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_ClientMessage, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_ClientMessage, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_ClientMessage, _impl_.msg_type_),
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_ClientMessage, _impl_.data_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_SplitPlayerDisconnect, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_SplitPlayerDisconnect, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_SplitPlayerDisconnect, _impl_.slot_),
  0,
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_ServerStatus, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_ServerStatus, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_ServerStatus, _impl_.simplified_),
  0,
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_RequestPause, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_RequestPause, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_RequestPause, _impl_.pause_type_),
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_RequestPause, _impl_.pause_group_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_CmdKeyValues, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_CmdKeyValues, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_CmdKeyValues, _impl_.data_),
  0,
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_RconServerDetails, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_RconServerDetails, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_RconServerDetails, _impl_.token_),
  0,
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_ServerInfo, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_ServerInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_ServerInfo, _impl_.protocol_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_ServerInfo, _impl_.server_count_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_ServerInfo, _impl_.is_dedicated_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_ServerInfo, _impl_.is_hltv_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_ServerInfo, _impl_.c_os_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_ServerInfo, _impl_.max_clients_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_ServerInfo, _impl_.max_classes_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_ServerInfo, _impl_.player_slot_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_ServerInfo, _impl_.tick_interval_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_ServerInfo, _impl_.game_dir_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_ServerInfo, _impl_.map_name_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_ServerInfo, _impl_.sky_name_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_ServerInfo, _impl_.host_name_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_ServerInfo, _impl_.addon_name_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_ServerInfo, _impl_.game_session_config_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_ServerInfo, _impl_.game_session_manifest_),
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  15,
  14,
  0,
  1,
  2,
  3,
  4,
  6,
  5,
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_ClassInfo_class_t, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_ClassInfo_class_t, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_ClassInfo_class_t, _impl_.class_id_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_ClassInfo_class_t, _impl_.class_name_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_ClassInfo, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_ClassInfo, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_ClassInfo, _impl_.create_on_client_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_ClassInfo, _impl_.classes_),
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_SetPause, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_SetPause, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_SetPause, _impl_.paused_),
  0,
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_VoiceInit, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_VoiceInit, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_VoiceInit, _impl_.quality_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_VoiceInit, _impl_.codec_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_VoiceInit, _impl_.version_),
  1,
  0,
  2,
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_Print, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_Print, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_Print, _impl_.text_),
  0,
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_Sounds_sounddata_t, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_Sounds_sounddata_t, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_Sounds_sounddata_t, _impl_.origin_x_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_Sounds_sounddata_t, _impl_.origin_y_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_Sounds_sounddata_t, _impl_.origin_z_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_Sounds_sounddata_t, _impl_.volume_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_Sounds_sounddata_t, _impl_.delay_value_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_Sounds_sounddata_t, _impl_.sequence_number_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_Sounds_sounddata_t, _impl_.entity_index_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_Sounds_sounddata_t, _impl_.channel_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_Sounds_sounddata_t, _impl_.pitch_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_Sounds_sounddata_t, _impl_.flags_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_Sounds_sounddata_t, _impl_.sound_num_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_Sounds_sounddata_t, _impl_.sound_num_handle_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_Sounds_sounddata_t, _impl_.speaker_entity_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_Sounds_sounddata_t, _impl_.random_seed_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_Sounds_sounddata_t, _impl_.sound_level_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_Sounds_sounddata_t, _impl_.is_sentence_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_Sounds_sounddata_t, _impl_.is_ambient_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_Sounds_sounddata_t, _impl_.guid_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_Sounds_sounddata_t, _impl_.sound_resource_id_),
  0,
  1,
  2,
  3,
  4,
  5,
  18,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  16,
  17,
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_Sounds, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_Sounds, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_Sounds, _impl_.reliable_sound_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_Sounds, _impl_.sounds_),
  0,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_Prefetch, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_Prefetch, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_Prefetch, _impl_.sound_index_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_Prefetch, _impl_.resource_type_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_SetView, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_SetView, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_SetView, _impl_.entity_index_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_SetView, _impl_.slot_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_FixAngle, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_FixAngle, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_FixAngle, _impl_.relative_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_FixAngle, _impl_.angle_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_CrosshairAngle, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_CrosshairAngle, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_CrosshairAngle, _impl_.angle_),
  0,
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_BSPDecal, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_BSPDecal, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_BSPDecal, _impl_.pos_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_BSPDecal, _impl_.decal_texture_index_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_BSPDecal, _impl_.entity_index_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_BSPDecal, _impl_.model_index_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_BSPDecal, _impl_.low_priority_),
  0,
  1,
  4,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_SplitScreen, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_SplitScreen, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_SplitScreen, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_SplitScreen, _impl_.slot_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_SplitScreen, _impl_.player_index_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_GetCvarValue, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_GetCvarValue, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_GetCvarValue, _impl_.cookie_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_GetCvarValue, _impl_.cvar_name_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_Menu, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_Menu, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_Menu, _impl_.dialog_type_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_Menu, _impl_.menu_key_values_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_UserMessage, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_UserMessage, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_UserMessage, _impl_.msg_type_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_UserMessage, _impl_.msg_data_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_UserMessage, _impl_.passthrough_),
  1,
  0,
  2,
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_SendTable_sendprop_t, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_SendTable_sendprop_t, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_SendTable_sendprop_t, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_SendTable_sendprop_t, _impl_.var_name_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_SendTable_sendprop_t, _impl_.flags_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_SendTable_sendprop_t, _impl_.priority_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_SendTable_sendprop_t, _impl_.dt_name_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_SendTable_sendprop_t, _impl_.num_elements_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_SendTable_sendprop_t, _impl_.low_value_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_SendTable_sendprop_t, _impl_.high_value_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_SendTable_sendprop_t, _impl_.num_bits_),
  2,
  0,
  3,
  4,
  1,
  5,
  6,
  7,
  8,
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_SendTable, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_SendTable, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_SendTable, _impl_.is_end_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_SendTable, _impl_.net_table_name_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_SendTable, _impl_.needs_decoder_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_SendTable, _impl_.props_),
  1,
  0,
  2,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_GameEventList_key_t, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_GameEventList_key_t, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_GameEventList_key_t, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_GameEventList_key_t, _impl_.name_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_GameEventList_descriptor_t, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_GameEventList_descriptor_t, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_GameEventList_descriptor_t, _impl_.eventid_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_GameEventList_descriptor_t, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_GameEventList_descriptor_t, _impl_.keys_),
  1,
  0,
  ~0u,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_GameEventList, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_GameEventList, _impl_.descriptors_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_PacketEntities_command_queue_info_t, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_PacketEntities_command_queue_info_t, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_PacketEntities_command_queue_info_t, _impl_.commands_queued_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_PacketEntities_command_queue_info_t, _impl_.command_queue_desired_size_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_PacketEntities_command_queue_info_t, _impl_.starved_command_ticks_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_PacketEntities_command_queue_info_t, _impl_.time_dilation_percent_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_PacketEntities_command_queue_info_t, _impl_.discarded_command_ticks_),
  0,
  1,
  2,
  3,
  4,
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_PacketEntities_alternate_baseline_t, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_PacketEntities_alternate_baseline_t, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_PacketEntities_alternate_baseline_t, _impl_.entity_index_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_PacketEntities_alternate_baseline_t, _impl_.baseline_index_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_PacketEntities_non_transmitted_entities_t, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_PacketEntities_non_transmitted_entities_t, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_PacketEntities_non_transmitted_entities_t, _impl_.header_count_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_PacketEntities_non_transmitted_entities_t, _impl_.data_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_PacketEntities, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_PacketEntities, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_PacketEntities, _impl_.max_entries_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_PacketEntities, _impl_.updated_entries_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_PacketEntities, _impl_.legacy_is_delta_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_PacketEntities, _impl_.update_baseline_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_PacketEntities, _impl_.baseline_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_PacketEntities, _impl_.delta_from_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_PacketEntities, _impl_.entity_data_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_PacketEntities, _impl_.pending_full_frame_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_PacketEntities, _impl_.active_spawngroup_handle_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_PacketEntities, _impl_.max_spawngroup_creationsequence_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_PacketEntities, _impl_.last_cmd_number_executed_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_PacketEntities, _impl_.last_cmd_number_recv_delta_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_PacketEntities, _impl_.server_tick_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_PacketEntities, _impl_.serialized_entities_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_PacketEntities, _impl_.command_queue_info_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_PacketEntities, _impl_.alternate_baselines_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_PacketEntities, _impl_.has_pvs_vis_bits_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_PacketEntities, _impl_.last_cmd_recv_margin_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_PacketEntities, _impl_.non_transmitted_entities_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_PacketEntities, _impl_.dev_padding_),
  5,
  6,
  8,
  9,
  7,
  11,
  0,
  10,
  12,
  13,
  14,
  17,
  15,
  1,
  3,
  ~0u,
  16,
  18,
  4,
  2,
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_TempEntities, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_TempEntities, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_TempEntities, _impl_.reliable_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_TempEntities, _impl_.num_entries_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_TempEntities, _impl_.entity_data_),
  1,
  2,
  0,
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_CreateStringTable, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_CreateStringTable, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_CreateStringTable, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_CreateStringTable, _impl_.num_entries_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_CreateStringTable, _impl_.user_data_fixed_size_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_CreateStringTable, _impl_.user_data_size_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_CreateStringTable, _impl_.user_data_size_bits_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_CreateStringTable, _impl_.flags_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_CreateStringTable, _impl_.string_data_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_CreateStringTable, _impl_.uncompressed_size_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_CreateStringTable, _impl_.data_compressed_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_CreateStringTable, _impl_.using_varint_bitcounts_),
  0,
  2,
  6,
  3,
  4,
  5,
  1,
  9,
  7,
  8,
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_UpdateStringTable, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_UpdateStringTable, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_UpdateStringTable, _impl_.table_id_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_UpdateStringTable, _impl_.num_changed_entries_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_UpdateStringTable, _impl_.string_data_),
  1,
  2,
  0,
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_VoiceData, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_VoiceData, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_VoiceData, _impl_.audio_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_VoiceData, _impl_.client_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_VoiceData, _impl_.proximity_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_VoiceData, _impl_.xuid_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_VoiceData, _impl_.audible_mask_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_VoiceData, _impl_.tick_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_VoiceData, _impl_.passthrough_),
  0,
  6,
  2,
  1,
  3,
  4,
  5,
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_PacketReliable, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_PacketReliable, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_PacketReliable, _impl_.tick_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_PacketReliable, _impl_.messagessize_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_PacketReliable, _impl_.state_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_FullFrameSplit, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_FullFrameSplit, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_FullFrameSplit, _impl_.tick_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_FullFrameSplit, _impl_.section_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_FullFrameSplit, _impl_.total_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_FullFrameSplit, _impl_.data_),
  1,
  2,
  3,
  0,
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_HLTVStatus, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_HLTVStatus, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_HLTVStatus, _impl_.master_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_HLTVStatus, _impl_.clients_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_HLTVStatus, _impl_.slots_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_HLTVStatus, _impl_.proxies_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_ServerSteamID, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_ServerSteamID, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_ServerSteamID, _impl_.steam_id_),
  0,
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_CmdKeyValues, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_CmdKeyValues, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_CmdKeyValues, _impl_.data_),
  0,
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_RconServerDetails, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_RconServerDetails, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_RconServerDetails, _impl_.token_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_RconServerDetails, _impl_.details_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::CMsgIPCAddress, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgIPCAddress, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgIPCAddress, _impl_.computer_guid_),
  PROTOBUF_FIELD_OFFSET(::CMsgIPCAddress, _impl_.process_id_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::CMsgServerPeer, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgServerPeer, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgServerPeer, _impl_.player_slot_),
  PROTOBUF_FIELD_OFFSET(::CMsgServerPeer, _impl_.steamid_),
  PROTOBUF_FIELD_OFFSET(::CMsgServerPeer, _impl_.ipc_),
  PROTOBUF_FIELD_OFFSET(::CMsgServerPeer, _impl_.they_hear_you_),
  PROTOBUF_FIELD_OFFSET(::CMsgServerPeer, _impl_.you_hear_them_),
  PROTOBUF_FIELD_OFFSET(::CMsgServerPeer, _impl_.is_listenserver_host_),
  5,
  1,
  0,
  2,
  3,
  4,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_PeerList, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_PeerList, _impl_.peer_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_ClearAllStringTables, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_ClearAllStringTables, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_ClearAllStringTables, _impl_.mapname_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_ClearAllStringTables, _impl_.create_tables_skipped_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::ProtoFlattenedSerializerField_t_polymorphic_field_t, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::ProtoFlattenedSerializerField_t_polymorphic_field_t, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ProtoFlattenedSerializerField_t_polymorphic_field_t, _impl_.polymorphic_field_serializer_name_sym_),
  PROTOBUF_FIELD_OFFSET(::ProtoFlattenedSerializerField_t_polymorphic_field_t, _impl_.polymorphic_field_serializer_version_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::ProtoFlattenedSerializerField_t, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::ProtoFlattenedSerializerField_t, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ProtoFlattenedSerializerField_t, _impl_.var_type_sym_),
  PROTOBUF_FIELD_OFFSET(::ProtoFlattenedSerializerField_t, _impl_.var_name_sym_),
  PROTOBUF_FIELD_OFFSET(::ProtoFlattenedSerializerField_t, _impl_.bit_count_),
  PROTOBUF_FIELD_OFFSET(::ProtoFlattenedSerializerField_t, _impl_.low_value_),
  PROTOBUF_FIELD_OFFSET(::ProtoFlattenedSerializerField_t, _impl_.high_value_),
  PROTOBUF_FIELD_OFFSET(::ProtoFlattenedSerializerField_t, _impl_.encode_flags_),
  PROTOBUF_FIELD_OFFSET(::ProtoFlattenedSerializerField_t, _impl_.field_serializer_name_sym_),
  PROTOBUF_FIELD_OFFSET(::ProtoFlattenedSerializerField_t, _impl_.field_serializer_version_),
  PROTOBUF_FIELD_OFFSET(::ProtoFlattenedSerializerField_t, _impl_.send_node_sym_),
  PROTOBUF_FIELD_OFFSET(::ProtoFlattenedSerializerField_t, _impl_.var_encoder_sym_),
  PROTOBUF_FIELD_OFFSET(::ProtoFlattenedSerializerField_t, _impl_.polymorphic_types_),
  PROTOBUF_FIELD_OFFSET(::ProtoFlattenedSerializerField_t, _impl_.var_serializer_sym_),
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  ~0u,
  10,
  PROTOBUF_FIELD_OFFSET(::ProtoFlattenedSerializer_t, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::ProtoFlattenedSerializer_t, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::ProtoFlattenedSerializer_t, _impl_.serializer_name_sym_),
  PROTOBUF_FIELD_OFFSET(::ProtoFlattenedSerializer_t, _impl_.serializer_version_),
  PROTOBUF_FIELD_OFFSET(::ProtoFlattenedSerializer_t, _impl_.fields_index_),
  0,
  1,
  ~0u,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_FlattenedSerializer, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_FlattenedSerializer, _impl_.serializers_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_FlattenedSerializer, _impl_.symbols_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_FlattenedSerializer, _impl_.fields_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_StopSound, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_StopSound, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_StopSound, _impl_.guid_),
  0,
  PROTOBUF_FIELD_OFFSET(::CBidirMsg_RebroadcastGameEvent, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CBidirMsg_RebroadcastGameEvent, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CBidirMsg_RebroadcastGameEvent, _impl_.posttoserver_),
  PROTOBUF_FIELD_OFFSET(::CBidirMsg_RebroadcastGameEvent, _impl_.buftype_),
  PROTOBUF_FIELD_OFFSET(::CBidirMsg_RebroadcastGameEvent, _impl_.clientbitcount_),
  PROTOBUF_FIELD_OFFSET(::CBidirMsg_RebroadcastGameEvent, _impl_.receivingclients_),
  0,
  1,
  3,
  2,
  PROTOBUF_FIELD_OFFSET(::CBidirMsg_RebroadcastSource, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CBidirMsg_RebroadcastSource, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CBidirMsg_RebroadcastSource, _impl_.eventsource_),
  0,
  PROTOBUF_FIELD_OFFSET(::CMsgServerNetworkStats_Port, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgServerNetworkStats_Port, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgServerNetworkStats_Port, _impl_.port_),
  PROTOBUF_FIELD_OFFSET(::CMsgServerNetworkStats_Port, _impl_.name_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::CMsgServerNetworkStats_Player, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgServerNetworkStats_Player, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgServerNetworkStats_Player, _impl_.steamid_),
  PROTOBUF_FIELD_OFFSET(::CMsgServerNetworkStats_Player, _impl_.remote_addr_),
  PROTOBUF_FIELD_OFFSET(::CMsgServerNetworkStats_Player, _impl_.ping_avg_ms_),
  PROTOBUF_FIELD_OFFSET(::CMsgServerNetworkStats_Player, _impl_.packet_loss_pct_),
  PROTOBUF_FIELD_OFFSET(::CMsgServerNetworkStats_Player, _impl_.is_bot_),
  PROTOBUF_FIELD_OFFSET(::CMsgServerNetworkStats_Player, _impl_.loss_in_),
  PROTOBUF_FIELD_OFFSET(::CMsgServerNetworkStats_Player, _impl_.loss_out_),
  PROTOBUF_FIELD_OFFSET(::CMsgServerNetworkStats_Player, _impl_.engine_latency_ms_),
  1,
  0,
  2,
  3,
  4,
  5,
  6,
  7,
  PROTOBUF_FIELD_OFFSET(::CMsgServerNetworkStats, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgServerNetworkStats, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgServerNetworkStats, _impl_.dedicated_),
  PROTOBUF_FIELD_OFFSET(::CMsgServerNetworkStats, _impl_.cpu_usage_),
  PROTOBUF_FIELD_OFFSET(::CMsgServerNetworkStats, _impl_.memory_used_mb_),
  PROTOBUF_FIELD_OFFSET(::CMsgServerNetworkStats, _impl_.memory_free_mb_),
  PROTOBUF_FIELD_OFFSET(::CMsgServerNetworkStats, _impl_.uptime_),
  PROTOBUF_FIELD_OFFSET(::CMsgServerNetworkStats, _impl_.spawn_count_),
  PROTOBUF_FIELD_OFFSET(::CMsgServerNetworkStats, _impl_.num_clients_),
  PROTOBUF_FIELD_OFFSET(::CMsgServerNetworkStats, _impl_.num_bots_),
  PROTOBUF_FIELD_OFFSET(::CMsgServerNetworkStats, _impl_.num_spectators_),
  PROTOBUF_FIELD_OFFSET(::CMsgServerNetworkStats, _impl_.num_tv_relays_),
  PROTOBUF_FIELD_OFFSET(::CMsgServerNetworkStats, _impl_.fps_),
  PROTOBUF_FIELD_OFFSET(::CMsgServerNetworkStats, _impl_.ports_),
  PROTOBUF_FIELD_OFFSET(::CMsgServerNetworkStats, _impl_.avg_ping_ms_),
  PROTOBUF_FIELD_OFFSET(::CMsgServerNetworkStats, _impl_.avg_engine_latency_out_),
  PROTOBUF_FIELD_OFFSET(::CMsgServerNetworkStats, _impl_.avg_packets_out_),
  PROTOBUF_FIELD_OFFSET(::CMsgServerNetworkStats, _impl_.avg_packets_in_),
  PROTOBUF_FIELD_OFFSET(::CMsgServerNetworkStats, _impl_.avg_loss_out_),
  PROTOBUF_FIELD_OFFSET(::CMsgServerNetworkStats, _impl_.avg_loss_in_),
  PROTOBUF_FIELD_OFFSET(::CMsgServerNetworkStats, _impl_.avg_data_out_),
  PROTOBUF_FIELD_OFFSET(::CMsgServerNetworkStats, _impl_.avg_data_in_),
  PROTOBUF_FIELD_OFFSET(::CMsgServerNetworkStats, _impl_.total_data_in_),
  PROTOBUF_FIELD_OFFSET(::CMsgServerNetworkStats, _impl_.total_packets_in_),
  PROTOBUF_FIELD_OFFSET(::CMsgServerNetworkStats, _impl_.total_data_out_),
  PROTOBUF_FIELD_OFFSET(::CMsgServerNetworkStats, _impl_.total_packets_out_),
  PROTOBUF_FIELD_OFFSET(::CMsgServerNetworkStats, _impl_.players_),
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  ~0u,
  11,
  12,
  13,
  14,
  15,
  16,
  17,
  22,
  18,
  19,
  20,
  21,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_HltvReplay, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_HltvReplay, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_HltvReplay, _impl_.delay_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_HltvReplay, _impl_.primary_target_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_HltvReplay, _impl_.replay_stop_at_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_HltvReplay, _impl_.replay_start_at_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_HltvReplay, _impl_.replay_slowdown_begin_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_HltvReplay, _impl_.replay_slowdown_end_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_HltvReplay, _impl_.replay_slowdown_rate_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_HltvReplay, _impl_.reason_),
  0,
  7,
  1,
  2,
  3,
  4,
  5,
  6,
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_HltvReplay, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_HltvReplay, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_HltvReplay, _impl_.request_),
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_HltvReplay, _impl_.slowdown_length_),
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_HltvReplay, _impl_.slowdown_rate_),
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_HltvReplay, _impl_.primary_target_),
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_HltvReplay, _impl_.event_time_),
  0,
  1,
  2,
  4,
  3,
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_Broadcast_Command, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_Broadcast_Command, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_Broadcast_Command, _impl_.cmd_),
  0,
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_HltvFixupOperatorTick, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_HltvFixupOperatorTick, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_HltvFixupOperatorTick, _impl_.tick_),
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_HltvFixupOperatorTick, _impl_.props_data_),
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_HltvFixupOperatorTick, _impl_.origin_),
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_HltvFixupOperatorTick, _impl_.eye_angles_),
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_HltvFixupOperatorTick, _impl_.observer_mode_),
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_HltvFixupOperatorTick, _impl_.cameraman_scoreboard_),
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_HltvFixupOperatorTick, _impl_.observer_target_),
  PROTOBUF_FIELD_OFFSET(::CCLCMsg_HltvFixupOperatorTick, _impl_.view_offset_),
  4,
  0,
  1,
  2,
  5,
  6,
  7,
  3,
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_HltvFixupOperatorStatus, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_HltvFixupOperatorStatus, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_HltvFixupOperatorStatus, _impl_.mode_),
  PROTOBUF_FIELD_OFFSET(::CSVCMsg_HltvFixupOperatorStatus, _impl_.override_operator_name_),
  1,
  0,
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 11, -1, sizeof(::CCLCMsg_ClientInfo)},
  { 16, 25, -1, sizeof(::CCLCMsg_Move)},
  { 28, 43, -1, sizeof(::CMsgVoiceAudio)},
  { 52, 61, -1, sizeof(::CCLCMsg_VoiceData)},
  { 64, 72, -1, sizeof(::CCLCMsg_BaselineAck)},
  { 74, -1, -1, sizeof(::CCLCMsg_ListenEvents)},
  { 81, 91, -1, sizeof(::CCLCMsg_RespondCvarValue)},
  { 95, 106, -1, sizeof(::CCLCMsg_FileCRCCheck)},
  { 111, 118, -1, sizeof(::CCLCMsg_LoadingProgress)},
  { 119, 126, -1, sizeof(::CCLCMsg_SplitPlayerConnect)},
  { 127, 135, -1, sizeof(::CCLCMsg_ClientMessage)},
  { 137, 144, -1, sizeof(::CCLCMsg_SplitPlayerDisconnect)},
  { 145, 152, -1, sizeof(::CCLCMsg_ServerStatus)},
  { 153, 161, -1, sizeof(::CCLCMsg_RequestPause)},
  { 163, 170, -1, sizeof(::CCLCMsg_CmdKeyValues)},
  { 171, 178, -1, sizeof(::CCLCMsg_RconServerDetails)},
  { 179, 201, -1, sizeof(::CSVCMsg_ServerInfo)},
  { 217, 225, -1, sizeof(::CSVCMsg_ClassInfo_class_t)},
  { 227, 235, -1, sizeof(::CSVCMsg_ClassInfo)},
  { 237, 244, -1, sizeof(::CSVCMsg_SetPause)},
  { 245, 254, -1, sizeof(::CSVCMsg_VoiceInit)},
  { 257, 264, -1, sizeof(::CSVCMsg_Print)},
  { 265, 290, -1, sizeof(::CSVCMsg_Sounds_sounddata_t)},
  { 309, 317, -1, sizeof(::CSVCMsg_Sounds)},
  { 319, 327, -1, sizeof(::CSVCMsg_Prefetch)},
  { 329, 337, -1, sizeof(::CSVCMsg_SetView)},
  { 339, 347, -1, sizeof(::CSVCMsg_FixAngle)},
  { 349, 356, -1, sizeof(::CSVCMsg_CrosshairAngle)},
  { 357, 368, -1, sizeof(::CSVCMsg_BSPDecal)},
  { 373, 382, -1, sizeof(::CSVCMsg_SplitScreen)},
  { 385, 393, -1, sizeof(::CSVCMsg_GetCvarValue)},
  { 395, 403, -1, sizeof(::CSVCMsg_Menu)},
  { 405, 414, -1, sizeof(::CSVCMsg_UserMessage)},
  { 417, 432, -1, sizeof(::CSVCMsg_SendTable_sendprop_t)},
  { 441, 451, -1, sizeof(::CSVCMsg_SendTable)},
  { 455, 463, -1, sizeof(::CSVCMsg_GameEventList_key_t)},
  { 465, 474, -1, sizeof(::CSVCMsg_GameEventList_descriptor_t)},
  { 477, -1, -1, sizeof(::CSVCMsg_GameEventList)},
  { 484, 495, -1, sizeof(::CSVCMsg_PacketEntities_command_queue_info_t)},
  { 500, 508, -1, sizeof(::CSVCMsg_PacketEntities_alternate_baseline_t)},
  { 510, 518, -1, sizeof(::CSVCMsg_PacketEntities_non_transmitted_entities_t)},
  { 520, 546, -1, sizeof(::CSVCMsg_PacketEntities)},
  { 566, 575, -1, sizeof(::CSVCMsg_TempEntities)},
  { 578, 594, -1, sizeof(::CSVCMsg_CreateStringTable)},
  { 604, 613, -1, sizeof(::CSVCMsg_UpdateStringTable)},
  { 616, 629, -1, sizeof(::CSVCMsg_VoiceData)},
  { 636, 645, -1, sizeof(::CSVCMsg_PacketReliable)},
  { 648, 658, -1, sizeof(::CSVCMsg_FullFrameSplit)},
  { 662, 672, -1, sizeof(::CSVCMsg_HLTVStatus)},
  { 676, 683, -1, sizeof(::CSVCMsg_ServerSteamID)},
  { 684, 691, -1, sizeof(::CSVCMsg_CmdKeyValues)},
  { 692, 700, -1, sizeof(::CSVCMsg_RconServerDetails)},
  { 702, 710, -1, sizeof(::CMsgIPCAddress)},
  { 712, 724, -1, sizeof(::CMsgServerPeer)},
  { 730, -1, -1, sizeof(::CSVCMsg_PeerList)},
  { 737, 745, -1, sizeof(::CSVCMsg_ClearAllStringTables)},
  { 747, 755, -1, sizeof(::ProtoFlattenedSerializerField_t_polymorphic_field_t)},
  { 757, 775, -1, sizeof(::ProtoFlattenedSerializerField_t)},
  { 787, 796, -1, sizeof(::ProtoFlattenedSerializer_t)},
  { 799, -1, -1, sizeof(::CSVCMsg_FlattenedSerializer)},
  { 808, 815, -1, sizeof(::CSVCMsg_StopSound)},
  { 816, 826, -1, sizeof(::CBidirMsg_RebroadcastGameEvent)},
  { 830, 837, -1, sizeof(::CBidirMsg_RebroadcastSource)},
  { 838, 846, -1, sizeof(::CMsgServerNetworkStats_Port)},
  { 848, 862, -1, sizeof(::CMsgServerNetworkStats_Player)},
  { 870, 901, -1, sizeof(::CMsgServerNetworkStats)},
  { 926, 940, -1, sizeof(::CSVCMsg_HltvReplay)},
  { 948, 959, -1, sizeof(::CCLCMsg_HltvReplay)},
  { 964, 971, -1, sizeof(::CSVCMsg_Broadcast_Command)},
  { 972, 986, -1, sizeof(::CCLCMsg_HltvFixupOperatorTick)},
  { 994, 1002, -1, sizeof(::CSVCMsg_HltvFixupOperatorStatus)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::_CCLCMsg_ClientInfo_default_instance_._instance,
  &::_CCLCMsg_Move_default_instance_._instance,
  &::_CMsgVoiceAudio_default_instance_._instance,
  &::_CCLCMsg_VoiceData_default_instance_._instance,
  &::_CCLCMsg_BaselineAck_default_instance_._instance,
  &::_CCLCMsg_ListenEvents_default_instance_._instance,
  &::_CCLCMsg_RespondCvarValue_default_instance_._instance,
  &::_CCLCMsg_FileCRCCheck_default_instance_._instance,
  &::_CCLCMsg_LoadingProgress_default_instance_._instance,
  &::_CCLCMsg_SplitPlayerConnect_default_instance_._instance,
  &::_CCLCMsg_ClientMessage_default_instance_._instance,
  &::_CCLCMsg_SplitPlayerDisconnect_default_instance_._instance,
  &::_CCLCMsg_ServerStatus_default_instance_._instance,
  &::_CCLCMsg_RequestPause_default_instance_._instance,
  &::_CCLCMsg_CmdKeyValues_default_instance_._instance,
  &::_CCLCMsg_RconServerDetails_default_instance_._instance,
  &::_CSVCMsg_ServerInfo_default_instance_._instance,
  &::_CSVCMsg_ClassInfo_class_t_default_instance_._instance,
  &::_CSVCMsg_ClassInfo_default_instance_._instance,
  &::_CSVCMsg_SetPause_default_instance_._instance,
  &::_CSVCMsg_VoiceInit_default_instance_._instance,
  &::_CSVCMsg_Print_default_instance_._instance,
  &::_CSVCMsg_Sounds_sounddata_t_default_instance_._instance,
  &::_CSVCMsg_Sounds_default_instance_._instance,
  &::_CSVCMsg_Prefetch_default_instance_._instance,
  &::_CSVCMsg_SetView_default_instance_._instance,
  &::_CSVCMsg_FixAngle_default_instance_._instance,
  &::_CSVCMsg_CrosshairAngle_default_instance_._instance,
  &::_CSVCMsg_BSPDecal_default_instance_._instance,
  &::_CSVCMsg_SplitScreen_default_instance_._instance,
  &::_CSVCMsg_GetCvarValue_default_instance_._instance,
  &::_CSVCMsg_Menu_default_instance_._instance,
  &::_CSVCMsg_UserMessage_default_instance_._instance,
  &::_CSVCMsg_SendTable_sendprop_t_default_instance_._instance,
  &::_CSVCMsg_SendTable_default_instance_._instance,
  &::_CSVCMsg_GameEventList_key_t_default_instance_._instance,
  &::_CSVCMsg_GameEventList_descriptor_t_default_instance_._instance,
  &::_CSVCMsg_GameEventList_default_instance_._instance,
  &::_CSVCMsg_PacketEntities_command_queue_info_t_default_instance_._instance,
  &::_CSVCMsg_PacketEntities_alternate_baseline_t_default_instance_._instance,
  &::_CSVCMsg_PacketEntities_non_transmitted_entities_t_default_instance_._instance,
  &::_CSVCMsg_PacketEntities_default_instance_._instance,
  &::_CSVCMsg_TempEntities_default_instance_._instance,
  &::_CSVCMsg_CreateStringTable_default_instance_._instance,
  &::_CSVCMsg_UpdateStringTable_default_instance_._instance,
  &::_CSVCMsg_VoiceData_default_instance_._instance,
  &::_CSVCMsg_PacketReliable_default_instance_._instance,
  &::_CSVCMsg_FullFrameSplit_default_instance_._instance,
  &::_CSVCMsg_HLTVStatus_default_instance_._instance,
  &::_CSVCMsg_ServerSteamID_default_instance_._instance,
  &::_CSVCMsg_CmdKeyValues_default_instance_._instance,
  &::_CSVCMsg_RconServerDetails_default_instance_._instance,
  &::_CMsgIPCAddress_default_instance_._instance,
  &::_CMsgServerPeer_default_instance_._instance,
  &::_CSVCMsg_PeerList_default_instance_._instance,
  &::_CSVCMsg_ClearAllStringTables_default_instance_._instance,
  &::_ProtoFlattenedSerializerField_t_polymorphic_field_t_default_instance_._instance,
  &::_ProtoFlattenedSerializerField_t_default_instance_._instance,
  &::_ProtoFlattenedSerializer_t_default_instance_._instance,
  &::_CSVCMsg_FlattenedSerializer_default_instance_._instance,
  &::_CSVCMsg_StopSound_default_instance_._instance,
  &::_CBidirMsg_RebroadcastGameEvent_default_instance_._instance,
  &::_CBidirMsg_RebroadcastSource_default_instance_._instance,
  &::_CMsgServerNetworkStats_Port_default_instance_._instance,
  &::_CMsgServerNetworkStats_Player_default_instance_._instance,
  &::_CMsgServerNetworkStats_default_instance_._instance,
  &::_CSVCMsg_HltvReplay_default_instance_._instance,
  &::_CCLCMsg_HltvReplay_default_instance_._instance,
  &::_CSVCMsg_Broadcast_Command_default_instance_._instance,
  &::_CCLCMsg_HltvFixupOperatorTick_default_instance_._instance,
  &::_CSVCMsg_HltvFixupOperatorStatus_default_instance_._instance,
};

const char descriptor_table_protodef_netmessages_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\021netmessages.proto\032\026networkbasetypes.pr"
  "oto\"}\n\022CCLCMsg_ClientInfo\022\026\n\016send_table_"
  "crc\030\001 \001(\007\022\024\n\014server_count\030\002 \001(\r\022\017\n\007is_hl"
  "tv\030\003 \001(\010\022\022\n\nfriends_id\030\005 \001(\r\022\024\n\014friends_"
  "name\030\006 \001(\t\"J\n\014CCLCMsg_Move\022\014\n\004data\030\003 \001(\014"
  "\022\026\n\016command_number\030\004 \001(\r\022\024\n\014num_commands"
  "\030\005 \001(\r\"\217\002\n\016CMsgVoiceAudio\022:\n\006format\030\001 \001("
  "\0162\022.VoiceDataFormat_t:\026VOICEDATA_FORMAT_"
  "STEAM\022\022\n\nvoice_data\030\002 \001(\014\022\026\n\016sequence_by"
  "tes\030\003 \001(\005\022\026\n\016section_number\030\004 \001(\r\022\023\n\013sam"
  "ple_rate\030\005 \001(\r\022\"\n\032uncompressed_sample_of"
  "fset\030\006 \001(\r\022\023\n\013num_packets\030\007 \001(\r\022\032\n\016packe"
  "t_offsets\030\010 \003(\rB\002\020\001\022\023\n\013voice_level\030\t \001(\002"
  "\"O\n\021CCLCMsg_VoiceData\022\036\n\005audio\030\001 \001(\0132\017.C"
  "MsgVoiceAudio\022\014\n\004xuid\030\002 \001(\006\022\014\n\004tick\030\003 \001("
  "\r\"A\n\023CCLCMsg_BaselineAck\022\025\n\rbaseline_tic"
  "k\030\001 \001(\005\022\023\n\013baseline_nr\030\002 \001(\005\"*\n\024CCLCMsg_"
  "ListenEvents\022\022\n\nevent_mask\030\001 \003(\007\"\\\n\030CCLC"
  "Msg_RespondCvarValue\022\016\n\006cookie\030\001 \001(\005\022\023\n\013"
  "status_code\030\002 \001(\005\022\014\n\004name\030\003 \001(\t\022\r\n\005value"
  "\030\004 \001(\t\"m\n\024CCLCMsg_FileCRCCheck\022\021\n\tcode_p"
  "ath\030\001 \001(\005\022\014\n\004path\030\002 \001(\t\022\025\n\rcode_filename"
  "\030\003 \001(\005\022\020\n\010filename\030\004 \001(\t\022\013\n\003crc\030\005 \001(\007\"+\n"
  "\027CCLCMsg_LoadingProgress\022\020\n\010progress\030\001 \001"
  "(\005\"0\n\032CCLCMsg_SplitPlayerConnect\022\022\n\nplay"
  "ername\030\001 \001(\t\"7\n\025CCLCMsg_ClientMessage\022\020\n"
  "\010msg_type\030\001 \001(\005\022\014\n\004data\030\002 \001(\014\"-\n\035CCLCMsg"
  "_SplitPlayerDisconnect\022\014\n\004slot\030\001 \001(\005\"*\n\024"
  "CCLCMsg_ServerStatus\022\022\n\nsimplified\030\001 \001(\010"
  "\"Z\n\024CCLCMsg_RequestPause\022-\n\npause_type\030\001"
  " \001(\0162\017.RequestPause_t:\010RP_PAUSE\022\023\n\013pause"
  "_group\030\002 \001(\005\"$\n\024CCLCMsg_CmdKeyValues\022\014\n\004"
  "data\030\001 \001(\014\"*\n\031CCLCMsg_RconServerDetails\022"
  "\r\n\005token\030\001 \001(\014\"\207\003\n\022CSVCMsg_ServerInfo\022\020\n"
  "\010protocol\030\001 \001(\005\022\024\n\014server_count\030\002 \001(\005\022\024\n"
  "\014is_dedicated\030\003 \001(\010\022\017\n\007is_hltv\030\004 \001(\010\022\014\n\004"
  "c_os\030\006 \001(\005\022\023\n\013max_clients\030\n \001(\005\022\023\n\013max_c"
  "lasses\030\013 \001(\005\022\027\n\013player_slot\030\014 \001(\005:\002-1\022\025\n"
  "\rtick_interval\030\r \001(\002\022\020\n\010game_dir\030\016 \001(\t\022\020"
  "\n\010map_name\030\017 \001(\t\022\020\n\010sky_name\030\020 \001(\t\022\021\n\tho"
  "st_name\030\021 \001(\t\022\022\n\naddon_name\030\022 \001(\t\022>\n\023gam"
  "e_session_config\030\023 \001(\0132!.CSVCMsg_GameSes"
  "sionConfiguration\022\035\n\025game_session_manife"
  "st\030\024 \001(\014\"\213\001\n\021CSVCMsg_ClassInfo\022\030\n\020create"
  "_on_client\030\001 \001(\010\022+\n\007classes\030\002 \003(\0132\032.CSVC"
  "Msg_ClassInfo.class_t\032/\n\007class_t\022\020\n\010clas"
  "s_id\030\001 \001(\005\022\022\n\nclass_name\030\003 \001(\t\"\"\n\020CSVCMs"
  "g_SetPause\022\016\n\006paused\030\001 \001(\010\"G\n\021CSVCMsg_Vo"
  "iceInit\022\017\n\007quality\030\001 \001(\005\022\r\n\005codec\030\002 \001(\t\022"
  "\022\n\007version\030\003 \001(\005:\0010\"\035\n\rCSVCMsg_Print\022\014\n\004"
  "text\030\001 \001(\t\"\343\003\n\016CSVCMsg_Sounds\022\026\n\016reliabl"
  "e_sound\030\001 \001(\010\022+\n\006sounds\030\002 \003(\0132\033.CSVCMsg_"
  "Sounds.sounddata_t\032\213\003\n\013sounddata_t\022\020\n\010or"
  "igin_x\030\001 \001(\021\022\020\n\010origin_y\030\002 \001(\021\022\020\n\010origin"
  "_z\030\003 \001(\021\022\016\n\006volume\030\004 \001(\r\022\023\n\013delay_value\030"
  "\005 \001(\002\022\027\n\017sequence_number\030\006 \001(\005\022\030\n\014entity"
  "_index\030\007 \001(\005:\002-1\022\017\n\007channel\030\010 \001(\005\022\r\n\005pit"
  "ch\030\t \001(\005\022\r\n\005flags\030\n \001(\005\022\021\n\tsound_num\030\013 \001"
  "(\r\022\030\n\020sound_num_handle\030\014 \001(\007\022\026\n\016speaker_"
  "entity\030\r \001(\005\022\023\n\013random_seed\030\016 \001(\005\022\023\n\013sou"
  "nd_level\030\017 \001(\005\022\023\n\013is_sentence\030\020 \001(\010\022\022\n\ni"
  "s_ambient\030\021 \001(\010\022\014\n\004guid\030\022 \001(\r\022\031\n\021sound_r"
  "esource_id\030\023 \001(\006\"X\n\020CSVCMsg_Prefetch\022\023\n\013"
  "sound_index\030\001 \001(\005\022/\n\rresource_type\030\002 \001(\016"
  "2\r.PrefetchType:\tPFT_SOUND\"=\n\017CSVCMsg_Se"
  "tView\022\030\n\014entity_index\030\001 \001(\005:\002-1\022\020\n\004slot\030"
  "\002 \001(\005:\002-1\"@\n\020CSVCMsg_FixAngle\022\020\n\010relativ"
  "e\030\001 \001(\010\022\032\n\005angle\030\002 \001(\0132\013.CMsgQAngle\"4\n\026C"
  "SVCMsg_CrosshairAngle\022\032\n\005angle\030\001 \001(\0132\013.C"
  "MsgQAngle\"\216\001\n\020CSVCMsg_BSPDecal\022\030\n\003pos\030\001 "
  "\001(\0132\013.CMsgVector\022\033\n\023decal_texture_index\030"
  "\002 \001(\005\022\030\n\014entity_index\030\003 \001(\005:\002-1\022\023\n\013model"
  "_index\030\004 \001(\005\022\024\n\014low_priority\030\005 \001(\010\"~\n\023CS"
  "VCMsg_SplitScreen\022\?\n\004type\030\001 \001(\0162\030.ESplit"
  "ScreenMessageType:\027MSG_SPLITSCREEN_ADDUS"
  "ER\022\014\n\004slot\030\002 \001(\005\022\030\n\014player_index\030\003 \001(\005:\002"
  "-1\"9\n\024CSVCMsg_GetCvarValue\022\016\n\006cookie\030\001 \001"
  "(\005\022\021\n\tcvar_name\030\002 \001(\t\"<\n\014CSVCMsg_Menu\022\023\n"
  "\013dialog_type\030\001 \001(\005\022\027\n\017menu_key_values\030\002 "
  "\001(\014\"N\n\023CSVCMsg_UserMessage\022\020\n\010msg_type\030\001"
  " \001(\005\022\020\n\010msg_data\030\002 \001(\014\022\023\n\013passthrough\030\003 "
  "\001(\005\"\260\002\n\021CSVCMsg_SendTable\022\016\n\006is_end\030\001 \001("
  "\010\022\026\n\016net_table_name\030\002 \001(\t\022\025\n\rneeds_decod"
  "er\030\003 \001(\010\022,\n\005props\030\004 \003(\0132\035.CSVCMsg_SendTa"
  "ble.sendprop_t\032\255\001\n\nsendprop_t\022\014\n\004type\030\001 "
  "\001(\005\022\020\n\010var_name\030\002 \001(\t\022\r\n\005flags\030\003 \001(\005\022\020\n\010"
  "priority\030\004 \001(\005\022\017\n\007dt_name\030\005 \001(\t\022\024\n\014num_e"
  "lements\030\006 \001(\005\022\021\n\tlow_value\030\007 \001(\002\022\022\n\nhigh"
  "_value\030\010 \001(\002\022\020\n\010num_bits\030\t \001(\005\"\321\001\n\025CSVCM"
  "sg_GameEventList\0228\n\013descriptors\030\001 \003(\0132#."
  "CSVCMsg_GameEventList.descriptor_t\032#\n\005ke"
  "y_t\022\014\n\004type\030\001 \001(\005\022\014\n\004name\030\002 \001(\t\032Y\n\014descr"
  "iptor_t\022\017\n\007eventid\030\001 \001(\005\022\014\n\004name\030\002 \001(\t\022*"
  "\n\004keys\030\003 \003(\0132\034.CSVCMsg_GameEventList.key"
  "_t\"\210\010\n\026CSVCMsg_PacketEntities\022\023\n\013max_ent"
  "ries\030\001 \001(\005\022\027\n\017updated_entries\030\002 \001(\005\022\027\n\017l"
  "egacy_is_delta\030\003 \001(\010\022\027\n\017update_baseline\030"
  "\004 \001(\010\022\020\n\010baseline\030\005 \001(\005\022\022\n\ndelta_from\030\006 "
  "\001(\005\022\023\n\013entity_data\030\007 \001(\014\022\032\n\022pending_full"
  "_frame\030\010 \001(\010\022 \n\030active_spawngroup_handle"
  "\030\t \001(\r\022\'\n\037max_spawngroup_creationsequenc"
  "e\030\n \001(\r\022 \n\030last_cmd_number_executed\030\013 \001("
  "\r\022\"\n\032last_cmd_number_recv_delta\030\021 \001(\021\022\023\n"
  "\013server_tick\030\014 \001(\r\022\033\n\023serialized_entitie"
  "s\030\r \001(\014\022H\n\022command_queue_info\030\016 \001(\0132,.CS"
  "VCMsg_PacketEntities.command_queue_info_"
  "t\022I\n\023alternate_baselines\030\017 \003(\0132,.CSVCMsg"
  "_PacketEntities.alternate_baseline_t\022\030\n\020"
  "has_pvs_vis_bits\030\020 \001(\r\022\034\n\024last_cmd_recv_"
  "margin\030\022 \001(\r\022T\n\030non_transmitted_entities"
  "\030\023 \001(\01322.CSVCMsg_PacketEntities.non_tran"
  "smitted_entities_t\022\024\n\013dev_padding\030\347\007 \001(\014"
  "\032\262\001\n\024command_queue_info_t\022\027\n\017commands_qu"
  "eued\030\001 \001(\r\022\"\n\032command_queue_desired_size"
  "\030\002 \001(\r\022\035\n\025starved_command_ticks\030\003 \001(\r\022\035\n"
  "\025time_dilation_percent\030\004 \001(\002\022\037\n\027discarde"
  "d_command_ticks\030\005 \001(\r\032D\n\024alternate_basel"
  "ine_t\022\024\n\014entity_index\030\001 \001(\005\022\026\n\016baseline_"
  "index\030\002 \001(\005\032@\n\032non_transmitted_entities_"
  "t\022\024\n\014header_count\030\001 \001(\005\022\014\n\004data\030\002 \001(\014\"R\n"
  "\024CSVCMsg_TempEntities\022\020\n\010reliable\030\001 \001(\010\022"
  "\023\n\013num_entries\030\002 \001(\005\022\023\n\013entity_data\030\003 \001("
  "\014\"\211\002\n\031CSVCMsg_CreateStringTable\022\014\n\004name\030"
  "\001 \001(\t\022\023\n\013num_entries\030\002 \001(\005\022\034\n\024user_data_"
  "fixed_size\030\003 \001(\010\022\026\n\016user_data_size\030\004 \001(\005"
  "\022\033\n\023user_data_size_bits\030\005 \001(\005\022\r\n\005flags\030\006"
  " \001(\005\022\023\n\013string_data\030\007 \001(\014\022\031\n\021uncompresse"
  "d_size\030\010 \001(\005\022\027\n\017data_compressed\030\t \001(\010\022\036\n"
  "\026using_varint_bitcounts\030\n \001(\010\"_\n\031CSVCMsg"
  "_UpdateStringTable\022\020\n\010table_id\030\001 \001(\005\022\033\n\023"
  "num_changed_entries\030\002 \001(\005\022\023\n\013string_data"
  "\030\003 \001(\014\"\241\001\n\021CSVCMsg_VoiceData\022\036\n\005audio\030\001 "
  "\001(\0132\017.CMsgVoiceAudio\022\022\n\006client\030\002 \001(\005:\002-1"
  "\022\021\n\tproximity\030\003 \001(\010\022\014\n\004xuid\030\004 \001(\006\022\024\n\014aud"
  "ible_mask\030\005 \001(\005\022\014\n\004tick\030\006 \001(\r\022\023\n\013passthr"
  "ough\030\007 \001(\005\"K\n\026CSVCMsg_PacketReliable\022\014\n\004"
  "tick\030\001 \001(\005\022\024\n\014messagessize\030\002 \001(\005\022\r\n\005stat"
  "e\030\003 \001(\010\"T\n\026CSVCMsg_FullFrameSplit\022\014\n\004tic"
  "k\030\001 \001(\005\022\017\n\007section\030\002 \001(\005\022\r\n\005total\030\003 \001(\005\022"
  "\014\n\004data\030\004 \001(\014\"U\n\022CSVCMsg_HLTVStatus\022\016\n\006m"
  "aster\030\001 \001(\t\022\017\n\007clients\030\002 \001(\005\022\r\n\005slots\030\003 "
  "\001(\005\022\017\n\007proxies\030\004 \001(\005\")\n\025CSVCMsg_ServerSt"
  "eamID\022\020\n\010steam_id\030\001 \001(\004\"$\n\024CSVCMsg_CmdKe"
  "yValues\022\014\n\004data\030\001 \001(\014\";\n\031CSVCMsg_RconSer"
  "verDetails\022\r\n\005token\030\001 \001(\014\022\017\n\007details\030\002 \001"
  "(\t\";\n\016CMsgIPCAddress\022\025\n\rcomputer_guid\030\001 "
  "\001(\006\022\022\n\nprocess_id\030\002 \001(\r\"\244\001\n\016CMsgServerPe"
  "er\022\027\n\013player_slot\030\001 \001(\005:\002-1\022\017\n\007steamid\030\002"
  " \001(\006\022\034\n\003ipc\030\003 \001(\0132\017.CMsgIPCAddress\022\025\n\rth"
  "ey_hear_you\030\004 \001(\010\022\025\n\ryou_hear_them\030\005 \001(\010"
  "\022\034\n\024is_listenserver_host\030\006 \001(\010\"1\n\020CSVCMs"
  "g_PeerList\022\035\n\004peer\030\001 \003(\0132\017.CMsgServerPee"
  "r\"N\n\034CSVCMsg_ClearAllStringTables\022\017\n\007map"
  "name\030\001 \001(\t\022\035\n\025create_tables_skipped\030\003 \001("
  "\010\"\363\003\n\037ProtoFlattenedSerializerField_t\022\024\n"
  "\014var_type_sym\030\001 \001(\005\022\024\n\014var_name_sym\030\002 \001("
  "\005\022\021\n\tbit_count\030\003 \001(\005\022\021\n\tlow_value\030\004 \001(\002\022"
  "\022\n\nhigh_value\030\005 \001(\002\022\024\n\014encode_flags\030\006 \001("
  "\005\022!\n\031field_serializer_name_sym\030\007 \001(\005\022 \n\030"
  "field_serializer_version\030\010 \001(\005\022\025\n\rsend_n"
  "ode_sym\030\t \001(\005\022\027\n\017var_encoder_sym\030\n \001(\005\022O"
  "\n\021polymorphic_types\030\013 \003(\01324.ProtoFlatten"
  "edSerializerField_t.polymorphic_field_t\022"
  "\032\n\022var_serializer_sym\030\014 \001(\005\032r\n\023polymorph"
  "ic_field_t\022-\n%polymorphic_field_serializ"
  "er_name_sym\030\001 \001(\005\022,\n$polymorphic_field_s"
  "erializer_version\030\002 \001(\005\"k\n\032ProtoFlattene"
  "dSerializer_t\022\033\n\023serializer_name_sym\030\001 \001"
  "(\005\022\032\n\022serializer_version\030\002 \001(\005\022\024\n\014fields"
  "_index\030\003 \003(\005\"\222\001\n\033CSVCMsg_FlattenedSerial"
  "izer\0220\n\013serializers\030\001 \003(\0132\033.ProtoFlatten"
  "edSerializer_t\022\017\n\007symbols\030\002 \003(\t\0220\n\006field"
  "s\030\003 \003(\0132 .ProtoFlattenedSerializerField_"
  "t\"!\n\021CSVCMsg_StopSound\022\014\n\004guid\030\001 \001(\007\"y\n\036"
  "CBidirMsg_RebroadcastGameEvent\022\024\n\014postto"
  "server\030\001 \001(\010\022\017\n\007buftype\030\002 \001(\005\022\026\n\016clientb"
  "itcount\030\003 \001(\r\022\030\n\020receivingclients\030\004 \001(\004\""
  "2\n\033CBidirMsg_RebroadcastSource\022\023\n\013events"
  "ource\030\001 \001(\005\"\305\006\n\026CMsgServerNetworkStats\022\021"
  "\n\tdedicated\030\001 \001(\010\022\021\n\tcpu_usage\030\002 \001(\005\022\026\n\016"
  "memory_used_mb\030\003 \001(\005\022\026\n\016memory_free_mb\030\004"
  " \001(\005\022\016\n\006uptime\030\005 \001(\005\022\023\n\013spawn_count\030\006 \001("
  "\005\022\023\n\013num_clients\030\010 \001(\005\022\020\n\010num_bots\030\t \001(\005"
  "\022\026\n\016num_spectators\030\n \001(\005\022\025\n\rnum_tv_relay"
  "s\030\013 \001(\005\022\013\n\003fps\030\014 \001(\002\022+\n\005ports\030\021 \003(\0132\034.CM"
  "sgServerNetworkStats.Port\022\023\n\013avg_ping_ms"
  "\030\022 \001(\002\022\036\n\026avg_engine_latency_out\030\023 \001(\002\022\027"
  "\n\017avg_packets_out\030\024 \001(\002\022\026\n\016avg_packets_i"
  "n\030\025 \001(\002\022\024\n\014avg_loss_out\030\026 \001(\002\022\023\n\013avg_los"
  "s_in\030\027 \001(\002\022\024\n\014avg_data_out\030\030 \001(\002\022\023\n\013avg_"
  "data_in\030\031 \001(\002\022\025\n\rtotal_data_in\030\032 \001(\004\022\030\n\020"
  "total_packets_in\030\033 \001(\004\022\026\n\016total_data_out"
  "\030\034 \001(\004\022\031\n\021total_packets_out\030\035 \001(\004\022/\n\007pla"
  "yers\030\036 \003(\0132\036.CMsgServerNetworkStats.Play"
  "er\032\"\n\004Port\022\014\n\004port\030\001 \001(\005\022\014\n\004name\030\002 \001(\t\032\252"
  "\001\n\006Player\022\017\n\007steamid\030\001 \001(\004\022\023\n\013remote_add"
  "r\030\002 \001(\t\022\023\n\013ping_avg_ms\030\004 \001(\005\022\027\n\017packet_l"
  "oss_pct\030\005 \001(\002\022\016\n\006is_bot\030\006 \001(\010\022\017\n\007loss_in"
  "\030\007 \001(\002\022\020\n\010loss_out\030\010 \001(\002\022\031\n\021engine_laten"
  "cy_ms\030\t \001(\005\"\332\001\n\022CSVCMsg_HltvReplay\022\r\n\005de"
  "lay\030\001 \001(\005\022\032\n\016primary_target\030\002 \001(\005:\002-1\022\026\n"
  "\016replay_stop_at\030\003 \001(\005\022\027\n\017replay_start_at"
  "\030\004 \001(\005\022\035\n\025replay_slowdown_begin\030\005 \001(\005\022\033\n"
  "\023replay_slowdown_end\030\006 \001(\005\022\034\n\024replay_slo"
  "wdown_rate\030\007 \001(\002\022\016\n\006reason\030\010 \001(\005\"\205\001\n\022CCL"
  "CMsg_HltvReplay\022\017\n\007request\030\001 \001(\005\022\027\n\017slow"
  "down_length\030\002 \001(\002\022\025\n\rslowdown_rate\030\003 \001(\002"
  "\022\032\n\016primary_target\030\004 \001(\005:\002-1\022\022\n\nevent_ti"
  "me\030\005 \001(\002\"(\n\031CSVCMsg_Broadcast_Command\022\013\n"
  "\003cmd\030\001 \001(\t\"\357\001\n\035CCLCMsg_HltvFixupOperator"
  "Tick\022\014\n\004tick\030\001 \001(\005\022\022\n\nprops_data\030\002 \001(\014\022\033"
  "\n\006origin\030\003 \001(\0132\013.CMsgVector\022\037\n\neye_angle"
  "s\030\004 \001(\0132\013.CMsgQAngle\022\025\n\robserver_mode\030\005 "
  "\001(\005\022\034\n\024cameraman_scoreboard\030\006 \001(\010\022\027\n\017obs"
  "erver_target\030\007 \001(\005\022 \n\013view_offset\030\010 \001(\0132"
  "\013.CMsgVector\"O\n\037CSVCMsg_HltvFixupOperato"
  "rStatus\022\014\n\004mode\030\001 \001(\r\022\036\n\026override_operat"
  "or_name\030\002 \001(\t*\216\003\n\014CLC_Messages\022\022\n\016clc_Cl"
  "ientInfo\020\024\022\014\n\010clc_Move\020\025\022\021\n\rclc_VoiceDat"
  "a\020\026\022\023\n\017clc_BaselineAck\020\027\022\024\n\020clc_ListenEv"
  "ents\020\030\022\030\n\024clc_RespondCvarValue\020\031\022\024\n\020clc_"
  "FileCRCCheck\020\032\022\027\n\023clc_LoadingProgress\020\033\022"
  "\032\n\026clc_SplitPlayerConnect\020\034\022\025\n\021clc_Clien"
  "tMessage\020\035\022\035\n\031clc_SplitPlayerDisconnect\020"
  "\036\022\024\n\020clc_ServerStatus\020\037\022\022\n\016clc_ServerPin"
  "g\020 \022\024\n\020clc_RequestPause\020!\022\024\n\020clc_CmdKeyV"
  "alues\020\"\022\031\n\025clc_RconServerDetails\020#\022\022\n\016cl"
  "c_HltvReplay\020$*\231\005\n\014SVC_Messages\022\022\n\016svc_S"
  "erverInfo\020(\022\033\n\027svc_FlattenedSerializer\020)"
  "\022\021\n\rsvc_ClassInfo\020*\022\020\n\014svc_SetPause\020+\022\031\n"
  "\025svc_CreateStringTable\020,\022\031\n\025svc_UpdateSt"
  "ringTable\020-\022\021\n\rsvc_VoiceInit\020.\022\021\n\rsvc_Vo"
  "iceData\020/\022\r\n\tsvc_Print\0200\022\016\n\nsvc_Sounds\0201"
  "\022\017\n\013svc_SetView\0202\022\034\n\030svc_ClearAllStringT"
  "ables\0203\022\024\n\020svc_CmdKeyValues\0204\022\020\n\014svc_BSP"
  "Decal\0205\022\023\n\017svc_SplitScreen\0206\022\026\n\022svc_Pack"
  "etEntities\0207\022\020\n\014svc_Prefetch\0208\022\014\n\010svc_Me"
  "nu\0209\022\024\n\020svc_GetCvarValue\020:\022\021\n\rsvc_StopSo"
  "und\020;\022\020\n\014svc_PeerList\020<\022\026\n\022svc_PacketRel"
  "iable\020=\022\022\n\016svc_HLTVStatus\020>\022\025\n\021svc_Serve"
  "rSteamID\020\?\022\026\n\022svc_FullFrameSplit\020F\022\031\n\025sv"
  "c_RconServerDetails\020G\022\023\n\017svc_UserMessage"
  "\020H\022\022\n\016svc_HltvReplay\020I\022\031\n\025svc_Broadcast_"
  "Command\020J\022\037\n\033svc_HltvFixupOperatorStatus"
  "\020K*g\n\021VoiceDataFormat_t\022\032\n\026VOICEDATA_FOR"
  "MAT_STEAM\020\000\022\033\n\027VOICEDATA_FORMAT_ENGINE\020\001"
  "\022\031\n\025VOICEDATA_FORMAT_OPUS\020\002*B\n\016RequestPa"
  "use_t\022\014\n\010RP_PAUSE\020\000\022\016\n\nRP_UNPAUSE\020\001\022\022\n\016R"
  "P_TOGGLEPAUSE\020\002*\035\n\014PrefetchType\022\r\n\tPFT_S"
  "OUND\020\000*V\n\027ESplitScreenMessageType\022\033\n\027MSG"
  "_SPLITSCREEN_ADDUSER\020\000\022\036\n\032MSG_SPLITSCREE"
  "N_REMOVEUSER\020\001*\263\001\n\025EQueryCvarValueStatus"
  "\022%\n!eQueryCvarValueStatus_ValueIntact\020\000\022"
  "&\n\"eQueryCvarValueStatus_CvarNotFound\020\001\022"
  "\"\n\036eQueryCvarValueStatus_NotACvar\020\002\022\'\n#e"
  "QueryCvarValueStatus_CvarProtected\020\003*h\n\013"
  "DIALOG_TYPE\022\016\n\nDIALOG_MSG\020\000\022\017\n\013DIALOG_ME"
  "NU\020\001\022\017\n\013DIALOG_TEXT\020\002\022\020\n\014DIALOG_ENTRY\020\003\022"
  "\025\n\021DIALOG_ASKCONNECT\020\004*+\n\031SVC_Messages_L"
  "owFrequency\022\016\n\tsvc_dummy\020\330\004*a\n\026Bidirecti"
  "onal_Messages\022\033\n\027bi_RebroadcastGameEvent"
  "\020\020\022\030\n\024bi_RebroadcastSource\020\021\022\020\n\014bi_GameE"
  "vent\020\022*M\n#Bidirectional_Messages_LowFreq"
  "uency\022\021\n\014bi_RelayInfo\020\274\005\022\023\n\016bi_RelayPack"
  "et\020\275\005*\241\001\n\021ReplayEventType_t\022\027\n\023REPLAY_EV"
  "ENT_CANCEL\020\000\022\026\n\022REPLAY_EVENT_DEATH\020\001\022\030\n\024"
  "REPLAY_EVENT_GENERIC\020\002\022\'\n#REPLAY_EVENT_S"
  "TUCK_NEED_FULL_UPDATE\020\003\022\030\n\024REPLAY_EVENT_"
  "VICTORY\020\004"
  ;
static const ::_pbi::DescriptorTable* const descriptor_table_netmessages_2eproto_deps[1] = {
  &::descriptor_table_networkbasetypes_2eproto,
};
static ::_pbi::once_flag descriptor_table_netmessages_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_netmessages_2eproto = {
    false, false, 10729, descriptor_table_protodef_netmessages_2eproto,
    "netmessages.proto",
    &descriptor_table_netmessages_2eproto_once, descriptor_table_netmessages_2eproto_deps, 1, 71,
    schemas, file_default_instances, TableStruct_netmessages_2eproto::offsets,
    file_level_metadata_netmessages_2eproto, file_level_enum_descriptors_netmessages_2eproto,
    file_level_service_descriptors_netmessages_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_netmessages_2eproto_getter() {
  return &descriptor_table_netmessages_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_netmessages_2eproto(&descriptor_table_netmessages_2eproto);
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* CLC_Messages_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_netmessages_2eproto);
  return file_level_enum_descriptors_netmessages_2eproto[0];
}
bool CLC_Messages_IsValid(int value) {
  switch (value) {
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
    case 29:
    case 30:
    case 31:
    case 32:
    case 33:
    case 34:
    case 35:
    case 36:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SVC_Messages_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_netmessages_2eproto);
  return file_level_enum_descriptors_netmessages_2eproto[1];
}
bool SVC_Messages_IsValid(int value) {
  switch (value) {
    case 40:
    case 41:
    case 42:
    case 43:
    case 44:
    case 45:
    case 46:
    case 47:
    case 48:
    case 49:
    case 50:
    case 51:
    case 52:
    case 53:
    case 54:
    case 55:
    case 56:
    case 57:
    case 58:
    case 59:
    case 60:
    case 61:
    case 62:
    case 63:
    case 70:
    case 71:
    case 72:
    case 73:
    case 74:
    case 75:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* VoiceDataFormat_t_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_netmessages_2eproto);
  return file_level_enum_descriptors_netmessages_2eproto[2];
}
bool VoiceDataFormat_t_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* RequestPause_t_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_netmessages_2eproto);
  return file_level_enum_descriptors_netmessages_2eproto[3];
}
bool RequestPause_t_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* PrefetchType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_netmessages_2eproto);
  return file_level_enum_descriptors_netmessages_2eproto[4];
}
bool PrefetchType_IsValid(int value) {
  switch (value) {
    case 0:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ESplitScreenMessageType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_netmessages_2eproto);
  return file_level_enum_descriptors_netmessages_2eproto[5];
}
bool ESplitScreenMessageType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EQueryCvarValueStatus_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_netmessages_2eproto);
  return file_level_enum_descriptors_netmessages_2eproto[6];
}
bool EQueryCvarValueStatus_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* DIALOG_TYPE_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_netmessages_2eproto);
  return file_level_enum_descriptors_netmessages_2eproto[7];
}
bool DIALOG_TYPE_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SVC_Messages_LowFrequency_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_netmessages_2eproto);
  return file_level_enum_descriptors_netmessages_2eproto[8];
}
bool SVC_Messages_LowFrequency_IsValid(int value) {
  switch (value) {
    case 600:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Bidirectional_Messages_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_netmessages_2eproto);
  return file_level_enum_descriptors_netmessages_2eproto[9];
}
bool Bidirectional_Messages_IsValid(int value) {
  switch (value) {
    case 16:
    case 17:
    case 18:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Bidirectional_Messages_LowFrequency_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_netmessages_2eproto);
  return file_level_enum_descriptors_netmessages_2eproto[10];
}
bool Bidirectional_Messages_LowFrequency_IsValid(int value) {
  switch (value) {
    case 700:
    case 701:
      return true;
    default:
      return false;
  }
}

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ReplayEventType_t_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_netmessages_2eproto);
  return file_level_enum_descriptors_netmessages_2eproto[11];
}
bool ReplayEventType_t_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}


// ===================================================================

class CCLCMsg_ClientInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<CCLCMsg_ClientInfo>()._impl_._has_bits_);
  static void set_has_send_table_crc(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_server_count(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_is_hltv(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_friends_id(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_friends_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CCLCMsg_ClientInfo::CCLCMsg_ClientInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CCLCMsg_ClientInfo)
}
CCLCMsg_ClientInfo::CCLCMsg_ClientInfo(const CCLCMsg_ClientInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CCLCMsg_ClientInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.friends_name_){}
    , decltype(_impl_.send_table_crc_){}
    , decltype(_impl_.server_count_){}
    , decltype(_impl_.is_hltv_){}
    , decltype(_impl_.friends_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.friends_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.friends_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_friends_name()) {
    _this->_impl_.friends_name_.Set(from._internal_friends_name(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.send_table_crc_, &from._impl_.send_table_crc_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.friends_id_) -
    reinterpret_cast<char*>(&_impl_.send_table_crc_)) + sizeof(_impl_.friends_id_));
  // @@protoc_insertion_point(copy_constructor:CCLCMsg_ClientInfo)
}

inline void CCLCMsg_ClientInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.friends_name_){}
    , decltype(_impl_.send_table_crc_){0u}
    , decltype(_impl_.server_count_){0u}
    , decltype(_impl_.is_hltv_){false}
    , decltype(_impl_.friends_id_){0u}
  };
  _impl_.friends_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.friends_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CCLCMsg_ClientInfo::~CCLCMsg_ClientInfo() {
  // @@protoc_insertion_point(destructor:CCLCMsg_ClientInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CCLCMsg_ClientInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.friends_name_.Destroy();
}

void CCLCMsg_ClientInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CCLCMsg_ClientInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:CCLCMsg_ClientInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.friends_name_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000001eu) {
    ::memset(&_impl_.send_table_crc_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.friends_id_) -
        reinterpret_cast<char*>(&_impl_.send_table_crc_)) + sizeof(_impl_.friends_id_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CCLCMsg_ClientInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional fixed32 send_table_crc = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _Internal::set_has_send_table_crc(&has_bits);
          _impl_.send_table_crc_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 server_count = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_server_count(&has_bits);
          _impl_.server_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_hltv = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_is_hltv(&has_bits);
          _impl_.is_hltv_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 friends_id = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_friends_id(&has_bits);
          _impl_.friends_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string friends_name = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          auto str = _internal_mutable_friends_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CCLCMsg_ClientInfo.friends_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CCLCMsg_ClientInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CCLCMsg_ClientInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional fixed32 send_table_crc = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(1, this->_internal_send_table_crc(), target);
  }

  // optional uint32 server_count = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_server_count(), target);
  }

  // optional bool is_hltv = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_is_hltv(), target);
  }

  // optional uint32 friends_id = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_friends_id(), target);
  }

  // optional string friends_name = 6;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_friends_name().data(), static_cast<int>(this->_internal_friends_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CCLCMsg_ClientInfo.friends_name");
    target = stream->WriteStringMaybeAliased(
        6, this->_internal_friends_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CCLCMsg_ClientInfo)
  return target;
}

size_t CCLCMsg_ClientInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CCLCMsg_ClientInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string friends_name = 6;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_friends_name());
    }

    // optional fixed32 send_table_crc = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

    // optional uint32 server_count = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_server_count());
    }

    // optional bool is_hltv = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

    // optional uint32 friends_id = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_friends_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CCLCMsg_ClientInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CCLCMsg_ClientInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CCLCMsg_ClientInfo::GetClassData() const { return &_class_data_; }


void CCLCMsg_ClientInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CCLCMsg_ClientInfo*>(&to_msg);
  auto& from = static_cast<const CCLCMsg_ClientInfo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CCLCMsg_ClientInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_friends_name(from._internal_friends_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.send_table_crc_ = from._impl_.send_table_crc_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.server_count_ = from._impl_.server_count_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.is_hltv_ = from._impl_.is_hltv_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.friends_id_ = from._impl_.friends_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CCLCMsg_ClientInfo::CopyFrom(const CCLCMsg_ClientInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CCLCMsg_ClientInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CCLCMsg_ClientInfo::IsInitialized() const {
  return true;
}

void CCLCMsg_ClientInfo::InternalSwap(CCLCMsg_ClientInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.friends_name_, lhs_arena,
      &other->_impl_.friends_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CCLCMsg_ClientInfo, _impl_.friends_id_)
      + sizeof(CCLCMsg_ClientInfo::_impl_.friends_id_)
      - PROTOBUF_FIELD_OFFSET(CCLCMsg_ClientInfo, _impl_.send_table_crc_)>(
          reinterpret_cast<char*>(&_impl_.send_table_crc_),
          reinterpret_cast<char*>(&other->_impl_.send_table_crc_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CCLCMsg_ClientInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[0]);
}

// ===================================================================

class CCLCMsg_Move::_Internal {
 public:
  using HasBits = decltype(std::declval<CCLCMsg_Move>()._impl_._has_bits_);
  static void set_has_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_command_number(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_num_commands(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

CCLCMsg_Move::CCLCMsg_Move(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CCLCMsg_Move)
}
CCLCMsg_Move::CCLCMsg_Move(const CCLCMsg_Move& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CCLCMsg_Move* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.data_){}
    , decltype(_impl_.command_number_){}
    , decltype(_impl_.num_commands_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_data()) {
    _this->_impl_.data_.Set(from._internal_data(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.command_number_, &from._impl_.command_number_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.num_commands_) -
    reinterpret_cast<char*>(&_impl_.command_number_)) + sizeof(_impl_.num_commands_));
  // @@protoc_insertion_point(copy_constructor:CCLCMsg_Move)
}

inline void CCLCMsg_Move::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.data_){}
    , decltype(_impl_.command_number_){0u}
    , decltype(_impl_.num_commands_){0u}
  };
  _impl_.data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CCLCMsg_Move::~CCLCMsg_Move() {
  // @@protoc_insertion_point(destructor:CCLCMsg_Move)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CCLCMsg_Move::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.data_.Destroy();
}

void CCLCMsg_Move::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CCLCMsg_Move::Clear() {
// @@protoc_insertion_point(message_clear_start:CCLCMsg_Move)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.data_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.command_number_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.num_commands_) -
        reinterpret_cast<char*>(&_impl_.command_number_)) + sizeof(_impl_.num_commands_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CCLCMsg_Move::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes data = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 command_number = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_command_number(&has_bits);
          _impl_.command_number_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 num_commands = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_num_commands(&has_bits);
          _impl_.num_commands_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CCLCMsg_Move::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CCLCMsg_Move)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes data = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_data(), target);
  }

  // optional uint32 command_number = 4;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_command_number(), target);
  }

  // optional uint32 num_commands = 5;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_num_commands(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CCLCMsg_Move)
  return target;
}

size_t CCLCMsg_Move::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CCLCMsg_Move)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional bytes data = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_data());
    }

    // optional uint32 command_number = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_command_number());
    }

    // optional uint32 num_commands = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_num_commands());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CCLCMsg_Move::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CCLCMsg_Move::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CCLCMsg_Move::GetClassData() const { return &_class_data_; }


void CCLCMsg_Move::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CCLCMsg_Move*>(&to_msg);
  auto& from = static_cast<const CCLCMsg_Move&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CCLCMsg_Move)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_data(from._internal_data());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.command_number_ = from._impl_.command_number_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.num_commands_ = from._impl_.num_commands_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CCLCMsg_Move::CopyFrom(const CCLCMsg_Move& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CCLCMsg_Move)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CCLCMsg_Move::IsInitialized() const {
  return true;
}

void CCLCMsg_Move::InternalSwap(CCLCMsg_Move* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.data_, lhs_arena,
      &other->_impl_.data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CCLCMsg_Move, _impl_.num_commands_)
      + sizeof(CCLCMsg_Move::_impl_.num_commands_)
      - PROTOBUF_FIELD_OFFSET(CCLCMsg_Move, _impl_.command_number_)>(
          reinterpret_cast<char*>(&_impl_.command_number_),
          reinterpret_cast<char*>(&other->_impl_.command_number_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CCLCMsg_Move::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[1]);
}

// ===================================================================

class CMsgVoiceAudio::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgVoiceAudio>()._impl_._has_bits_);
  static void set_has_format(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_voice_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_sequence_bytes(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_section_number(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_sample_rate(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_uncompressed_sample_offset(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_num_packets(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_voice_level(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
};

CMsgVoiceAudio::CMsgVoiceAudio(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgVoiceAudio)
}
CMsgVoiceAudio::CMsgVoiceAudio(const CMsgVoiceAudio& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgVoiceAudio* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.packet_offsets_){from._impl_.packet_offsets_}
    , /*decltype(_impl_._packet_offsets_cached_byte_size_)*/{0}
    , decltype(_impl_.voice_data_){}
    , decltype(_impl_.format_){}
    , decltype(_impl_.sequence_bytes_){}
    , decltype(_impl_.section_number_){}
    , decltype(_impl_.sample_rate_){}
    , decltype(_impl_.uncompressed_sample_offset_){}
    , decltype(_impl_.num_packets_){}
    , decltype(_impl_.voice_level_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.voice_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.voice_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_voice_data()) {
    _this->_impl_.voice_data_.Set(from._internal_voice_data(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.format_, &from._impl_.format_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.voice_level_) -
    reinterpret_cast<char*>(&_impl_.format_)) + sizeof(_impl_.voice_level_));
  // @@protoc_insertion_point(copy_constructor:CMsgVoiceAudio)
}

inline void CMsgVoiceAudio::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.packet_offsets_){arena}
    , /*decltype(_impl_._packet_offsets_cached_byte_size_)*/{0}
    , decltype(_impl_.voice_data_){}
    , decltype(_impl_.format_){0}
    , decltype(_impl_.sequence_bytes_){0}
    , decltype(_impl_.section_number_){0u}
    , decltype(_impl_.sample_rate_){0u}
    , decltype(_impl_.uncompressed_sample_offset_){0u}
    , decltype(_impl_.num_packets_){0u}
    , decltype(_impl_.voice_level_){0}
  };
  _impl_.voice_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.voice_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgVoiceAudio::~CMsgVoiceAudio() {
  // @@protoc_insertion_point(destructor:CMsgVoiceAudio)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgVoiceAudio::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.packet_offsets_.~RepeatedField();
  _impl_.voice_data_.Destroy();
}

void CMsgVoiceAudio::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgVoiceAudio::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgVoiceAudio)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.packet_offsets_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.voice_data_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x000000feu) {
    ::memset(&_impl_.format_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.voice_level_) -
        reinterpret_cast<char*>(&_impl_.format_)) + sizeof(_impl_.voice_level_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgVoiceAudio::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .VoiceDataFormat_t format = 1 [default = VOICEDATA_FORMAT_STEAM];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::VoiceDataFormat_t_IsValid(val))) {
            _internal_set_format(static_cast<::VoiceDataFormat_t>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional bytes voice_data = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_voice_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 sequence_bytes = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_sequence_bytes(&has_bits);
          _impl_.sequence_bytes_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 section_number = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_section_number(&has_bits);
          _impl_.section_number_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 sample_rate = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_sample_rate(&has_bits);
          _impl_.sample_rate_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 uncompressed_sample_offset = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_uncompressed_sample_offset(&has_bits);
          _impl_.uncompressed_sample_offset_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 num_packets = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_num_packets(&has_bits);
          _impl_.num_packets_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated uint32 packet_offsets = 8 [packed = true];
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedUInt32Parser(_internal_mutable_packet_offsets(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 64) {
          _internal_add_packet_offsets(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float voice_level = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 77)) {
          _Internal::set_has_voice_level(&has_bits);
          _impl_.voice_level_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgVoiceAudio::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgVoiceAudio)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .VoiceDataFormat_t format = 1 [default = VOICEDATA_FORMAT_STEAM];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_format(), target);
  }

  // optional bytes voice_data = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_voice_data(), target);
  }

  // optional int32 sequence_bytes = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_sequence_bytes(), target);
  }

  // optional uint32 section_number = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_section_number(), target);
  }

  // optional uint32 sample_rate = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_sample_rate(), target);
  }

  // optional uint32 uncompressed_sample_offset = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_uncompressed_sample_offset(), target);
  }

  // optional uint32 num_packets = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_num_packets(), target);
  }

  // repeated uint32 packet_offsets = 8 [packed = true];
  {
    int byte_size = _impl_._packet_offsets_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteUInt32Packed(
          8, _internal_packet_offsets(), byte_size, target);
    }
  }

  // optional float voice_level = 9;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(9, this->_internal_voice_level(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgVoiceAudio)
  return target;
}

size_t CMsgVoiceAudio::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgVoiceAudio)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated uint32 packet_offsets = 8 [packed = true];
  {
    size_t data_size = ::_pbi::WireFormatLite::
      UInt32Size(this->_impl_.packet_offsets_);
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._packet_offsets_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional bytes voice_data = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_voice_data());
    }

    // optional .VoiceDataFormat_t format = 1 [default = VOICEDATA_FORMAT_STEAM];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_format());
    }

    // optional int32 sequence_bytes = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_sequence_bytes());
    }

    // optional uint32 section_number = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_section_number());
    }

    // optional uint32 sample_rate = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_sample_rate());
    }

    // optional uint32 uncompressed_sample_offset = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_uncompressed_sample_offset());
    }

    // optional uint32 num_packets = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_num_packets());
    }

    // optional float voice_level = 9;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 4;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgVoiceAudio::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgVoiceAudio::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgVoiceAudio::GetClassData() const { return &_class_data_; }


void CMsgVoiceAudio::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgVoiceAudio*>(&to_msg);
  auto& from = static_cast<const CMsgVoiceAudio&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgVoiceAudio)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.packet_offsets_.MergeFrom(from._impl_.packet_offsets_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_voice_data(from._internal_voice_data());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.format_ = from._impl_.format_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.sequence_bytes_ = from._impl_.sequence_bytes_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.section_number_ = from._impl_.section_number_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.sample_rate_ = from._impl_.sample_rate_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.uncompressed_sample_offset_ = from._impl_.uncompressed_sample_offset_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.num_packets_ = from._impl_.num_packets_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.voice_level_ = from._impl_.voice_level_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgVoiceAudio::CopyFrom(const CMsgVoiceAudio& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgVoiceAudio)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgVoiceAudio::IsInitialized() const {
  return true;
}

void CMsgVoiceAudio::InternalSwap(CMsgVoiceAudio* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.packet_offsets_.InternalSwap(&other->_impl_.packet_offsets_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.voice_data_, lhs_arena,
      &other->_impl_.voice_data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgVoiceAudio, _impl_.voice_level_)
      + sizeof(CMsgVoiceAudio::_impl_.voice_level_)
      - PROTOBUF_FIELD_OFFSET(CMsgVoiceAudio, _impl_.format_)>(
          reinterpret_cast<char*>(&_impl_.format_),
          reinterpret_cast<char*>(&other->_impl_.format_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgVoiceAudio::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[2]);
}

// ===================================================================

class CCLCMsg_VoiceData::_Internal {
 public:
  using HasBits = decltype(std::declval<CCLCMsg_VoiceData>()._impl_._has_bits_);
  static const ::CMsgVoiceAudio& audio(const CCLCMsg_VoiceData* msg);
  static void set_has_audio(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_xuid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_tick(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::CMsgVoiceAudio&
CCLCMsg_VoiceData::_Internal::audio(const CCLCMsg_VoiceData* msg) {
  return *msg->_impl_.audio_;
}
CCLCMsg_VoiceData::CCLCMsg_VoiceData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CCLCMsg_VoiceData)
}
CCLCMsg_VoiceData::CCLCMsg_VoiceData(const CCLCMsg_VoiceData& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CCLCMsg_VoiceData* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.audio_){nullptr}
    , decltype(_impl_.xuid_){}
    , decltype(_impl_.tick_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_audio()) {
    _this->_impl_.audio_ = new ::CMsgVoiceAudio(*from._impl_.audio_);
  }
  ::memcpy(&_impl_.xuid_, &from._impl_.xuid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.tick_) -
    reinterpret_cast<char*>(&_impl_.xuid_)) + sizeof(_impl_.tick_));
  // @@protoc_insertion_point(copy_constructor:CCLCMsg_VoiceData)
}

inline void CCLCMsg_VoiceData::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.audio_){nullptr}
    , decltype(_impl_.xuid_){uint64_t{0u}}
    , decltype(_impl_.tick_){0u}
  };
}

CCLCMsg_VoiceData::~CCLCMsg_VoiceData() {
  // @@protoc_insertion_point(destructor:CCLCMsg_VoiceData)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CCLCMsg_VoiceData::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.audio_;
}

void CCLCMsg_VoiceData::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CCLCMsg_VoiceData::Clear() {
// @@protoc_insertion_point(message_clear_start:CCLCMsg_VoiceData)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.audio_ != nullptr);
    _impl_.audio_->Clear();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.xuid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.tick_) -
        reinterpret_cast<char*>(&_impl_.xuid_)) + sizeof(_impl_.tick_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CCLCMsg_VoiceData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .CMsgVoiceAudio audio = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_audio(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional fixed64 xuid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_xuid(&has_bits);
          _impl_.xuid_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 tick = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_tick(&has_bits);
          _impl_.tick_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CCLCMsg_VoiceData::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CCLCMsg_VoiceData)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .CMsgVoiceAudio audio = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::audio(this),
        _Internal::audio(this).GetCachedSize(), target, stream);
  }

  // optional fixed64 xuid = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(2, this->_internal_xuid(), target);
  }

  // optional uint32 tick = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_tick(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CCLCMsg_VoiceData)
  return target;
}

size_t CCLCMsg_VoiceData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CCLCMsg_VoiceData)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .CMsgVoiceAudio audio = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.audio_);
    }

    // optional fixed64 xuid = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional uint32 tick = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_tick());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CCLCMsg_VoiceData::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CCLCMsg_VoiceData::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CCLCMsg_VoiceData::GetClassData() const { return &_class_data_; }


void CCLCMsg_VoiceData::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CCLCMsg_VoiceData*>(&to_msg);
  auto& from = static_cast<const CCLCMsg_VoiceData&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CCLCMsg_VoiceData)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_audio()->::CMsgVoiceAudio::MergeFrom(
          from._internal_audio());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.xuid_ = from._impl_.xuid_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.tick_ = from._impl_.tick_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CCLCMsg_VoiceData::CopyFrom(const CCLCMsg_VoiceData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CCLCMsg_VoiceData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CCLCMsg_VoiceData::IsInitialized() const {
  return true;
}

void CCLCMsg_VoiceData::InternalSwap(CCLCMsg_VoiceData* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CCLCMsg_VoiceData, _impl_.tick_)
      + sizeof(CCLCMsg_VoiceData::_impl_.tick_)
      - PROTOBUF_FIELD_OFFSET(CCLCMsg_VoiceData, _impl_.audio_)>(
          reinterpret_cast<char*>(&_impl_.audio_),
          reinterpret_cast<char*>(&other->_impl_.audio_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CCLCMsg_VoiceData::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[3]);
}

// ===================================================================

class CCLCMsg_BaselineAck::_Internal {
 public:
  using HasBits = decltype(std::declval<CCLCMsg_BaselineAck>()._impl_._has_bits_);
  static void set_has_baseline_tick(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_baseline_nr(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CCLCMsg_BaselineAck::CCLCMsg_BaselineAck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CCLCMsg_BaselineAck)
}
CCLCMsg_BaselineAck::CCLCMsg_BaselineAck(const CCLCMsg_BaselineAck& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CCLCMsg_BaselineAck* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.baseline_tick_){}
    , decltype(_impl_.baseline_nr_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.baseline_tick_, &from._impl_.baseline_tick_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.baseline_nr_) -
    reinterpret_cast<char*>(&_impl_.baseline_tick_)) + sizeof(_impl_.baseline_nr_));
  // @@protoc_insertion_point(copy_constructor:CCLCMsg_BaselineAck)
}

inline void CCLCMsg_BaselineAck::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.baseline_tick_){0}
    , decltype(_impl_.baseline_nr_){0}
  };
}

CCLCMsg_BaselineAck::~CCLCMsg_BaselineAck() {
  // @@protoc_insertion_point(destructor:CCLCMsg_BaselineAck)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CCLCMsg_BaselineAck::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CCLCMsg_BaselineAck::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CCLCMsg_BaselineAck::Clear() {
// @@protoc_insertion_point(message_clear_start:CCLCMsg_BaselineAck)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.baseline_tick_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.baseline_nr_) -
        reinterpret_cast<char*>(&_impl_.baseline_tick_)) + sizeof(_impl_.baseline_nr_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CCLCMsg_BaselineAck::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 baseline_tick = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_baseline_tick(&has_bits);
          _impl_.baseline_tick_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 baseline_nr = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_baseline_nr(&has_bits);
          _impl_.baseline_nr_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CCLCMsg_BaselineAck::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CCLCMsg_BaselineAck)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 baseline_tick = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_baseline_tick(), target);
  }

  // optional int32 baseline_nr = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_baseline_nr(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CCLCMsg_BaselineAck)
  return target;
}

size_t CCLCMsg_BaselineAck::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CCLCMsg_BaselineAck)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional int32 baseline_tick = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_baseline_tick());
    }

    // optional int32 baseline_nr = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_baseline_nr());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CCLCMsg_BaselineAck::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CCLCMsg_BaselineAck::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CCLCMsg_BaselineAck::GetClassData() const { return &_class_data_; }


void CCLCMsg_BaselineAck::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CCLCMsg_BaselineAck*>(&to_msg);
  auto& from = static_cast<const CCLCMsg_BaselineAck&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CCLCMsg_BaselineAck)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.baseline_tick_ = from._impl_.baseline_tick_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.baseline_nr_ = from._impl_.baseline_nr_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CCLCMsg_BaselineAck::CopyFrom(const CCLCMsg_BaselineAck& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CCLCMsg_BaselineAck)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CCLCMsg_BaselineAck::IsInitialized() const {
  return true;
}

void CCLCMsg_BaselineAck::InternalSwap(CCLCMsg_BaselineAck* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CCLCMsg_BaselineAck, _impl_.baseline_nr_)
      + sizeof(CCLCMsg_BaselineAck::_impl_.baseline_nr_)
      - PROTOBUF_FIELD_OFFSET(CCLCMsg_BaselineAck, _impl_.baseline_tick_)>(
          reinterpret_cast<char*>(&_impl_.baseline_tick_),
          reinterpret_cast<char*>(&other->_impl_.baseline_tick_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CCLCMsg_BaselineAck::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[4]);
}

// ===================================================================

class CCLCMsg_ListenEvents::_Internal {
 public:
};

CCLCMsg_ListenEvents::CCLCMsg_ListenEvents(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CCLCMsg_ListenEvents)
}
CCLCMsg_ListenEvents::CCLCMsg_ListenEvents(const CCLCMsg_ListenEvents& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CCLCMsg_ListenEvents* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.event_mask_){from._impl_.event_mask_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CCLCMsg_ListenEvents)
}

inline void CCLCMsg_ListenEvents::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.event_mask_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CCLCMsg_ListenEvents::~CCLCMsg_ListenEvents() {
  // @@protoc_insertion_point(destructor:CCLCMsg_ListenEvents)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CCLCMsg_ListenEvents::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.event_mask_.~RepeatedField();
}

void CCLCMsg_ListenEvents::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CCLCMsg_ListenEvents::Clear() {
// @@protoc_insertion_point(message_clear_start:CCLCMsg_ListenEvents)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.event_mask_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CCLCMsg_ListenEvents::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated fixed32 event_mask = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_event_mask(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr));
            ptr += sizeof(uint32_t);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<13>(ptr));
        } else if (static_cast<uint8_t>(tag) == 10) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFixed32Parser(_internal_mutable_event_mask(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CCLCMsg_ListenEvents::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CCLCMsg_ListenEvents)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated fixed32 event_mask = 1;
  for (int i = 0, n = this->_internal_event_mask_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(1, this->_internal_event_mask(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CCLCMsg_ListenEvents)
  return target;
}

size_t CCLCMsg_ListenEvents::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CCLCMsg_ListenEvents)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated fixed32 event_mask = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_event_mask_size());
    size_t data_size = 4UL * count;
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_event_mask_size());
    total_size += data_size;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CCLCMsg_ListenEvents::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CCLCMsg_ListenEvents::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CCLCMsg_ListenEvents::GetClassData() const { return &_class_data_; }


void CCLCMsg_ListenEvents::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CCLCMsg_ListenEvents*>(&to_msg);
  auto& from = static_cast<const CCLCMsg_ListenEvents&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CCLCMsg_ListenEvents)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.event_mask_.MergeFrom(from._impl_.event_mask_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CCLCMsg_ListenEvents::CopyFrom(const CCLCMsg_ListenEvents& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CCLCMsg_ListenEvents)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CCLCMsg_ListenEvents::IsInitialized() const {
  return true;
}

void CCLCMsg_ListenEvents::InternalSwap(CCLCMsg_ListenEvents* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.event_mask_.InternalSwap(&other->_impl_.event_mask_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CCLCMsg_ListenEvents::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[5]);
}

// ===================================================================

class CCLCMsg_RespondCvarValue::_Internal {
 public:
  using HasBits = decltype(std::declval<CCLCMsg_RespondCvarValue>()._impl_._has_bits_);
  static void set_has_cookie(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_status_code(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_value(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CCLCMsg_RespondCvarValue::CCLCMsg_RespondCvarValue(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CCLCMsg_RespondCvarValue)
}
CCLCMsg_RespondCvarValue::CCLCMsg_RespondCvarValue(const CCLCMsg_RespondCvarValue& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CCLCMsg_RespondCvarValue* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.value_){}
    , decltype(_impl_.cookie_){}
    , decltype(_impl_.status_code_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_value()) {
    _this->_impl_.value_.Set(from._internal_value(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.cookie_, &from._impl_.cookie_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.status_code_) -
    reinterpret_cast<char*>(&_impl_.cookie_)) + sizeof(_impl_.status_code_));
  // @@protoc_insertion_point(copy_constructor:CCLCMsg_RespondCvarValue)
}

inline void CCLCMsg_RespondCvarValue::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.value_){}
    , decltype(_impl_.cookie_){0}
    , decltype(_impl_.status_code_){0}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CCLCMsg_RespondCvarValue::~CCLCMsg_RespondCvarValue() {
  // @@protoc_insertion_point(destructor:CCLCMsg_RespondCvarValue)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CCLCMsg_RespondCvarValue::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  _impl_.value_.Destroy();
}

void CCLCMsg_RespondCvarValue::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CCLCMsg_RespondCvarValue::Clear() {
// @@protoc_insertion_point(message_clear_start:CCLCMsg_RespondCvarValue)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.value_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000000cu) {
    ::memset(&_impl_.cookie_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.status_code_) -
        reinterpret_cast<char*>(&_impl_.cookie_)) + sizeof(_impl_.status_code_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CCLCMsg_RespondCvarValue::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 cookie = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_cookie(&has_bits);
          _impl_.cookie_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 status_code = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_status_code(&has_bits);
          _impl_.status_code_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CCLCMsg_RespondCvarValue.name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string value = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_value();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CCLCMsg_RespondCvarValue.value");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CCLCMsg_RespondCvarValue::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CCLCMsg_RespondCvarValue)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 cookie = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_cookie(), target);
  }

  // optional int32 status_code = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_status_code(), target);
  }

  // optional string name = 3;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CCLCMsg_RespondCvarValue.name");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_name(), target);
  }

  // optional string value = 4;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_value().data(), static_cast<int>(this->_internal_value().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CCLCMsg_RespondCvarValue.value");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CCLCMsg_RespondCvarValue)
  return target;
}

size_t CCLCMsg_RespondCvarValue::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CCLCMsg_RespondCvarValue)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string name = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional string value = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_value());
    }

    // optional int32 cookie = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_cookie());
    }

    // optional int32 status_code = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_status_code());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CCLCMsg_RespondCvarValue::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CCLCMsg_RespondCvarValue::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CCLCMsg_RespondCvarValue::GetClassData() const { return &_class_data_; }


void CCLCMsg_RespondCvarValue::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CCLCMsg_RespondCvarValue*>(&to_msg);
  auto& from = static_cast<const CCLCMsg_RespondCvarValue&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CCLCMsg_RespondCvarValue)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_value(from._internal_value());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.cookie_ = from._impl_.cookie_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.status_code_ = from._impl_.status_code_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CCLCMsg_RespondCvarValue::CopyFrom(const CCLCMsg_RespondCvarValue& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CCLCMsg_RespondCvarValue)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CCLCMsg_RespondCvarValue::IsInitialized() const {
  return true;
}

void CCLCMsg_RespondCvarValue::InternalSwap(CCLCMsg_RespondCvarValue* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.value_, lhs_arena,
      &other->_impl_.value_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CCLCMsg_RespondCvarValue, _impl_.status_code_)
      + sizeof(CCLCMsg_RespondCvarValue::_impl_.status_code_)
      - PROTOBUF_FIELD_OFFSET(CCLCMsg_RespondCvarValue, _impl_.cookie_)>(
          reinterpret_cast<char*>(&_impl_.cookie_),
          reinterpret_cast<char*>(&other->_impl_.cookie_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CCLCMsg_RespondCvarValue::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[6]);
}

// ===================================================================

class CCLCMsg_FileCRCCheck::_Internal {
 public:
  using HasBits = decltype(std::declval<CCLCMsg_FileCRCCheck>()._impl_._has_bits_);
  static void set_has_code_path(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_path(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_code_filename(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_filename(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_crc(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

CCLCMsg_FileCRCCheck::CCLCMsg_FileCRCCheck(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CCLCMsg_FileCRCCheck)
}
CCLCMsg_FileCRCCheck::CCLCMsg_FileCRCCheck(const CCLCMsg_FileCRCCheck& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CCLCMsg_FileCRCCheck* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.path_){}
    , decltype(_impl_.filename_){}
    , decltype(_impl_.code_path_){}
    , decltype(_impl_.code_filename_){}
    , decltype(_impl_.crc_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.path_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.path_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_path()) {
    _this->_impl_.path_.Set(from._internal_path(), 
      _this->GetArenaForAllocation());
  }
  _impl_.filename_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.filename_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_filename()) {
    _this->_impl_.filename_.Set(from._internal_filename(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.code_path_, &from._impl_.code_path_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.crc_) -
    reinterpret_cast<char*>(&_impl_.code_path_)) + sizeof(_impl_.crc_));
  // @@protoc_insertion_point(copy_constructor:CCLCMsg_FileCRCCheck)
}

inline void CCLCMsg_FileCRCCheck::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.path_){}
    , decltype(_impl_.filename_){}
    , decltype(_impl_.code_path_){0}
    , decltype(_impl_.code_filename_){0}
    , decltype(_impl_.crc_){0u}
  };
  _impl_.path_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.path_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.filename_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.filename_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CCLCMsg_FileCRCCheck::~CCLCMsg_FileCRCCheck() {
  // @@protoc_insertion_point(destructor:CCLCMsg_FileCRCCheck)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CCLCMsg_FileCRCCheck::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.path_.Destroy();
  _impl_.filename_.Destroy();
}

void CCLCMsg_FileCRCCheck::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CCLCMsg_FileCRCCheck::Clear() {
// @@protoc_insertion_point(message_clear_start:CCLCMsg_FileCRCCheck)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.path_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.filename_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000001cu) {
    ::memset(&_impl_.code_path_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.crc_) -
        reinterpret_cast<char*>(&_impl_.code_path_)) + sizeof(_impl_.crc_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CCLCMsg_FileCRCCheck::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 code_path = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_code_path(&has_bits);
          _impl_.code_path_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string path = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_path();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CCLCMsg_FileCRCCheck.path");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional int32 code_filename = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_code_filename(&has_bits);
          _impl_.code_filename_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string filename = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_filename();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CCLCMsg_FileCRCCheck.filename");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional fixed32 crc = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 45)) {
          _Internal::set_has_crc(&has_bits);
          _impl_.crc_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CCLCMsg_FileCRCCheck::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CCLCMsg_FileCRCCheck)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 code_path = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_code_path(), target);
  }

  // optional string path = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_path().data(), static_cast<int>(this->_internal_path().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CCLCMsg_FileCRCCheck.path");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_path(), target);
  }

  // optional int32 code_filename = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_code_filename(), target);
  }

  // optional string filename = 4;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_filename().data(), static_cast<int>(this->_internal_filename().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CCLCMsg_FileCRCCheck.filename");
    target = stream->WriteStringMaybeAliased(
        4, this->_internal_filename(), target);
  }

  // optional fixed32 crc = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(5, this->_internal_crc(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CCLCMsg_FileCRCCheck)
  return target;
}

size_t CCLCMsg_FileCRCCheck::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CCLCMsg_FileCRCCheck)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string path = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_path());
    }

    // optional string filename = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_filename());
    }

    // optional int32 code_path = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_code_path());
    }

    // optional int32 code_filename = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_code_filename());
    }

    // optional fixed32 crc = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 4;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CCLCMsg_FileCRCCheck::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CCLCMsg_FileCRCCheck::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CCLCMsg_FileCRCCheck::GetClassData() const { return &_class_data_; }


void CCLCMsg_FileCRCCheck::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CCLCMsg_FileCRCCheck*>(&to_msg);
  auto& from = static_cast<const CCLCMsg_FileCRCCheck&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CCLCMsg_FileCRCCheck)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_path(from._internal_path());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_filename(from._internal_filename());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.code_path_ = from._impl_.code_path_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.code_filename_ = from._impl_.code_filename_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.crc_ = from._impl_.crc_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CCLCMsg_FileCRCCheck::CopyFrom(const CCLCMsg_FileCRCCheck& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CCLCMsg_FileCRCCheck)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CCLCMsg_FileCRCCheck::IsInitialized() const {
  return true;
}

void CCLCMsg_FileCRCCheck::InternalSwap(CCLCMsg_FileCRCCheck* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.path_, lhs_arena,
      &other->_impl_.path_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.filename_, lhs_arena,
      &other->_impl_.filename_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CCLCMsg_FileCRCCheck, _impl_.crc_)
      + sizeof(CCLCMsg_FileCRCCheck::_impl_.crc_)
      - PROTOBUF_FIELD_OFFSET(CCLCMsg_FileCRCCheck, _impl_.code_path_)>(
          reinterpret_cast<char*>(&_impl_.code_path_),
          reinterpret_cast<char*>(&other->_impl_.code_path_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CCLCMsg_FileCRCCheck::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[7]);
}

// ===================================================================

class CCLCMsg_LoadingProgress::_Internal {
 public:
  using HasBits = decltype(std::declval<CCLCMsg_LoadingProgress>()._impl_._has_bits_);
  static void set_has_progress(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CCLCMsg_LoadingProgress::CCLCMsg_LoadingProgress(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CCLCMsg_LoadingProgress)
}
CCLCMsg_LoadingProgress::CCLCMsg_LoadingProgress(const CCLCMsg_LoadingProgress& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CCLCMsg_LoadingProgress* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.progress_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.progress_ = from._impl_.progress_;
  // @@protoc_insertion_point(copy_constructor:CCLCMsg_LoadingProgress)
}

inline void CCLCMsg_LoadingProgress::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.progress_){0}
  };
}

CCLCMsg_LoadingProgress::~CCLCMsg_LoadingProgress() {
  // @@protoc_insertion_point(destructor:CCLCMsg_LoadingProgress)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CCLCMsg_LoadingProgress::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CCLCMsg_LoadingProgress::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CCLCMsg_LoadingProgress::Clear() {
// @@protoc_insertion_point(message_clear_start:CCLCMsg_LoadingProgress)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.progress_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CCLCMsg_LoadingProgress::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 progress = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_progress(&has_bits);
          _impl_.progress_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CCLCMsg_LoadingProgress::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CCLCMsg_LoadingProgress)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 progress = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_progress(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CCLCMsg_LoadingProgress)
  return target;
}

size_t CCLCMsg_LoadingProgress::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CCLCMsg_LoadingProgress)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional int32 progress = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_progress());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CCLCMsg_LoadingProgress::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CCLCMsg_LoadingProgress::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CCLCMsg_LoadingProgress::GetClassData() const { return &_class_data_; }


void CCLCMsg_LoadingProgress::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CCLCMsg_LoadingProgress*>(&to_msg);
  auto& from = static_cast<const CCLCMsg_LoadingProgress&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CCLCMsg_LoadingProgress)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_progress()) {
    _this->_internal_set_progress(from._internal_progress());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CCLCMsg_LoadingProgress::CopyFrom(const CCLCMsg_LoadingProgress& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CCLCMsg_LoadingProgress)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CCLCMsg_LoadingProgress::IsInitialized() const {
  return true;
}

void CCLCMsg_LoadingProgress::InternalSwap(CCLCMsg_LoadingProgress* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.progress_, other->_impl_.progress_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CCLCMsg_LoadingProgress::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[8]);
}

// ===================================================================

class CCLCMsg_SplitPlayerConnect::_Internal {
 public:
  using HasBits = decltype(std::declval<CCLCMsg_SplitPlayerConnect>()._impl_._has_bits_);
  static void set_has_playername(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CCLCMsg_SplitPlayerConnect::CCLCMsg_SplitPlayerConnect(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CCLCMsg_SplitPlayerConnect)
}
CCLCMsg_SplitPlayerConnect::CCLCMsg_SplitPlayerConnect(const CCLCMsg_SplitPlayerConnect& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CCLCMsg_SplitPlayerConnect* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.playername_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.playername_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.playername_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_playername()) {
    _this->_impl_.playername_.Set(from._internal_playername(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:CCLCMsg_SplitPlayerConnect)
}

inline void CCLCMsg_SplitPlayerConnect::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.playername_){}
  };
  _impl_.playername_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.playername_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CCLCMsg_SplitPlayerConnect::~CCLCMsg_SplitPlayerConnect() {
  // @@protoc_insertion_point(destructor:CCLCMsg_SplitPlayerConnect)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CCLCMsg_SplitPlayerConnect::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.playername_.Destroy();
}

void CCLCMsg_SplitPlayerConnect::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CCLCMsg_SplitPlayerConnect::Clear() {
// @@protoc_insertion_point(message_clear_start:CCLCMsg_SplitPlayerConnect)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.playername_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CCLCMsg_SplitPlayerConnect::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string playername = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_playername();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CCLCMsg_SplitPlayerConnect.playername");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CCLCMsg_SplitPlayerConnect::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CCLCMsg_SplitPlayerConnect)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string playername = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_playername().data(), static_cast<int>(this->_internal_playername().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CCLCMsg_SplitPlayerConnect.playername");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_playername(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CCLCMsg_SplitPlayerConnect)
  return target;
}

size_t CCLCMsg_SplitPlayerConnect::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CCLCMsg_SplitPlayerConnect)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string playername = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_playername());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CCLCMsg_SplitPlayerConnect::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CCLCMsg_SplitPlayerConnect::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CCLCMsg_SplitPlayerConnect::GetClassData() const { return &_class_data_; }


void CCLCMsg_SplitPlayerConnect::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CCLCMsg_SplitPlayerConnect*>(&to_msg);
  auto& from = static_cast<const CCLCMsg_SplitPlayerConnect&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CCLCMsg_SplitPlayerConnect)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_playername()) {
    _this->_internal_set_playername(from._internal_playername());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CCLCMsg_SplitPlayerConnect::CopyFrom(const CCLCMsg_SplitPlayerConnect& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CCLCMsg_SplitPlayerConnect)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CCLCMsg_SplitPlayerConnect::IsInitialized() const {
  return true;
}

void CCLCMsg_SplitPlayerConnect::InternalSwap(CCLCMsg_SplitPlayerConnect* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.playername_, lhs_arena,
      &other->_impl_.playername_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata CCLCMsg_SplitPlayerConnect::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[9]);
}

// ===================================================================

class CCLCMsg_ClientMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<CCLCMsg_ClientMessage>()._impl_._has_bits_);
  static void set_has_msg_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CCLCMsg_ClientMessage::CCLCMsg_ClientMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CCLCMsg_ClientMessage)
}
CCLCMsg_ClientMessage::CCLCMsg_ClientMessage(const CCLCMsg_ClientMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CCLCMsg_ClientMessage* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.data_){}
    , decltype(_impl_.msg_type_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_data()) {
    _this->_impl_.data_.Set(from._internal_data(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.msg_type_ = from._impl_.msg_type_;
  // @@protoc_insertion_point(copy_constructor:CCLCMsg_ClientMessage)
}

inline void CCLCMsg_ClientMessage::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.data_){}
    , decltype(_impl_.msg_type_){0}
  };
  _impl_.data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CCLCMsg_ClientMessage::~CCLCMsg_ClientMessage() {
  // @@protoc_insertion_point(destructor:CCLCMsg_ClientMessage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CCLCMsg_ClientMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.data_.Destroy();
}

void CCLCMsg_ClientMessage::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CCLCMsg_ClientMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:CCLCMsg_ClientMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.data_.ClearNonDefaultToEmpty();
  }
  _impl_.msg_type_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CCLCMsg_ClientMessage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 msg_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_msg_type(&has_bits);
          _impl_.msg_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes data = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CCLCMsg_ClientMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CCLCMsg_ClientMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 msg_type = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_msg_type(), target);
  }

  // optional bytes data = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_data(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CCLCMsg_ClientMessage)
  return target;
}

size_t CCLCMsg_ClientMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CCLCMsg_ClientMessage)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bytes data = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_data());
    }

    // optional int32 msg_type = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_msg_type());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CCLCMsg_ClientMessage::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CCLCMsg_ClientMessage::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CCLCMsg_ClientMessage::GetClassData() const { return &_class_data_; }


void CCLCMsg_ClientMessage::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CCLCMsg_ClientMessage*>(&to_msg);
  auto& from = static_cast<const CCLCMsg_ClientMessage&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CCLCMsg_ClientMessage)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_data(from._internal_data());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.msg_type_ = from._impl_.msg_type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CCLCMsg_ClientMessage::CopyFrom(const CCLCMsg_ClientMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CCLCMsg_ClientMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CCLCMsg_ClientMessage::IsInitialized() const {
  return true;
}

void CCLCMsg_ClientMessage::InternalSwap(CCLCMsg_ClientMessage* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.data_, lhs_arena,
      &other->_impl_.data_, rhs_arena
  );
  swap(_impl_.msg_type_, other->_impl_.msg_type_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CCLCMsg_ClientMessage::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[10]);
}

// ===================================================================

class CCLCMsg_SplitPlayerDisconnect::_Internal {
 public:
  using HasBits = decltype(std::declval<CCLCMsg_SplitPlayerDisconnect>()._impl_._has_bits_);
  static void set_has_slot(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CCLCMsg_SplitPlayerDisconnect::CCLCMsg_SplitPlayerDisconnect(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CCLCMsg_SplitPlayerDisconnect)
}
CCLCMsg_SplitPlayerDisconnect::CCLCMsg_SplitPlayerDisconnect(const CCLCMsg_SplitPlayerDisconnect& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CCLCMsg_SplitPlayerDisconnect* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.slot_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.slot_ = from._impl_.slot_;
  // @@protoc_insertion_point(copy_constructor:CCLCMsg_SplitPlayerDisconnect)
}

inline void CCLCMsg_SplitPlayerDisconnect::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.slot_){0}
  };
}

CCLCMsg_SplitPlayerDisconnect::~CCLCMsg_SplitPlayerDisconnect() {
  // @@protoc_insertion_point(destructor:CCLCMsg_SplitPlayerDisconnect)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CCLCMsg_SplitPlayerDisconnect::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CCLCMsg_SplitPlayerDisconnect::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CCLCMsg_SplitPlayerDisconnect::Clear() {
// @@protoc_insertion_point(message_clear_start:CCLCMsg_SplitPlayerDisconnect)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.slot_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CCLCMsg_SplitPlayerDisconnect::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 slot = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_slot(&has_bits);
          _impl_.slot_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CCLCMsg_SplitPlayerDisconnect::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CCLCMsg_SplitPlayerDisconnect)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 slot = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_slot(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CCLCMsg_SplitPlayerDisconnect)
  return target;
}

size_t CCLCMsg_SplitPlayerDisconnect::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CCLCMsg_SplitPlayerDisconnect)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional int32 slot = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_slot());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CCLCMsg_SplitPlayerDisconnect::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CCLCMsg_SplitPlayerDisconnect::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CCLCMsg_SplitPlayerDisconnect::GetClassData() const { return &_class_data_; }


void CCLCMsg_SplitPlayerDisconnect::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CCLCMsg_SplitPlayerDisconnect*>(&to_msg);
  auto& from = static_cast<const CCLCMsg_SplitPlayerDisconnect&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CCLCMsg_SplitPlayerDisconnect)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_slot()) {
    _this->_internal_set_slot(from._internal_slot());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CCLCMsg_SplitPlayerDisconnect::CopyFrom(const CCLCMsg_SplitPlayerDisconnect& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CCLCMsg_SplitPlayerDisconnect)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CCLCMsg_SplitPlayerDisconnect::IsInitialized() const {
  return true;
}

void CCLCMsg_SplitPlayerDisconnect::InternalSwap(CCLCMsg_SplitPlayerDisconnect* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.slot_, other->_impl_.slot_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CCLCMsg_SplitPlayerDisconnect::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[11]);
}

// ===================================================================

class CCLCMsg_ServerStatus::_Internal {
 public:
  using HasBits = decltype(std::declval<CCLCMsg_ServerStatus>()._impl_._has_bits_);
  static void set_has_simplified(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CCLCMsg_ServerStatus::CCLCMsg_ServerStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CCLCMsg_ServerStatus)
}
CCLCMsg_ServerStatus::CCLCMsg_ServerStatus(const CCLCMsg_ServerStatus& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CCLCMsg_ServerStatus* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.simplified_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.simplified_ = from._impl_.simplified_;
  // @@protoc_insertion_point(copy_constructor:CCLCMsg_ServerStatus)
}

inline void CCLCMsg_ServerStatus::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.simplified_){false}
  };
}

CCLCMsg_ServerStatus::~CCLCMsg_ServerStatus() {
  // @@protoc_insertion_point(destructor:CCLCMsg_ServerStatus)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CCLCMsg_ServerStatus::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CCLCMsg_ServerStatus::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CCLCMsg_ServerStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:CCLCMsg_ServerStatus)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.simplified_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CCLCMsg_ServerStatus::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool simplified = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_simplified(&has_bits);
          _impl_.simplified_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CCLCMsg_ServerStatus::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CCLCMsg_ServerStatus)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool simplified = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_simplified(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CCLCMsg_ServerStatus)
  return target;
}

size_t CCLCMsg_ServerStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CCLCMsg_ServerStatus)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bool simplified = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CCLCMsg_ServerStatus::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CCLCMsg_ServerStatus::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CCLCMsg_ServerStatus::GetClassData() const { return &_class_data_; }


void CCLCMsg_ServerStatus::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CCLCMsg_ServerStatus*>(&to_msg);
  auto& from = static_cast<const CCLCMsg_ServerStatus&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CCLCMsg_ServerStatus)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_simplified()) {
    _this->_internal_set_simplified(from._internal_simplified());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CCLCMsg_ServerStatus::CopyFrom(const CCLCMsg_ServerStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CCLCMsg_ServerStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CCLCMsg_ServerStatus::IsInitialized() const {
  return true;
}

void CCLCMsg_ServerStatus::InternalSwap(CCLCMsg_ServerStatus* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.simplified_, other->_impl_.simplified_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CCLCMsg_ServerStatus::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[12]);
}

// ===================================================================

class CCLCMsg_RequestPause::_Internal {
 public:
  using HasBits = decltype(std::declval<CCLCMsg_RequestPause>()._impl_._has_bits_);
  static void set_has_pause_type(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_pause_group(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CCLCMsg_RequestPause::CCLCMsg_RequestPause(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CCLCMsg_RequestPause)
}
CCLCMsg_RequestPause::CCLCMsg_RequestPause(const CCLCMsg_RequestPause& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CCLCMsg_RequestPause* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.pause_type_){}
    , decltype(_impl_.pause_group_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.pause_type_, &from._impl_.pause_type_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.pause_group_) -
    reinterpret_cast<char*>(&_impl_.pause_type_)) + sizeof(_impl_.pause_group_));
  // @@protoc_insertion_point(copy_constructor:CCLCMsg_RequestPause)
}

inline void CCLCMsg_RequestPause::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.pause_type_){0}
    , decltype(_impl_.pause_group_){0}
  };
}

CCLCMsg_RequestPause::~CCLCMsg_RequestPause() {
  // @@protoc_insertion_point(destructor:CCLCMsg_RequestPause)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CCLCMsg_RequestPause::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CCLCMsg_RequestPause::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CCLCMsg_RequestPause::Clear() {
// @@protoc_insertion_point(message_clear_start:CCLCMsg_RequestPause)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.pause_type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.pause_group_) -
        reinterpret_cast<char*>(&_impl_.pause_type_)) + sizeof(_impl_.pause_group_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CCLCMsg_RequestPause::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .RequestPause_t pause_type = 1 [default = RP_PAUSE];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::RequestPause_t_IsValid(val))) {
            _internal_set_pause_type(static_cast<::RequestPause_t>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional int32 pause_group = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_pause_group(&has_bits);
          _impl_.pause_group_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CCLCMsg_RequestPause::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CCLCMsg_RequestPause)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .RequestPause_t pause_type = 1 [default = RP_PAUSE];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_pause_type(), target);
  }

  // optional int32 pause_group = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_pause_group(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CCLCMsg_RequestPause)
  return target;
}

size_t CCLCMsg_RequestPause::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CCLCMsg_RequestPause)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .RequestPause_t pause_type = 1 [default = RP_PAUSE];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_pause_type());
    }

    // optional int32 pause_group = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_pause_group());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CCLCMsg_RequestPause::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CCLCMsg_RequestPause::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CCLCMsg_RequestPause::GetClassData() const { return &_class_data_; }


void CCLCMsg_RequestPause::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CCLCMsg_RequestPause*>(&to_msg);
  auto& from = static_cast<const CCLCMsg_RequestPause&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CCLCMsg_RequestPause)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.pause_type_ = from._impl_.pause_type_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.pause_group_ = from._impl_.pause_group_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CCLCMsg_RequestPause::CopyFrom(const CCLCMsg_RequestPause& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CCLCMsg_RequestPause)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CCLCMsg_RequestPause::IsInitialized() const {
  return true;
}

void CCLCMsg_RequestPause::InternalSwap(CCLCMsg_RequestPause* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CCLCMsg_RequestPause, _impl_.pause_group_)
      + sizeof(CCLCMsg_RequestPause::_impl_.pause_group_)
      - PROTOBUF_FIELD_OFFSET(CCLCMsg_RequestPause, _impl_.pause_type_)>(
          reinterpret_cast<char*>(&_impl_.pause_type_),
          reinterpret_cast<char*>(&other->_impl_.pause_type_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CCLCMsg_RequestPause::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[13]);
}

// ===================================================================

class CCLCMsg_CmdKeyValues::_Internal {
 public:
  using HasBits = decltype(std::declval<CCLCMsg_CmdKeyValues>()._impl_._has_bits_);
  static void set_has_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CCLCMsg_CmdKeyValues::CCLCMsg_CmdKeyValues(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CCLCMsg_CmdKeyValues)
}
CCLCMsg_CmdKeyValues::CCLCMsg_CmdKeyValues(const CCLCMsg_CmdKeyValues& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CCLCMsg_CmdKeyValues* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.data_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_data()) {
    _this->_impl_.data_.Set(from._internal_data(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:CCLCMsg_CmdKeyValues)
}

inline void CCLCMsg_CmdKeyValues::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.data_){}
  };
  _impl_.data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CCLCMsg_CmdKeyValues::~CCLCMsg_CmdKeyValues() {
  // @@protoc_insertion_point(destructor:CCLCMsg_CmdKeyValues)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CCLCMsg_CmdKeyValues::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.data_.Destroy();
}

void CCLCMsg_CmdKeyValues::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CCLCMsg_CmdKeyValues::Clear() {
// @@protoc_insertion_point(message_clear_start:CCLCMsg_CmdKeyValues)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.data_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CCLCMsg_CmdKeyValues::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes data = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CCLCMsg_CmdKeyValues::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CCLCMsg_CmdKeyValues)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes data = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_data(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CCLCMsg_CmdKeyValues)
  return target;
}

size_t CCLCMsg_CmdKeyValues::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CCLCMsg_CmdKeyValues)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bytes data = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_data());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CCLCMsg_CmdKeyValues::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CCLCMsg_CmdKeyValues::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CCLCMsg_CmdKeyValues::GetClassData() const { return &_class_data_; }


void CCLCMsg_CmdKeyValues::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CCLCMsg_CmdKeyValues*>(&to_msg);
  auto& from = static_cast<const CCLCMsg_CmdKeyValues&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CCLCMsg_CmdKeyValues)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_data()) {
    _this->_internal_set_data(from._internal_data());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CCLCMsg_CmdKeyValues::CopyFrom(const CCLCMsg_CmdKeyValues& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CCLCMsg_CmdKeyValues)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CCLCMsg_CmdKeyValues::IsInitialized() const {
  return true;
}

void CCLCMsg_CmdKeyValues::InternalSwap(CCLCMsg_CmdKeyValues* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.data_, lhs_arena,
      &other->_impl_.data_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata CCLCMsg_CmdKeyValues::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[14]);
}

// ===================================================================

class CCLCMsg_RconServerDetails::_Internal {
 public:
  using HasBits = decltype(std::declval<CCLCMsg_RconServerDetails>()._impl_._has_bits_);
  static void set_has_token(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CCLCMsg_RconServerDetails::CCLCMsg_RconServerDetails(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CCLCMsg_RconServerDetails)
}
CCLCMsg_RconServerDetails::CCLCMsg_RconServerDetails(const CCLCMsg_RconServerDetails& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CCLCMsg_RconServerDetails* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.token_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_token()) {
    _this->_impl_.token_.Set(from._internal_token(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:CCLCMsg_RconServerDetails)
}

inline void CCLCMsg_RconServerDetails::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.token_){}
  };
  _impl_.token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CCLCMsg_RconServerDetails::~CCLCMsg_RconServerDetails() {
  // @@protoc_insertion_point(destructor:CCLCMsg_RconServerDetails)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CCLCMsg_RconServerDetails::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.token_.Destroy();
}

void CCLCMsg_RconServerDetails::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CCLCMsg_RconServerDetails::Clear() {
// @@protoc_insertion_point(message_clear_start:CCLCMsg_RconServerDetails)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.token_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CCLCMsg_RconServerDetails::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes token = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_token();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CCLCMsg_RconServerDetails::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CCLCMsg_RconServerDetails)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes token = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_token(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CCLCMsg_RconServerDetails)
  return target;
}

size_t CCLCMsg_RconServerDetails::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CCLCMsg_RconServerDetails)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bytes token = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_token());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CCLCMsg_RconServerDetails::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CCLCMsg_RconServerDetails::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CCLCMsg_RconServerDetails::GetClassData() const { return &_class_data_; }


void CCLCMsg_RconServerDetails::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CCLCMsg_RconServerDetails*>(&to_msg);
  auto& from = static_cast<const CCLCMsg_RconServerDetails&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CCLCMsg_RconServerDetails)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_token()) {
    _this->_internal_set_token(from._internal_token());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CCLCMsg_RconServerDetails::CopyFrom(const CCLCMsg_RconServerDetails& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CCLCMsg_RconServerDetails)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CCLCMsg_RconServerDetails::IsInitialized() const {
  return true;
}

void CCLCMsg_RconServerDetails::InternalSwap(CCLCMsg_RconServerDetails* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.token_, lhs_arena,
      &other->_impl_.token_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata CCLCMsg_RconServerDetails::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[15]);
}

// ===================================================================

class CSVCMsg_ServerInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<CSVCMsg_ServerInfo>()._impl_._has_bits_);
  static void set_has_protocol(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_server_count(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_is_dedicated(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_is_hltv(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_c_os(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_max_clients(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_max_classes(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_player_slot(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_tick_interval(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_game_dir(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_map_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_sky_name(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_host_name(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_addon_name(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::CSVCMsg_GameSessionConfiguration& game_session_config(const CSVCMsg_ServerInfo* msg);
  static void set_has_game_session_config(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_game_session_manifest(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

const ::CSVCMsg_GameSessionConfiguration&
CSVCMsg_ServerInfo::_Internal::game_session_config(const CSVCMsg_ServerInfo* msg) {
  return *msg->_impl_.game_session_config_;
}
void CSVCMsg_ServerInfo::clear_game_session_config() {
  if (_impl_.game_session_config_ != nullptr) _impl_.game_session_config_->Clear();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
CSVCMsg_ServerInfo::CSVCMsg_ServerInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CSVCMsg_ServerInfo)
}
CSVCMsg_ServerInfo::CSVCMsg_ServerInfo(const CSVCMsg_ServerInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CSVCMsg_ServerInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.game_dir_){}
    , decltype(_impl_.map_name_){}
    , decltype(_impl_.sky_name_){}
    , decltype(_impl_.host_name_){}
    , decltype(_impl_.addon_name_){}
    , decltype(_impl_.game_session_manifest_){}
    , decltype(_impl_.game_session_config_){nullptr}
    , decltype(_impl_.protocol_){}
    , decltype(_impl_.server_count_){}
    , decltype(_impl_.is_dedicated_){}
    , decltype(_impl_.is_hltv_){}
    , decltype(_impl_.c_os_){}
    , decltype(_impl_.max_clients_){}
    , decltype(_impl_.max_classes_){}
    , decltype(_impl_.tick_interval_){}
    , decltype(_impl_.player_slot_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.game_dir_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.game_dir_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_game_dir()) {
    _this->_impl_.game_dir_.Set(from._internal_game_dir(), 
      _this->GetArenaForAllocation());
  }
  _impl_.map_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.map_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_map_name()) {
    _this->_impl_.map_name_.Set(from._internal_map_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.sky_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sky_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_sky_name()) {
    _this->_impl_.sky_name_.Set(from._internal_sky_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.host_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.host_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_host_name()) {
    _this->_impl_.host_name_.Set(from._internal_host_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.addon_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.addon_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_addon_name()) {
    _this->_impl_.addon_name_.Set(from._internal_addon_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.game_session_manifest_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.game_session_manifest_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_game_session_manifest()) {
    _this->_impl_.game_session_manifest_.Set(from._internal_game_session_manifest(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_game_session_config()) {
    _this->_impl_.game_session_config_ = new ::CSVCMsg_GameSessionConfiguration(*from._impl_.game_session_config_);
  }
  ::memcpy(&_impl_.protocol_, &from._impl_.protocol_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.player_slot_) -
    reinterpret_cast<char*>(&_impl_.protocol_)) + sizeof(_impl_.player_slot_));
  // @@protoc_insertion_point(copy_constructor:CSVCMsg_ServerInfo)
}

inline void CSVCMsg_ServerInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.game_dir_){}
    , decltype(_impl_.map_name_){}
    , decltype(_impl_.sky_name_){}
    , decltype(_impl_.host_name_){}
    , decltype(_impl_.addon_name_){}
    , decltype(_impl_.game_session_manifest_){}
    , decltype(_impl_.game_session_config_){nullptr}
    , decltype(_impl_.protocol_){0}
    , decltype(_impl_.server_count_){0}
    , decltype(_impl_.is_dedicated_){false}
    , decltype(_impl_.is_hltv_){false}
    , decltype(_impl_.c_os_){0}
    , decltype(_impl_.max_clients_){0}
    , decltype(_impl_.max_classes_){0}
    , decltype(_impl_.tick_interval_){0}
    , decltype(_impl_.player_slot_){-1}
  };
  _impl_.game_dir_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.game_dir_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.map_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.map_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.sky_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.sky_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.host_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.host_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.addon_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.addon_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.game_session_manifest_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.game_session_manifest_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CSVCMsg_ServerInfo::~CSVCMsg_ServerInfo() {
  // @@protoc_insertion_point(destructor:CSVCMsg_ServerInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CSVCMsg_ServerInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.game_dir_.Destroy();
  _impl_.map_name_.Destroy();
  _impl_.sky_name_.Destroy();
  _impl_.host_name_.Destroy();
  _impl_.addon_name_.Destroy();
  _impl_.game_session_manifest_.Destroy();
  if (this != internal_default_instance()) delete _impl_.game_session_config_;
}

void CSVCMsg_ServerInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CSVCMsg_ServerInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:CSVCMsg_ServerInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.game_dir_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.map_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.sky_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      _impl_.host_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000010u) {
      _impl_.addon_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000020u) {
      _impl_.game_session_manifest_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000040u) {
      GOOGLE_DCHECK(_impl_.game_session_config_ != nullptr);
      _impl_.game_session_config_->Clear();
    }
  }
  _impl_.protocol_ = 0;
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&_impl_.server_count_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.tick_interval_) -
        reinterpret_cast<char*>(&_impl_.server_count_)) + sizeof(_impl_.tick_interval_));
    _impl_.player_slot_ = -1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSVCMsg_ServerInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 protocol = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_protocol(&has_bits);
          _impl_.protocol_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 server_count = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_server_count(&has_bits);
          _impl_.server_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_dedicated = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_is_dedicated(&has_bits);
          _impl_.is_dedicated_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_hltv = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_is_hltv(&has_bits);
          _impl_.is_hltv_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 c_os = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_c_os(&has_bits);
          _impl_.c_os_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 max_clients = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_max_clients(&has_bits);
          _impl_.max_clients_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 max_classes = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_max_classes(&has_bits);
          _impl_.max_classes_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 player_slot = 12 [default = -1];
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_player_slot(&has_bits);
          _impl_.player_slot_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float tick_interval = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 109)) {
          _Internal::set_has_tick_interval(&has_bits);
          _impl_.tick_interval_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional string game_dir = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          auto str = _internal_mutable_game_dir();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CSVCMsg_ServerInfo.game_dir");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string map_name = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
          auto str = _internal_mutable_map_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CSVCMsg_ServerInfo.map_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string sky_name = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 130)) {
          auto str = _internal_mutable_sky_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CSVCMsg_ServerInfo.sky_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string host_name = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 138)) {
          auto str = _internal_mutable_host_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CSVCMsg_ServerInfo.host_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional string addon_name = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 146)) {
          auto str = _internal_mutable_addon_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CSVCMsg_ServerInfo.addon_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional .CSVCMsg_GameSessionConfiguration game_session_config = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 154)) {
          ptr = ctx->ParseMessage(_internal_mutable_game_session_config(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes game_session_manifest = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          auto str = _internal_mutable_game_session_manifest();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSVCMsg_ServerInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CSVCMsg_ServerInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 protocol = 1;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_protocol(), target);
  }

  // optional int32 server_count = 2;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_server_count(), target);
  }

  // optional bool is_dedicated = 3;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_is_dedicated(), target);
  }

  // optional bool is_hltv = 4;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_is_hltv(), target);
  }

  // optional int32 c_os = 6;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(6, this->_internal_c_os(), target);
  }

  // optional int32 max_clients = 10;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(10, this->_internal_max_clients(), target);
  }

  // optional int32 max_classes = 11;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(11, this->_internal_max_classes(), target);
  }

  // optional int32 player_slot = 12 [default = -1];
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(12, this->_internal_player_slot(), target);
  }

  // optional float tick_interval = 13;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(13, this->_internal_tick_interval(), target);
  }

  // optional string game_dir = 14;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_game_dir().data(), static_cast<int>(this->_internal_game_dir().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CSVCMsg_ServerInfo.game_dir");
    target = stream->WriteStringMaybeAliased(
        14, this->_internal_game_dir(), target);
  }

  // optional string map_name = 15;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_map_name().data(), static_cast<int>(this->_internal_map_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CSVCMsg_ServerInfo.map_name");
    target = stream->WriteStringMaybeAliased(
        15, this->_internal_map_name(), target);
  }

  // optional string sky_name = 16;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_sky_name().data(), static_cast<int>(this->_internal_sky_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CSVCMsg_ServerInfo.sky_name");
    target = stream->WriteStringMaybeAliased(
        16, this->_internal_sky_name(), target);
  }

  // optional string host_name = 17;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_host_name().data(), static_cast<int>(this->_internal_host_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CSVCMsg_ServerInfo.host_name");
    target = stream->WriteStringMaybeAliased(
        17, this->_internal_host_name(), target);
  }

  // optional string addon_name = 18;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_addon_name().data(), static_cast<int>(this->_internal_addon_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CSVCMsg_ServerInfo.addon_name");
    target = stream->WriteStringMaybeAliased(
        18, this->_internal_addon_name(), target);
  }

  // optional .CSVCMsg_GameSessionConfiguration game_session_config = 19;
  if (cached_has_bits & 0x00000040u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(19, _Internal::game_session_config(this),
        _Internal::game_session_config(this).GetCachedSize(), target, stream);
  }

  // optional bytes game_session_manifest = 20;
  if (cached_has_bits & 0x00000020u) {
    target = stream->WriteBytesMaybeAliased(
        20, this->_internal_game_session_manifest(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CSVCMsg_ServerInfo)
  return target;
}

size_t CSVCMsg_ServerInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CSVCMsg_ServerInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string game_dir = 14;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_game_dir());
    }

    // optional string map_name = 15;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_map_name());
    }

    // optional string sky_name = 16;
    if (cached_has_bits & 0x00000004u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_sky_name());
    }

    // optional string host_name = 17;
    if (cached_has_bits & 0x00000008u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_host_name());
    }

    // optional string addon_name = 18;
    if (cached_has_bits & 0x00000010u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_addon_name());
    }

    // optional bytes game_session_manifest = 20;
    if (cached_has_bits & 0x00000020u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_game_session_manifest());
    }

    // optional .CSVCMsg_GameSessionConfiguration game_session_config = 19;
    if (cached_has_bits & 0x00000040u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.game_session_config_);
    }

    // optional int32 protocol = 1;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_protocol());
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional int32 server_count = 2;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_server_count());
    }

    // optional bool is_dedicated = 3;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 1;
    }

    // optional bool is_hltv = 4;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 + 1;
    }

    // optional int32 c_os = 6;
    if (cached_has_bits & 0x00000800u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_c_os());
    }

    // optional int32 max_clients = 10;
    if (cached_has_bits & 0x00001000u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_max_clients());
    }

    // optional int32 max_classes = 11;
    if (cached_has_bits & 0x00002000u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_max_classes());
    }

    // optional float tick_interval = 13;
    if (cached_has_bits & 0x00004000u) {
      total_size += 1 + 4;
    }

    // optional int32 player_slot = 12 [default = -1];
    if (cached_has_bits & 0x00008000u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_player_slot());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSVCMsg_ServerInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CSVCMsg_ServerInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSVCMsg_ServerInfo::GetClassData() const { return &_class_data_; }


void CSVCMsg_ServerInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CSVCMsg_ServerInfo*>(&to_msg);
  auto& from = static_cast<const CSVCMsg_ServerInfo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CSVCMsg_ServerInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_game_dir(from._internal_game_dir());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_map_name(from._internal_map_name());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_sky_name(from._internal_sky_name());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_set_host_name(from._internal_host_name());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_set_addon_name(from._internal_addon_name());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_set_game_session_manifest(from._internal_game_session_manifest());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_internal_mutable_game_session_config()->::CSVCMsg_GameSessionConfiguration::MergeFrom(
          from._internal_game_session_config());
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.protocol_ = from._impl_.protocol_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.server_count_ = from._impl_.server_count_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.is_dedicated_ = from._impl_.is_dedicated_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.is_hltv_ = from._impl_.is_hltv_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.c_os_ = from._impl_.c_os_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.max_clients_ = from._impl_.max_clients_;
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.max_classes_ = from._impl_.max_classes_;
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_impl_.tick_interval_ = from._impl_.tick_interval_;
    }
    if (cached_has_bits & 0x00008000u) {
      _this->_impl_.player_slot_ = from._impl_.player_slot_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSVCMsg_ServerInfo::CopyFrom(const CSVCMsg_ServerInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CSVCMsg_ServerInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSVCMsg_ServerInfo::IsInitialized() const {
  return true;
}

void CSVCMsg_ServerInfo::InternalSwap(CSVCMsg_ServerInfo* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.game_dir_, lhs_arena,
      &other->_impl_.game_dir_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.map_name_, lhs_arena,
      &other->_impl_.map_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.sky_name_, lhs_arena,
      &other->_impl_.sky_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.host_name_, lhs_arena,
      &other->_impl_.host_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.addon_name_, lhs_arena,
      &other->_impl_.addon_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.game_session_manifest_, lhs_arena,
      &other->_impl_.game_session_manifest_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CSVCMsg_ServerInfo, _impl_.tick_interval_)
      + sizeof(CSVCMsg_ServerInfo::_impl_.tick_interval_)
      - PROTOBUF_FIELD_OFFSET(CSVCMsg_ServerInfo, _impl_.game_session_config_)>(
          reinterpret_cast<char*>(&_impl_.game_session_config_),
          reinterpret_cast<char*>(&other->_impl_.game_session_config_));
  swap(_impl_.player_slot_, other->_impl_.player_slot_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CSVCMsg_ServerInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[16]);
}

// ===================================================================

class CSVCMsg_ClassInfo_class_t::_Internal {
 public:
  using HasBits = decltype(std::declval<CSVCMsg_ClassInfo_class_t>()._impl_._has_bits_);
  static void set_has_class_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_class_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CSVCMsg_ClassInfo_class_t::CSVCMsg_ClassInfo_class_t(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CSVCMsg_ClassInfo.class_t)
}
CSVCMsg_ClassInfo_class_t::CSVCMsg_ClassInfo_class_t(const CSVCMsg_ClassInfo_class_t& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CSVCMsg_ClassInfo_class_t* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.class_name_){}
    , decltype(_impl_.class_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.class_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.class_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_class_name()) {
    _this->_impl_.class_name_.Set(from._internal_class_name(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.class_id_ = from._impl_.class_id_;
  // @@protoc_insertion_point(copy_constructor:CSVCMsg_ClassInfo.class_t)
}

inline void CSVCMsg_ClassInfo_class_t::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.class_name_){}
    , decltype(_impl_.class_id_){0}
  };
  _impl_.class_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.class_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CSVCMsg_ClassInfo_class_t::~CSVCMsg_ClassInfo_class_t() {
  // @@protoc_insertion_point(destructor:CSVCMsg_ClassInfo.class_t)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CSVCMsg_ClassInfo_class_t::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.class_name_.Destroy();
}

void CSVCMsg_ClassInfo_class_t::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CSVCMsg_ClassInfo_class_t::Clear() {
// @@protoc_insertion_point(message_clear_start:CSVCMsg_ClassInfo.class_t)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.class_name_.ClearNonDefaultToEmpty();
  }
  _impl_.class_id_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSVCMsg_ClassInfo_class_t::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 class_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_class_id(&has_bits);
          _impl_.class_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string class_name = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_class_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CSVCMsg_ClassInfo.class_t.class_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSVCMsg_ClassInfo_class_t::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CSVCMsg_ClassInfo.class_t)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 class_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_class_id(), target);
  }

  // optional string class_name = 3;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_class_name().data(), static_cast<int>(this->_internal_class_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CSVCMsg_ClassInfo.class_t.class_name");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_class_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CSVCMsg_ClassInfo.class_t)
  return target;
}

size_t CSVCMsg_ClassInfo_class_t::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CSVCMsg_ClassInfo.class_t)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string class_name = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_class_name());
    }

    // optional int32 class_id = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_class_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSVCMsg_ClassInfo_class_t::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CSVCMsg_ClassInfo_class_t::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSVCMsg_ClassInfo_class_t::GetClassData() const { return &_class_data_; }


void CSVCMsg_ClassInfo_class_t::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CSVCMsg_ClassInfo_class_t*>(&to_msg);
  auto& from = static_cast<const CSVCMsg_ClassInfo_class_t&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CSVCMsg_ClassInfo.class_t)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_class_name(from._internal_class_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.class_id_ = from._impl_.class_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSVCMsg_ClassInfo_class_t::CopyFrom(const CSVCMsg_ClassInfo_class_t& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CSVCMsg_ClassInfo.class_t)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSVCMsg_ClassInfo_class_t::IsInitialized() const {
  return true;
}

void CSVCMsg_ClassInfo_class_t::InternalSwap(CSVCMsg_ClassInfo_class_t* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.class_name_, lhs_arena,
      &other->_impl_.class_name_, rhs_arena
  );
  swap(_impl_.class_id_, other->_impl_.class_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CSVCMsg_ClassInfo_class_t::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[17]);
}

// ===================================================================

class CSVCMsg_ClassInfo::_Internal {
 public:
  using HasBits = decltype(std::declval<CSVCMsg_ClassInfo>()._impl_._has_bits_);
  static void set_has_create_on_client(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CSVCMsg_ClassInfo::CSVCMsg_ClassInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CSVCMsg_ClassInfo)
}
CSVCMsg_ClassInfo::CSVCMsg_ClassInfo(const CSVCMsg_ClassInfo& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CSVCMsg_ClassInfo* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.classes_){from._impl_.classes_}
    , decltype(_impl_.create_on_client_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.create_on_client_ = from._impl_.create_on_client_;
  // @@protoc_insertion_point(copy_constructor:CSVCMsg_ClassInfo)
}

inline void CSVCMsg_ClassInfo::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.classes_){arena}
    , decltype(_impl_.create_on_client_){false}
  };
}

CSVCMsg_ClassInfo::~CSVCMsg_ClassInfo() {
  // @@protoc_insertion_point(destructor:CSVCMsg_ClassInfo)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CSVCMsg_ClassInfo::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.classes_.~RepeatedPtrField();
}

void CSVCMsg_ClassInfo::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CSVCMsg_ClassInfo::Clear() {
// @@protoc_insertion_point(message_clear_start:CSVCMsg_ClassInfo)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.classes_.Clear();
  _impl_.create_on_client_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSVCMsg_ClassInfo::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool create_on_client = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_create_on_client(&has_bits);
          _impl_.create_on_client_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .CSVCMsg_ClassInfo.class_t classes = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_classes(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSVCMsg_ClassInfo::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CSVCMsg_ClassInfo)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool create_on_client = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_create_on_client(), target);
  }

  // repeated .CSVCMsg_ClassInfo.class_t classes = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_classes_size()); i < n; i++) {
    const auto& repfield = this->_internal_classes(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CSVCMsg_ClassInfo)
  return target;
}

size_t CSVCMsg_ClassInfo::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CSVCMsg_ClassInfo)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CSVCMsg_ClassInfo.class_t classes = 2;
  total_size += 1UL * this->_internal_classes_size();
  for (const auto& msg : this->_impl_.classes_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional bool create_on_client = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSVCMsg_ClassInfo::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CSVCMsg_ClassInfo::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSVCMsg_ClassInfo::GetClassData() const { return &_class_data_; }


void CSVCMsg_ClassInfo::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CSVCMsg_ClassInfo*>(&to_msg);
  auto& from = static_cast<const CSVCMsg_ClassInfo&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CSVCMsg_ClassInfo)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.classes_.MergeFrom(from._impl_.classes_);
  if (from._internal_has_create_on_client()) {
    _this->_internal_set_create_on_client(from._internal_create_on_client());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSVCMsg_ClassInfo::CopyFrom(const CSVCMsg_ClassInfo& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CSVCMsg_ClassInfo)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSVCMsg_ClassInfo::IsInitialized() const {
  return true;
}

void CSVCMsg_ClassInfo::InternalSwap(CSVCMsg_ClassInfo* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.classes_.InternalSwap(&other->_impl_.classes_);
  swap(_impl_.create_on_client_, other->_impl_.create_on_client_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CSVCMsg_ClassInfo::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[18]);
}

// ===================================================================

class CSVCMsg_SetPause::_Internal {
 public:
  using HasBits = decltype(std::declval<CSVCMsg_SetPause>()._impl_._has_bits_);
  static void set_has_paused(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CSVCMsg_SetPause::CSVCMsg_SetPause(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CSVCMsg_SetPause)
}
CSVCMsg_SetPause::CSVCMsg_SetPause(const CSVCMsg_SetPause& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CSVCMsg_SetPause* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.paused_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.paused_ = from._impl_.paused_;
  // @@protoc_insertion_point(copy_constructor:CSVCMsg_SetPause)
}

inline void CSVCMsg_SetPause::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.paused_){false}
  };
}

CSVCMsg_SetPause::~CSVCMsg_SetPause() {
  // @@protoc_insertion_point(destructor:CSVCMsg_SetPause)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CSVCMsg_SetPause::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CSVCMsg_SetPause::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CSVCMsg_SetPause::Clear() {
// @@protoc_insertion_point(message_clear_start:CSVCMsg_SetPause)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.paused_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSVCMsg_SetPause::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool paused = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_paused(&has_bits);
          _impl_.paused_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSVCMsg_SetPause::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CSVCMsg_SetPause)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool paused = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_paused(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CSVCMsg_SetPause)
  return target;
}

size_t CSVCMsg_SetPause::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CSVCMsg_SetPause)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bool paused = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSVCMsg_SetPause::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CSVCMsg_SetPause::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSVCMsg_SetPause::GetClassData() const { return &_class_data_; }


void CSVCMsg_SetPause::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CSVCMsg_SetPause*>(&to_msg);
  auto& from = static_cast<const CSVCMsg_SetPause&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CSVCMsg_SetPause)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_paused()) {
    _this->_internal_set_paused(from._internal_paused());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSVCMsg_SetPause::CopyFrom(const CSVCMsg_SetPause& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CSVCMsg_SetPause)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSVCMsg_SetPause::IsInitialized() const {
  return true;
}

void CSVCMsg_SetPause::InternalSwap(CSVCMsg_SetPause* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.paused_, other->_impl_.paused_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CSVCMsg_SetPause::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[19]);
}

// ===================================================================

class CSVCMsg_VoiceInit::_Internal {
 public:
  using HasBits = decltype(std::declval<CSVCMsg_VoiceInit>()._impl_._has_bits_);
  static void set_has_quality(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_codec(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_version(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

CSVCMsg_VoiceInit::CSVCMsg_VoiceInit(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CSVCMsg_VoiceInit)
}
CSVCMsg_VoiceInit::CSVCMsg_VoiceInit(const CSVCMsg_VoiceInit& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CSVCMsg_VoiceInit* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.codec_){}
    , decltype(_impl_.quality_){}
    , decltype(_impl_.version_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.codec_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.codec_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_codec()) {
    _this->_impl_.codec_.Set(from._internal_codec(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.quality_, &from._impl_.quality_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.version_) -
    reinterpret_cast<char*>(&_impl_.quality_)) + sizeof(_impl_.version_));
  // @@protoc_insertion_point(copy_constructor:CSVCMsg_VoiceInit)
}

inline void CSVCMsg_VoiceInit::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.codec_){}
    , decltype(_impl_.quality_){0}
    , decltype(_impl_.version_){0}
  };
  _impl_.codec_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.codec_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CSVCMsg_VoiceInit::~CSVCMsg_VoiceInit() {
  // @@protoc_insertion_point(destructor:CSVCMsg_VoiceInit)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CSVCMsg_VoiceInit::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.codec_.Destroy();
}

void CSVCMsg_VoiceInit::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CSVCMsg_VoiceInit::Clear() {
// @@protoc_insertion_point(message_clear_start:CSVCMsg_VoiceInit)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.codec_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.quality_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.version_) -
        reinterpret_cast<char*>(&_impl_.quality_)) + sizeof(_impl_.version_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSVCMsg_VoiceInit::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 quality = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_quality(&has_bits);
          _impl_.quality_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string codec = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_codec();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CSVCMsg_VoiceInit.codec");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional int32 version = 3 [default = 0];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_version(&has_bits);
          _impl_.version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSVCMsg_VoiceInit::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CSVCMsg_VoiceInit)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 quality = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_quality(), target);
  }

  // optional string codec = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_codec().data(), static_cast<int>(this->_internal_codec().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CSVCMsg_VoiceInit.codec");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_codec(), target);
  }

  // optional int32 version = 3 [default = 0];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_version(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CSVCMsg_VoiceInit)
  return target;
}

size_t CSVCMsg_VoiceInit::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CSVCMsg_VoiceInit)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string codec = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_codec());
    }

    // optional int32 quality = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_quality());
    }

    // optional int32 version = 3 [default = 0];
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_version());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSVCMsg_VoiceInit::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CSVCMsg_VoiceInit::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSVCMsg_VoiceInit::GetClassData() const { return &_class_data_; }


void CSVCMsg_VoiceInit::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CSVCMsg_VoiceInit*>(&to_msg);
  auto& from = static_cast<const CSVCMsg_VoiceInit&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CSVCMsg_VoiceInit)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_codec(from._internal_codec());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.quality_ = from._impl_.quality_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.version_ = from._impl_.version_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSVCMsg_VoiceInit::CopyFrom(const CSVCMsg_VoiceInit& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CSVCMsg_VoiceInit)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSVCMsg_VoiceInit::IsInitialized() const {
  return true;
}

void CSVCMsg_VoiceInit::InternalSwap(CSVCMsg_VoiceInit* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.codec_, lhs_arena,
      &other->_impl_.codec_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CSVCMsg_VoiceInit, _impl_.version_)
      + sizeof(CSVCMsg_VoiceInit::_impl_.version_)
      - PROTOBUF_FIELD_OFFSET(CSVCMsg_VoiceInit, _impl_.quality_)>(
          reinterpret_cast<char*>(&_impl_.quality_),
          reinterpret_cast<char*>(&other->_impl_.quality_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CSVCMsg_VoiceInit::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[20]);
}

// ===================================================================

class CSVCMsg_Print::_Internal {
 public:
  using HasBits = decltype(std::declval<CSVCMsg_Print>()._impl_._has_bits_);
  static void set_has_text(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CSVCMsg_Print::CSVCMsg_Print(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CSVCMsg_Print)
}
CSVCMsg_Print::CSVCMsg_Print(const CSVCMsg_Print& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CSVCMsg_Print* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.text_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.text_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.text_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_text()) {
    _this->_impl_.text_.Set(from._internal_text(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:CSVCMsg_Print)
}

inline void CSVCMsg_Print::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.text_){}
  };
  _impl_.text_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.text_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CSVCMsg_Print::~CSVCMsg_Print() {
  // @@protoc_insertion_point(destructor:CSVCMsg_Print)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CSVCMsg_Print::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.text_.Destroy();
}

void CSVCMsg_Print::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CSVCMsg_Print::Clear() {
// @@protoc_insertion_point(message_clear_start:CSVCMsg_Print)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.text_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSVCMsg_Print::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string text = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_text();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CSVCMsg_Print.text");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSVCMsg_Print::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CSVCMsg_Print)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string text = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_text().data(), static_cast<int>(this->_internal_text().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CSVCMsg_Print.text");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_text(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CSVCMsg_Print)
  return target;
}

size_t CSVCMsg_Print::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CSVCMsg_Print)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string text = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_text());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSVCMsg_Print::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CSVCMsg_Print::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSVCMsg_Print::GetClassData() const { return &_class_data_; }


void CSVCMsg_Print::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CSVCMsg_Print*>(&to_msg);
  auto& from = static_cast<const CSVCMsg_Print&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CSVCMsg_Print)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_text()) {
    _this->_internal_set_text(from._internal_text());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSVCMsg_Print::CopyFrom(const CSVCMsg_Print& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CSVCMsg_Print)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSVCMsg_Print::IsInitialized() const {
  return true;
}

void CSVCMsg_Print::InternalSwap(CSVCMsg_Print* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.text_, lhs_arena,
      &other->_impl_.text_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata CSVCMsg_Print::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[21]);
}

// ===================================================================

class CSVCMsg_Sounds_sounddata_t::_Internal {
 public:
  using HasBits = decltype(std::declval<CSVCMsg_Sounds_sounddata_t>()._impl_._has_bits_);
  static void set_has_origin_x(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_origin_y(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_origin_z(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_volume(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_delay_value(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_sequence_number(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_entity_index(HasBits* has_bits) {
    (*has_bits)[0] |= 262144u;
  }
  static void set_has_channel(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_pitch(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_sound_num(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_sound_num_handle(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_speaker_entity(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_random_seed(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_sound_level(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_is_sentence(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_is_ambient(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_guid(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static void set_has_sound_resource_id(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
};

CSVCMsg_Sounds_sounddata_t::CSVCMsg_Sounds_sounddata_t(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CSVCMsg_Sounds.sounddata_t)
}
CSVCMsg_Sounds_sounddata_t::CSVCMsg_Sounds_sounddata_t(const CSVCMsg_Sounds_sounddata_t& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CSVCMsg_Sounds_sounddata_t* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.origin_x_){}
    , decltype(_impl_.origin_y_){}
    , decltype(_impl_.origin_z_){}
    , decltype(_impl_.volume_){}
    , decltype(_impl_.delay_value_){}
    , decltype(_impl_.sequence_number_){}
    , decltype(_impl_.channel_){}
    , decltype(_impl_.pitch_){}
    , decltype(_impl_.flags_){}
    , decltype(_impl_.sound_num_){}
    , decltype(_impl_.sound_num_handle_){}
    , decltype(_impl_.speaker_entity_){}
    , decltype(_impl_.random_seed_){}
    , decltype(_impl_.sound_level_){}
    , decltype(_impl_.is_sentence_){}
    , decltype(_impl_.is_ambient_){}
    , decltype(_impl_.guid_){}
    , decltype(_impl_.sound_resource_id_){}
    , decltype(_impl_.entity_index_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.origin_x_, &from._impl_.origin_x_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.entity_index_) -
    reinterpret_cast<char*>(&_impl_.origin_x_)) + sizeof(_impl_.entity_index_));
  // @@protoc_insertion_point(copy_constructor:CSVCMsg_Sounds.sounddata_t)
}

inline void CSVCMsg_Sounds_sounddata_t::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.origin_x_){0}
    , decltype(_impl_.origin_y_){0}
    , decltype(_impl_.origin_z_){0}
    , decltype(_impl_.volume_){0u}
    , decltype(_impl_.delay_value_){0}
    , decltype(_impl_.sequence_number_){0}
    , decltype(_impl_.channel_){0}
    , decltype(_impl_.pitch_){0}
    , decltype(_impl_.flags_){0}
    , decltype(_impl_.sound_num_){0u}
    , decltype(_impl_.sound_num_handle_){0u}
    , decltype(_impl_.speaker_entity_){0}
    , decltype(_impl_.random_seed_){0}
    , decltype(_impl_.sound_level_){0}
    , decltype(_impl_.is_sentence_){false}
    , decltype(_impl_.is_ambient_){false}
    , decltype(_impl_.guid_){0u}
    , decltype(_impl_.sound_resource_id_){uint64_t{0u}}
    , decltype(_impl_.entity_index_){-1}
  };
}

CSVCMsg_Sounds_sounddata_t::~CSVCMsg_Sounds_sounddata_t() {
  // @@protoc_insertion_point(destructor:CSVCMsg_Sounds.sounddata_t)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CSVCMsg_Sounds_sounddata_t::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CSVCMsg_Sounds_sounddata_t::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CSVCMsg_Sounds_sounddata_t::Clear() {
// @@protoc_insertion_point(message_clear_start:CSVCMsg_Sounds.sounddata_t)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&_impl_.origin_x_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.pitch_) -
        reinterpret_cast<char*>(&_impl_.origin_x_)) + sizeof(_impl_.pitch_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&_impl_.flags_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.is_ambient_) -
        reinterpret_cast<char*>(&_impl_.flags_)) + sizeof(_impl_.is_ambient_));
  }
  if (cached_has_bits & 0x00070000u) {
    ::memset(&_impl_.guid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.sound_resource_id_) -
        reinterpret_cast<char*>(&_impl_.guid_)) + sizeof(_impl_.sound_resource_id_));
    _impl_.entity_index_ = -1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSVCMsg_Sounds_sounddata_t::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional sint32 origin_x = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_origin_x(&has_bits);
          _impl_.origin_x_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional sint32 origin_y = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_origin_y(&has_bits);
          _impl_.origin_y_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional sint32 origin_z = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_origin_z(&has_bits);
          _impl_.origin_z_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 volume = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_volume(&has_bits);
          _impl_.volume_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float delay_value = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 45)) {
          _Internal::set_has_delay_value(&has_bits);
          _impl_.delay_value_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional int32 sequence_number = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_sequence_number(&has_bits);
          _impl_.sequence_number_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 entity_index = 7 [default = -1];
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_entity_index(&has_bits);
          _impl_.entity_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 channel = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_channel(&has_bits);
          _impl_.channel_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 pitch = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_pitch(&has_bits);
          _impl_.pitch_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 flags = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_flags(&has_bits);
          _impl_.flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 sound_num = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_sound_num(&has_bits);
          _impl_.sound_num_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional fixed32 sound_num_handle = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 101)) {
          _Internal::set_has_sound_num_handle(&has_bits);
          _impl_.sound_num_handle_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // optional int32 speaker_entity = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _Internal::set_has_speaker_entity(&has_bits);
          _impl_.speaker_entity_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 random_seed = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          _Internal::set_has_random_seed(&has_bits);
          _impl_.random_seed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 sound_level = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          _Internal::set_has_sound_level(&has_bits);
          _impl_.sound_level_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_sentence = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
          _Internal::set_has_is_sentence(&has_bits);
          _impl_.is_sentence_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_ambient = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 136)) {
          _Internal::set_has_is_ambient(&has_bits);
          _impl_.is_ambient_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 guid = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 144)) {
          _Internal::set_has_guid(&has_bits);
          _impl_.guid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional fixed64 sound_resource_id = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 153)) {
          _Internal::set_has_sound_resource_id(&has_bits);
          _impl_.sound_resource_id_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSVCMsg_Sounds_sounddata_t::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CSVCMsg_Sounds.sounddata_t)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional sint32 origin_x = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSInt32ToArray(1, this->_internal_origin_x(), target);
  }

  // optional sint32 origin_y = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSInt32ToArray(2, this->_internal_origin_y(), target);
  }

  // optional sint32 origin_z = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSInt32ToArray(3, this->_internal_origin_z(), target);
  }

  // optional uint32 volume = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_volume(), target);
  }

  // optional float delay_value = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(5, this->_internal_delay_value(), target);
  }

  // optional int32 sequence_number = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(6, this->_internal_sequence_number(), target);
  }

  // optional int32 entity_index = 7 [default = -1];
  if (cached_has_bits & 0x00040000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(7, this->_internal_entity_index(), target);
  }

  // optional int32 channel = 8;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(8, this->_internal_channel(), target);
  }

  // optional int32 pitch = 9;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(9, this->_internal_pitch(), target);
  }

  // optional int32 flags = 10;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(10, this->_internal_flags(), target);
  }

  // optional uint32 sound_num = 11;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(11, this->_internal_sound_num(), target);
  }

  // optional fixed32 sound_num_handle = 12;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(12, this->_internal_sound_num_handle(), target);
  }

  // optional int32 speaker_entity = 13;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(13, this->_internal_speaker_entity(), target);
  }

  // optional int32 random_seed = 14;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(14, this->_internal_random_seed(), target);
  }

  // optional int32 sound_level = 15;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(15, this->_internal_sound_level(), target);
  }

  // optional bool is_sentence = 16;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(16, this->_internal_is_sentence(), target);
  }

  // optional bool is_ambient = 17;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(17, this->_internal_is_ambient(), target);
  }

  // optional uint32 guid = 18;
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(18, this->_internal_guid(), target);
  }

  // optional fixed64 sound_resource_id = 19;
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(19, this->_internal_sound_resource_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CSVCMsg_Sounds.sounddata_t)
  return target;
}

size_t CSVCMsg_Sounds_sounddata_t::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CSVCMsg_Sounds.sounddata_t)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional sint32 origin_x = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::SInt32SizePlusOne(this->_internal_origin_x());
    }

    // optional sint32 origin_y = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::SInt32SizePlusOne(this->_internal_origin_y());
    }

    // optional sint32 origin_z = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::SInt32SizePlusOne(this->_internal_origin_z());
    }

    // optional uint32 volume = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_volume());
    }

    // optional float delay_value = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 4;
    }

    // optional int32 sequence_number = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_sequence_number());
    }

    // optional int32 channel = 8;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_channel());
    }

    // optional int32 pitch = 9;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_pitch());
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional int32 flags = 10;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_flags());
    }

    // optional uint32 sound_num = 11;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_sound_num());
    }

    // optional fixed32 sound_num_handle = 12;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 + 4;
    }

    // optional int32 speaker_entity = 13;
    if (cached_has_bits & 0x00000800u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_speaker_entity());
    }

    // optional int32 random_seed = 14;
    if (cached_has_bits & 0x00001000u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_random_seed());
    }

    // optional int32 sound_level = 15;
    if (cached_has_bits & 0x00002000u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_sound_level());
    }

    // optional bool is_sentence = 16;
    if (cached_has_bits & 0x00004000u) {
      total_size += 2 + 1;
    }

    // optional bool is_ambient = 17;
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 + 1;
    }

  }
  if (cached_has_bits & 0x00070000u) {
    // optional uint32 guid = 18;
    if (cached_has_bits & 0x00010000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_guid());
    }

    // optional fixed64 sound_resource_id = 19;
    if (cached_has_bits & 0x00020000u) {
      total_size += 2 + 8;
    }

    // optional int32 entity_index = 7 [default = -1];
    if (cached_has_bits & 0x00040000u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_entity_index());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSVCMsg_Sounds_sounddata_t::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CSVCMsg_Sounds_sounddata_t::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSVCMsg_Sounds_sounddata_t::GetClassData() const { return &_class_data_; }


void CSVCMsg_Sounds_sounddata_t::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CSVCMsg_Sounds_sounddata_t*>(&to_msg);
  auto& from = static_cast<const CSVCMsg_Sounds_sounddata_t&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CSVCMsg_Sounds.sounddata_t)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.origin_x_ = from._impl_.origin_x_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.origin_y_ = from._impl_.origin_y_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.origin_z_ = from._impl_.origin_z_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.volume_ = from._impl_.volume_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.delay_value_ = from._impl_.delay_value_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.sequence_number_ = from._impl_.sequence_number_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.channel_ = from._impl_.channel_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.pitch_ = from._impl_.pitch_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.flags_ = from._impl_.flags_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.sound_num_ = from._impl_.sound_num_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.sound_num_handle_ = from._impl_.sound_num_handle_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.speaker_entity_ = from._impl_.speaker_entity_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.random_seed_ = from._impl_.random_seed_;
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.sound_level_ = from._impl_.sound_level_;
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_impl_.is_sentence_ = from._impl_.is_sentence_;
    }
    if (cached_has_bits & 0x00008000u) {
      _this->_impl_.is_ambient_ = from._impl_.is_ambient_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00070000u) {
    if (cached_has_bits & 0x00010000u) {
      _this->_impl_.guid_ = from._impl_.guid_;
    }
    if (cached_has_bits & 0x00020000u) {
      _this->_impl_.sound_resource_id_ = from._impl_.sound_resource_id_;
    }
    if (cached_has_bits & 0x00040000u) {
      _this->_impl_.entity_index_ = from._impl_.entity_index_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSVCMsg_Sounds_sounddata_t::CopyFrom(const CSVCMsg_Sounds_sounddata_t& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CSVCMsg_Sounds.sounddata_t)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSVCMsg_Sounds_sounddata_t::IsInitialized() const {
  return true;
}

void CSVCMsg_Sounds_sounddata_t::InternalSwap(CSVCMsg_Sounds_sounddata_t* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CSVCMsg_Sounds_sounddata_t, _impl_.sound_resource_id_)
      + sizeof(CSVCMsg_Sounds_sounddata_t::_impl_.sound_resource_id_)
      - PROTOBUF_FIELD_OFFSET(CSVCMsg_Sounds_sounddata_t, _impl_.origin_x_)>(
          reinterpret_cast<char*>(&_impl_.origin_x_),
          reinterpret_cast<char*>(&other->_impl_.origin_x_));
  swap(_impl_.entity_index_, other->_impl_.entity_index_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CSVCMsg_Sounds_sounddata_t::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[22]);
}

// ===================================================================

class CSVCMsg_Sounds::_Internal {
 public:
  using HasBits = decltype(std::declval<CSVCMsg_Sounds>()._impl_._has_bits_);
  static void set_has_reliable_sound(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CSVCMsg_Sounds::CSVCMsg_Sounds(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CSVCMsg_Sounds)
}
CSVCMsg_Sounds::CSVCMsg_Sounds(const CSVCMsg_Sounds& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CSVCMsg_Sounds* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.sounds_){from._impl_.sounds_}
    , decltype(_impl_.reliable_sound_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.reliable_sound_ = from._impl_.reliable_sound_;
  // @@protoc_insertion_point(copy_constructor:CSVCMsg_Sounds)
}

inline void CSVCMsg_Sounds::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.sounds_){arena}
    , decltype(_impl_.reliable_sound_){false}
  };
}

CSVCMsg_Sounds::~CSVCMsg_Sounds() {
  // @@protoc_insertion_point(destructor:CSVCMsg_Sounds)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CSVCMsg_Sounds::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.sounds_.~RepeatedPtrField();
}

void CSVCMsg_Sounds::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CSVCMsg_Sounds::Clear() {
// @@protoc_insertion_point(message_clear_start:CSVCMsg_Sounds)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.sounds_.Clear();
  _impl_.reliable_sound_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSVCMsg_Sounds::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool reliable_sound = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_reliable_sound(&has_bits);
          _impl_.reliable_sound_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .CSVCMsg_Sounds.sounddata_t sounds = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_sounds(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSVCMsg_Sounds::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CSVCMsg_Sounds)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool reliable_sound = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_reliable_sound(), target);
  }

  // repeated .CSVCMsg_Sounds.sounddata_t sounds = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_sounds_size()); i < n; i++) {
    const auto& repfield = this->_internal_sounds(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CSVCMsg_Sounds)
  return target;
}

size_t CSVCMsg_Sounds::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CSVCMsg_Sounds)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CSVCMsg_Sounds.sounddata_t sounds = 2;
  total_size += 1UL * this->_internal_sounds_size();
  for (const auto& msg : this->_impl_.sounds_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // optional bool reliable_sound = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 1;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSVCMsg_Sounds::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CSVCMsg_Sounds::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSVCMsg_Sounds::GetClassData() const { return &_class_data_; }


void CSVCMsg_Sounds::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CSVCMsg_Sounds*>(&to_msg);
  auto& from = static_cast<const CSVCMsg_Sounds&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CSVCMsg_Sounds)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.sounds_.MergeFrom(from._impl_.sounds_);
  if (from._internal_has_reliable_sound()) {
    _this->_internal_set_reliable_sound(from._internal_reliable_sound());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSVCMsg_Sounds::CopyFrom(const CSVCMsg_Sounds& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CSVCMsg_Sounds)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSVCMsg_Sounds::IsInitialized() const {
  return true;
}

void CSVCMsg_Sounds::InternalSwap(CSVCMsg_Sounds* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.sounds_.InternalSwap(&other->_impl_.sounds_);
  swap(_impl_.reliable_sound_, other->_impl_.reliable_sound_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CSVCMsg_Sounds::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[23]);
}

// ===================================================================

class CSVCMsg_Prefetch::_Internal {
 public:
  using HasBits = decltype(std::declval<CSVCMsg_Prefetch>()._impl_._has_bits_);
  static void set_has_sound_index(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_resource_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CSVCMsg_Prefetch::CSVCMsg_Prefetch(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CSVCMsg_Prefetch)
}
CSVCMsg_Prefetch::CSVCMsg_Prefetch(const CSVCMsg_Prefetch& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CSVCMsg_Prefetch* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.sound_index_){}
    , decltype(_impl_.resource_type_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.sound_index_, &from._impl_.sound_index_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.resource_type_) -
    reinterpret_cast<char*>(&_impl_.sound_index_)) + sizeof(_impl_.resource_type_));
  // @@protoc_insertion_point(copy_constructor:CSVCMsg_Prefetch)
}

inline void CSVCMsg_Prefetch::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.sound_index_){0}
    , decltype(_impl_.resource_type_){0}
  };
}

CSVCMsg_Prefetch::~CSVCMsg_Prefetch() {
  // @@protoc_insertion_point(destructor:CSVCMsg_Prefetch)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CSVCMsg_Prefetch::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CSVCMsg_Prefetch::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CSVCMsg_Prefetch::Clear() {
// @@protoc_insertion_point(message_clear_start:CSVCMsg_Prefetch)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.sound_index_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.resource_type_) -
        reinterpret_cast<char*>(&_impl_.sound_index_)) + sizeof(_impl_.resource_type_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSVCMsg_Prefetch::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 sound_index = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_sound_index(&has_bits);
          _impl_.sound_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .PrefetchType resource_type = 2 [default = PFT_SOUND];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::PrefetchType_IsValid(val))) {
            _internal_set_resource_type(static_cast<::PrefetchType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSVCMsg_Prefetch::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CSVCMsg_Prefetch)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 sound_index = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_sound_index(), target);
  }

  // optional .PrefetchType resource_type = 2 [default = PFT_SOUND];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_resource_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CSVCMsg_Prefetch)
  return target;
}

size_t CSVCMsg_Prefetch::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CSVCMsg_Prefetch)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional int32 sound_index = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_sound_index());
    }

    // optional .PrefetchType resource_type = 2 [default = PFT_SOUND];
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_resource_type());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSVCMsg_Prefetch::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CSVCMsg_Prefetch::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSVCMsg_Prefetch::GetClassData() const { return &_class_data_; }


void CSVCMsg_Prefetch::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CSVCMsg_Prefetch*>(&to_msg);
  auto& from = static_cast<const CSVCMsg_Prefetch&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CSVCMsg_Prefetch)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.sound_index_ = from._impl_.sound_index_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.resource_type_ = from._impl_.resource_type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSVCMsg_Prefetch::CopyFrom(const CSVCMsg_Prefetch& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CSVCMsg_Prefetch)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSVCMsg_Prefetch::IsInitialized() const {
  return true;
}

void CSVCMsg_Prefetch::InternalSwap(CSVCMsg_Prefetch* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CSVCMsg_Prefetch, _impl_.resource_type_)
      + sizeof(CSVCMsg_Prefetch::_impl_.resource_type_)
      - PROTOBUF_FIELD_OFFSET(CSVCMsg_Prefetch, _impl_.sound_index_)>(
          reinterpret_cast<char*>(&_impl_.sound_index_),
          reinterpret_cast<char*>(&other->_impl_.sound_index_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CSVCMsg_Prefetch::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[24]);
}

// ===================================================================

class CSVCMsg_SetView::_Internal {
 public:
  using HasBits = decltype(std::declval<CSVCMsg_SetView>()._impl_._has_bits_);
  static void set_has_entity_index(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_slot(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CSVCMsg_SetView::CSVCMsg_SetView(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CSVCMsg_SetView)
}
CSVCMsg_SetView::CSVCMsg_SetView(const CSVCMsg_SetView& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CSVCMsg_SetView* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.entity_index_){}
    , decltype(_impl_.slot_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.entity_index_, &from._impl_.entity_index_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.slot_) -
    reinterpret_cast<char*>(&_impl_.entity_index_)) + sizeof(_impl_.slot_));
  // @@protoc_insertion_point(copy_constructor:CSVCMsg_SetView)
}

inline void CSVCMsg_SetView::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.entity_index_){-1}
    , decltype(_impl_.slot_){-1}
  };
}

CSVCMsg_SetView::~CSVCMsg_SetView() {
  // @@protoc_insertion_point(destructor:CSVCMsg_SetView)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CSVCMsg_SetView::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CSVCMsg_SetView::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CSVCMsg_SetView::Clear() {
// @@protoc_insertion_point(message_clear_start:CSVCMsg_SetView)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    _impl_.entity_index_ = -1;
    _impl_.slot_ = -1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSVCMsg_SetView::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 entity_index = 1 [default = -1];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_entity_index(&has_bits);
          _impl_.entity_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 slot = 2 [default = -1];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_slot(&has_bits);
          _impl_.slot_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSVCMsg_SetView::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CSVCMsg_SetView)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 entity_index = 1 [default = -1];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_entity_index(), target);
  }

  // optional int32 slot = 2 [default = -1];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_slot(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CSVCMsg_SetView)
  return target;
}

size_t CSVCMsg_SetView::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CSVCMsg_SetView)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional int32 entity_index = 1 [default = -1];
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_entity_index());
    }

    // optional int32 slot = 2 [default = -1];
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_slot());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSVCMsg_SetView::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CSVCMsg_SetView::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSVCMsg_SetView::GetClassData() const { return &_class_data_; }


void CSVCMsg_SetView::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CSVCMsg_SetView*>(&to_msg);
  auto& from = static_cast<const CSVCMsg_SetView&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CSVCMsg_SetView)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.entity_index_ = from._impl_.entity_index_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.slot_ = from._impl_.slot_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSVCMsg_SetView::CopyFrom(const CSVCMsg_SetView& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CSVCMsg_SetView)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSVCMsg_SetView::IsInitialized() const {
  return true;
}

void CSVCMsg_SetView::InternalSwap(CSVCMsg_SetView* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.entity_index_, other->_impl_.entity_index_);
  swap(_impl_.slot_, other->_impl_.slot_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CSVCMsg_SetView::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[25]);
}

// ===================================================================

class CSVCMsg_FixAngle::_Internal {
 public:
  using HasBits = decltype(std::declval<CSVCMsg_FixAngle>()._impl_._has_bits_);
  static void set_has_relative(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::CMsgQAngle& angle(const CSVCMsg_FixAngle* msg);
  static void set_has_angle(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::CMsgQAngle&
CSVCMsg_FixAngle::_Internal::angle(const CSVCMsg_FixAngle* msg) {
  return *msg->_impl_.angle_;
}
void CSVCMsg_FixAngle::clear_angle() {
  if (_impl_.angle_ != nullptr) _impl_.angle_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
CSVCMsg_FixAngle::CSVCMsg_FixAngle(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CSVCMsg_FixAngle)
}
CSVCMsg_FixAngle::CSVCMsg_FixAngle(const CSVCMsg_FixAngle& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CSVCMsg_FixAngle* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.angle_){nullptr}
    , decltype(_impl_.relative_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_angle()) {
    _this->_impl_.angle_ = new ::CMsgQAngle(*from._impl_.angle_);
  }
  _this->_impl_.relative_ = from._impl_.relative_;
  // @@protoc_insertion_point(copy_constructor:CSVCMsg_FixAngle)
}

inline void CSVCMsg_FixAngle::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.angle_){nullptr}
    , decltype(_impl_.relative_){false}
  };
}

CSVCMsg_FixAngle::~CSVCMsg_FixAngle() {
  // @@protoc_insertion_point(destructor:CSVCMsg_FixAngle)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CSVCMsg_FixAngle::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.angle_;
}

void CSVCMsg_FixAngle::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CSVCMsg_FixAngle::Clear() {
// @@protoc_insertion_point(message_clear_start:CSVCMsg_FixAngle)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.angle_ != nullptr);
    _impl_.angle_->Clear();
  }
  _impl_.relative_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSVCMsg_FixAngle::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool relative = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_relative(&has_bits);
          _impl_.relative_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgQAngle angle = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_angle(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSVCMsg_FixAngle::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CSVCMsg_FixAngle)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool relative = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_relative(), target);
  }

  // optional .CMsgQAngle angle = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::angle(this),
        _Internal::angle(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CSVCMsg_FixAngle)
  return target;
}

size_t CSVCMsg_FixAngle::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CSVCMsg_FixAngle)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .CMsgQAngle angle = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.angle_);
    }

    // optional bool relative = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSVCMsg_FixAngle::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CSVCMsg_FixAngle::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSVCMsg_FixAngle::GetClassData() const { return &_class_data_; }


void CSVCMsg_FixAngle::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CSVCMsg_FixAngle*>(&to_msg);
  auto& from = static_cast<const CSVCMsg_FixAngle&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CSVCMsg_FixAngle)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_angle()->::CMsgQAngle::MergeFrom(
          from._internal_angle());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.relative_ = from._impl_.relative_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSVCMsg_FixAngle::CopyFrom(const CSVCMsg_FixAngle& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CSVCMsg_FixAngle)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSVCMsg_FixAngle::IsInitialized() const {
  return true;
}

void CSVCMsg_FixAngle::InternalSwap(CSVCMsg_FixAngle* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CSVCMsg_FixAngle, _impl_.relative_)
      + sizeof(CSVCMsg_FixAngle::_impl_.relative_)
      - PROTOBUF_FIELD_OFFSET(CSVCMsg_FixAngle, _impl_.angle_)>(
          reinterpret_cast<char*>(&_impl_.angle_),
          reinterpret_cast<char*>(&other->_impl_.angle_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CSVCMsg_FixAngle::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[26]);
}

// ===================================================================

class CSVCMsg_CrosshairAngle::_Internal {
 public:
  using HasBits = decltype(std::declval<CSVCMsg_CrosshairAngle>()._impl_._has_bits_);
  static const ::CMsgQAngle& angle(const CSVCMsg_CrosshairAngle* msg);
  static void set_has_angle(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::CMsgQAngle&
CSVCMsg_CrosshairAngle::_Internal::angle(const CSVCMsg_CrosshairAngle* msg) {
  return *msg->_impl_.angle_;
}
void CSVCMsg_CrosshairAngle::clear_angle() {
  if (_impl_.angle_ != nullptr) _impl_.angle_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
CSVCMsg_CrosshairAngle::CSVCMsg_CrosshairAngle(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CSVCMsg_CrosshairAngle)
}
CSVCMsg_CrosshairAngle::CSVCMsg_CrosshairAngle(const CSVCMsg_CrosshairAngle& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CSVCMsg_CrosshairAngle* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.angle_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_angle()) {
    _this->_impl_.angle_ = new ::CMsgQAngle(*from._impl_.angle_);
  }
  // @@protoc_insertion_point(copy_constructor:CSVCMsg_CrosshairAngle)
}

inline void CSVCMsg_CrosshairAngle::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.angle_){nullptr}
  };
}

CSVCMsg_CrosshairAngle::~CSVCMsg_CrosshairAngle() {
  // @@protoc_insertion_point(destructor:CSVCMsg_CrosshairAngle)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CSVCMsg_CrosshairAngle::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.angle_;
}

void CSVCMsg_CrosshairAngle::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CSVCMsg_CrosshairAngle::Clear() {
// @@protoc_insertion_point(message_clear_start:CSVCMsg_CrosshairAngle)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.angle_ != nullptr);
    _impl_.angle_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSVCMsg_CrosshairAngle::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .CMsgQAngle angle = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_angle(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSVCMsg_CrosshairAngle::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CSVCMsg_CrosshairAngle)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .CMsgQAngle angle = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::angle(this),
        _Internal::angle(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CSVCMsg_CrosshairAngle)
  return target;
}

size_t CSVCMsg_CrosshairAngle::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CSVCMsg_CrosshairAngle)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .CMsgQAngle angle = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.angle_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSVCMsg_CrosshairAngle::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CSVCMsg_CrosshairAngle::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSVCMsg_CrosshairAngle::GetClassData() const { return &_class_data_; }


void CSVCMsg_CrosshairAngle::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CSVCMsg_CrosshairAngle*>(&to_msg);
  auto& from = static_cast<const CSVCMsg_CrosshairAngle&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CSVCMsg_CrosshairAngle)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_angle()) {
    _this->_internal_mutable_angle()->::CMsgQAngle::MergeFrom(
        from._internal_angle());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSVCMsg_CrosshairAngle::CopyFrom(const CSVCMsg_CrosshairAngle& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CSVCMsg_CrosshairAngle)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSVCMsg_CrosshairAngle::IsInitialized() const {
  return true;
}

void CSVCMsg_CrosshairAngle::InternalSwap(CSVCMsg_CrosshairAngle* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.angle_, other->_impl_.angle_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CSVCMsg_CrosshairAngle::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[27]);
}

// ===================================================================

class CSVCMsg_BSPDecal::_Internal {
 public:
  using HasBits = decltype(std::declval<CSVCMsg_BSPDecal>()._impl_._has_bits_);
  static const ::CMsgVector& pos(const CSVCMsg_BSPDecal* msg);
  static void set_has_pos(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_decal_texture_index(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_entity_index(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_model_index(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_low_priority(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::CMsgVector&
CSVCMsg_BSPDecal::_Internal::pos(const CSVCMsg_BSPDecal* msg) {
  return *msg->_impl_.pos_;
}
void CSVCMsg_BSPDecal::clear_pos() {
  if (_impl_.pos_ != nullptr) _impl_.pos_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
CSVCMsg_BSPDecal::CSVCMsg_BSPDecal(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CSVCMsg_BSPDecal)
}
CSVCMsg_BSPDecal::CSVCMsg_BSPDecal(const CSVCMsg_BSPDecal& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CSVCMsg_BSPDecal* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.pos_){nullptr}
    , decltype(_impl_.decal_texture_index_){}
    , decltype(_impl_.model_index_){}
    , decltype(_impl_.low_priority_){}
    , decltype(_impl_.entity_index_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_pos()) {
    _this->_impl_.pos_ = new ::CMsgVector(*from._impl_.pos_);
  }
  ::memcpy(&_impl_.decal_texture_index_, &from._impl_.decal_texture_index_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.entity_index_) -
    reinterpret_cast<char*>(&_impl_.decal_texture_index_)) + sizeof(_impl_.entity_index_));
  // @@protoc_insertion_point(copy_constructor:CSVCMsg_BSPDecal)
}

inline void CSVCMsg_BSPDecal::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.pos_){nullptr}
    , decltype(_impl_.decal_texture_index_){0}
    , decltype(_impl_.model_index_){0}
    , decltype(_impl_.low_priority_){false}
    , decltype(_impl_.entity_index_){-1}
  };
}

CSVCMsg_BSPDecal::~CSVCMsg_BSPDecal() {
  // @@protoc_insertion_point(destructor:CSVCMsg_BSPDecal)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CSVCMsg_BSPDecal::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.pos_;
}

void CSVCMsg_BSPDecal::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CSVCMsg_BSPDecal::Clear() {
// @@protoc_insertion_point(message_clear_start:CSVCMsg_BSPDecal)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.pos_ != nullptr);
    _impl_.pos_->Clear();
  }
  if (cached_has_bits & 0x0000001eu) {
    ::memset(&_impl_.decal_texture_index_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.low_priority_) -
        reinterpret_cast<char*>(&_impl_.decal_texture_index_)) + sizeof(_impl_.low_priority_));
    _impl_.entity_index_ = -1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSVCMsg_BSPDecal::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .CMsgVector pos = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_pos(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 decal_texture_index = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_decal_texture_index(&has_bits);
          _impl_.decal_texture_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 entity_index = 3 [default = -1];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_entity_index(&has_bits);
          _impl_.entity_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 model_index = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_model_index(&has_bits);
          _impl_.model_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool low_priority = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_low_priority(&has_bits);
          _impl_.low_priority_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSVCMsg_BSPDecal::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CSVCMsg_BSPDecal)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .CMsgVector pos = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::pos(this),
        _Internal::pos(this).GetCachedSize(), target, stream);
  }

  // optional int32 decal_texture_index = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_decal_texture_index(), target);
  }

  // optional int32 entity_index = 3 [default = -1];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_entity_index(), target);
  }

  // optional int32 model_index = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_model_index(), target);
  }

  // optional bool low_priority = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_low_priority(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CSVCMsg_BSPDecal)
  return target;
}

size_t CSVCMsg_BSPDecal::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CSVCMsg_BSPDecal)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional .CMsgVector pos = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.pos_);
    }

    // optional int32 decal_texture_index = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_decal_texture_index());
    }

    // optional int32 model_index = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_model_index());
    }

    // optional bool low_priority = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

    // optional int32 entity_index = 3 [default = -1];
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_entity_index());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSVCMsg_BSPDecal::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CSVCMsg_BSPDecal::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSVCMsg_BSPDecal::GetClassData() const { return &_class_data_; }


void CSVCMsg_BSPDecal::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CSVCMsg_BSPDecal*>(&to_msg);
  auto& from = static_cast<const CSVCMsg_BSPDecal&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CSVCMsg_BSPDecal)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_pos()->::CMsgVector::MergeFrom(
          from._internal_pos());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.decal_texture_index_ = from._impl_.decal_texture_index_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.model_index_ = from._impl_.model_index_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.low_priority_ = from._impl_.low_priority_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.entity_index_ = from._impl_.entity_index_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSVCMsg_BSPDecal::CopyFrom(const CSVCMsg_BSPDecal& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CSVCMsg_BSPDecal)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSVCMsg_BSPDecal::IsInitialized() const {
  return true;
}

void CSVCMsg_BSPDecal::InternalSwap(CSVCMsg_BSPDecal* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CSVCMsg_BSPDecal, _impl_.low_priority_)
      + sizeof(CSVCMsg_BSPDecal::_impl_.low_priority_)
      - PROTOBUF_FIELD_OFFSET(CSVCMsg_BSPDecal, _impl_.pos_)>(
          reinterpret_cast<char*>(&_impl_.pos_),
          reinterpret_cast<char*>(&other->_impl_.pos_));
  swap(_impl_.entity_index_, other->_impl_.entity_index_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CSVCMsg_BSPDecal::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[28]);
}

// ===================================================================

class CSVCMsg_SplitScreen::_Internal {
 public:
  using HasBits = decltype(std::declval<CSVCMsg_SplitScreen>()._impl_._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_slot(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_player_index(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

CSVCMsg_SplitScreen::CSVCMsg_SplitScreen(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CSVCMsg_SplitScreen)
}
CSVCMsg_SplitScreen::CSVCMsg_SplitScreen(const CSVCMsg_SplitScreen& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CSVCMsg_SplitScreen* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.type_){}
    , decltype(_impl_.slot_){}
    , decltype(_impl_.player_index_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.type_, &from._impl_.type_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.player_index_) -
    reinterpret_cast<char*>(&_impl_.type_)) + sizeof(_impl_.player_index_));
  // @@protoc_insertion_point(copy_constructor:CSVCMsg_SplitScreen)
}

inline void CSVCMsg_SplitScreen::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.type_){0}
    , decltype(_impl_.slot_){0}
    , decltype(_impl_.player_index_){-1}
  };
}

CSVCMsg_SplitScreen::~CSVCMsg_SplitScreen() {
  // @@protoc_insertion_point(destructor:CSVCMsg_SplitScreen)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CSVCMsg_SplitScreen::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CSVCMsg_SplitScreen::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CSVCMsg_SplitScreen::Clear() {
// @@protoc_insertion_point(message_clear_start:CSVCMsg_SplitScreen)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.slot_) -
        reinterpret_cast<char*>(&_impl_.type_)) + sizeof(_impl_.slot_));
    _impl_.player_index_ = -1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSVCMsg_SplitScreen::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .ESplitScreenMessageType type = 1 [default = MSG_SPLITSCREEN_ADDUSER];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::ESplitScreenMessageType_IsValid(val))) {
            _internal_set_type(static_cast<::ESplitScreenMessageType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional int32 slot = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_slot(&has_bits);
          _impl_.slot_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 player_index = 3 [default = -1];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_player_index(&has_bits);
          _impl_.player_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSVCMsg_SplitScreen::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CSVCMsg_SplitScreen)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .ESplitScreenMessageType type = 1 [default = MSG_SPLITSCREEN_ADDUSER];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_type(), target);
  }

  // optional int32 slot = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_slot(), target);
  }

  // optional int32 player_index = 3 [default = -1];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_player_index(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CSVCMsg_SplitScreen)
  return target;
}

size_t CSVCMsg_SplitScreen::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CSVCMsg_SplitScreen)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .ESplitScreenMessageType type = 1 [default = MSG_SPLITSCREEN_ADDUSER];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
    }

    // optional int32 slot = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_slot());
    }

    // optional int32 player_index = 3 [default = -1];
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_player_index());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSVCMsg_SplitScreen::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CSVCMsg_SplitScreen::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSVCMsg_SplitScreen::GetClassData() const { return &_class_data_; }


void CSVCMsg_SplitScreen::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CSVCMsg_SplitScreen*>(&to_msg);
  auto& from = static_cast<const CSVCMsg_SplitScreen&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CSVCMsg_SplitScreen)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.slot_ = from._impl_.slot_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.player_index_ = from._impl_.player_index_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSVCMsg_SplitScreen::CopyFrom(const CSVCMsg_SplitScreen& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CSVCMsg_SplitScreen)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSVCMsg_SplitScreen::IsInitialized() const {
  return true;
}

void CSVCMsg_SplitScreen::InternalSwap(CSVCMsg_SplitScreen* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CSVCMsg_SplitScreen, _impl_.slot_)
      + sizeof(CSVCMsg_SplitScreen::_impl_.slot_)
      - PROTOBUF_FIELD_OFFSET(CSVCMsg_SplitScreen, _impl_.type_)>(
          reinterpret_cast<char*>(&_impl_.type_),
          reinterpret_cast<char*>(&other->_impl_.type_));
  swap(_impl_.player_index_, other->_impl_.player_index_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CSVCMsg_SplitScreen::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[29]);
}

// ===================================================================

class CSVCMsg_GetCvarValue::_Internal {
 public:
  using HasBits = decltype(std::declval<CSVCMsg_GetCvarValue>()._impl_._has_bits_);
  static void set_has_cookie(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_cvar_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CSVCMsg_GetCvarValue::CSVCMsg_GetCvarValue(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CSVCMsg_GetCvarValue)
}
CSVCMsg_GetCvarValue::CSVCMsg_GetCvarValue(const CSVCMsg_GetCvarValue& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CSVCMsg_GetCvarValue* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.cvar_name_){}
    , decltype(_impl_.cookie_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.cvar_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.cvar_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_cvar_name()) {
    _this->_impl_.cvar_name_.Set(from._internal_cvar_name(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.cookie_ = from._impl_.cookie_;
  // @@protoc_insertion_point(copy_constructor:CSVCMsg_GetCvarValue)
}

inline void CSVCMsg_GetCvarValue::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.cvar_name_){}
    , decltype(_impl_.cookie_){0}
  };
  _impl_.cvar_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.cvar_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CSVCMsg_GetCvarValue::~CSVCMsg_GetCvarValue() {
  // @@protoc_insertion_point(destructor:CSVCMsg_GetCvarValue)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CSVCMsg_GetCvarValue::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.cvar_name_.Destroy();
}

void CSVCMsg_GetCvarValue::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CSVCMsg_GetCvarValue::Clear() {
// @@protoc_insertion_point(message_clear_start:CSVCMsg_GetCvarValue)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.cvar_name_.ClearNonDefaultToEmpty();
  }
  _impl_.cookie_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSVCMsg_GetCvarValue::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 cookie = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_cookie(&has_bits);
          _impl_.cookie_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string cvar_name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_cvar_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CSVCMsg_GetCvarValue.cvar_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSVCMsg_GetCvarValue::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CSVCMsg_GetCvarValue)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 cookie = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_cookie(), target);
  }

  // optional string cvar_name = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_cvar_name().data(), static_cast<int>(this->_internal_cvar_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CSVCMsg_GetCvarValue.cvar_name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_cvar_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CSVCMsg_GetCvarValue)
  return target;
}

size_t CSVCMsg_GetCvarValue::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CSVCMsg_GetCvarValue)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string cvar_name = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_cvar_name());
    }

    // optional int32 cookie = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_cookie());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSVCMsg_GetCvarValue::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CSVCMsg_GetCvarValue::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSVCMsg_GetCvarValue::GetClassData() const { return &_class_data_; }


void CSVCMsg_GetCvarValue::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CSVCMsg_GetCvarValue*>(&to_msg);
  auto& from = static_cast<const CSVCMsg_GetCvarValue&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CSVCMsg_GetCvarValue)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_cvar_name(from._internal_cvar_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.cookie_ = from._impl_.cookie_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSVCMsg_GetCvarValue::CopyFrom(const CSVCMsg_GetCvarValue& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CSVCMsg_GetCvarValue)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSVCMsg_GetCvarValue::IsInitialized() const {
  return true;
}

void CSVCMsg_GetCvarValue::InternalSwap(CSVCMsg_GetCvarValue* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.cvar_name_, lhs_arena,
      &other->_impl_.cvar_name_, rhs_arena
  );
  swap(_impl_.cookie_, other->_impl_.cookie_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CSVCMsg_GetCvarValue::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[30]);
}

// ===================================================================

class CSVCMsg_Menu::_Internal {
 public:
  using HasBits = decltype(std::declval<CSVCMsg_Menu>()._impl_._has_bits_);
  static void set_has_dialog_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_menu_key_values(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CSVCMsg_Menu::CSVCMsg_Menu(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CSVCMsg_Menu)
}
CSVCMsg_Menu::CSVCMsg_Menu(const CSVCMsg_Menu& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CSVCMsg_Menu* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.menu_key_values_){}
    , decltype(_impl_.dialog_type_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.menu_key_values_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.menu_key_values_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_menu_key_values()) {
    _this->_impl_.menu_key_values_.Set(from._internal_menu_key_values(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.dialog_type_ = from._impl_.dialog_type_;
  // @@protoc_insertion_point(copy_constructor:CSVCMsg_Menu)
}

inline void CSVCMsg_Menu::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.menu_key_values_){}
    , decltype(_impl_.dialog_type_){0}
  };
  _impl_.menu_key_values_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.menu_key_values_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CSVCMsg_Menu::~CSVCMsg_Menu() {
  // @@protoc_insertion_point(destructor:CSVCMsg_Menu)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CSVCMsg_Menu::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.menu_key_values_.Destroy();
}

void CSVCMsg_Menu::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CSVCMsg_Menu::Clear() {
// @@protoc_insertion_point(message_clear_start:CSVCMsg_Menu)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.menu_key_values_.ClearNonDefaultToEmpty();
  }
  _impl_.dialog_type_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSVCMsg_Menu::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 dialog_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dialog_type(&has_bits);
          _impl_.dialog_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes menu_key_values = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_menu_key_values();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSVCMsg_Menu::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CSVCMsg_Menu)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 dialog_type = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_dialog_type(), target);
  }

  // optional bytes menu_key_values = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_menu_key_values(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CSVCMsg_Menu)
  return target;
}

size_t CSVCMsg_Menu::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CSVCMsg_Menu)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bytes menu_key_values = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_menu_key_values());
    }

    // optional int32 dialog_type = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_dialog_type());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSVCMsg_Menu::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CSVCMsg_Menu::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSVCMsg_Menu::GetClassData() const { return &_class_data_; }


void CSVCMsg_Menu::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CSVCMsg_Menu*>(&to_msg);
  auto& from = static_cast<const CSVCMsg_Menu&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CSVCMsg_Menu)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_menu_key_values(from._internal_menu_key_values());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.dialog_type_ = from._impl_.dialog_type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSVCMsg_Menu::CopyFrom(const CSVCMsg_Menu& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CSVCMsg_Menu)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSVCMsg_Menu::IsInitialized() const {
  return true;
}

void CSVCMsg_Menu::InternalSwap(CSVCMsg_Menu* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.menu_key_values_, lhs_arena,
      &other->_impl_.menu_key_values_, rhs_arena
  );
  swap(_impl_.dialog_type_, other->_impl_.dialog_type_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CSVCMsg_Menu::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[31]);
}

// ===================================================================

class CSVCMsg_UserMessage::_Internal {
 public:
  using HasBits = decltype(std::declval<CSVCMsg_UserMessage>()._impl_._has_bits_);
  static void set_has_msg_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_msg_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_passthrough(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

CSVCMsg_UserMessage::CSVCMsg_UserMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CSVCMsg_UserMessage)
}
CSVCMsg_UserMessage::CSVCMsg_UserMessage(const CSVCMsg_UserMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CSVCMsg_UserMessage* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.msg_data_){}
    , decltype(_impl_.msg_type_){}
    , decltype(_impl_.passthrough_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.msg_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.msg_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_msg_data()) {
    _this->_impl_.msg_data_.Set(from._internal_msg_data(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.msg_type_, &from._impl_.msg_type_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.passthrough_) -
    reinterpret_cast<char*>(&_impl_.msg_type_)) + sizeof(_impl_.passthrough_));
  // @@protoc_insertion_point(copy_constructor:CSVCMsg_UserMessage)
}

inline void CSVCMsg_UserMessage::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.msg_data_){}
    , decltype(_impl_.msg_type_){0}
    , decltype(_impl_.passthrough_){0}
  };
  _impl_.msg_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.msg_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CSVCMsg_UserMessage::~CSVCMsg_UserMessage() {
  // @@protoc_insertion_point(destructor:CSVCMsg_UserMessage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CSVCMsg_UserMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.msg_data_.Destroy();
}

void CSVCMsg_UserMessage::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CSVCMsg_UserMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:CSVCMsg_UserMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.msg_data_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.msg_type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.passthrough_) -
        reinterpret_cast<char*>(&_impl_.msg_type_)) + sizeof(_impl_.passthrough_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSVCMsg_UserMessage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 msg_type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_msg_type(&has_bits);
          _impl_.msg_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes msg_data = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_msg_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 passthrough = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_passthrough(&has_bits);
          _impl_.passthrough_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSVCMsg_UserMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CSVCMsg_UserMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 msg_type = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_msg_type(), target);
  }

  // optional bytes msg_data = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_msg_data(), target);
  }

  // optional int32 passthrough = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_passthrough(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CSVCMsg_UserMessage)
  return target;
}

size_t CSVCMsg_UserMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CSVCMsg_UserMessage)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional bytes msg_data = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_msg_data());
    }

    // optional int32 msg_type = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_msg_type());
    }

    // optional int32 passthrough = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_passthrough());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSVCMsg_UserMessage::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CSVCMsg_UserMessage::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSVCMsg_UserMessage::GetClassData() const { return &_class_data_; }


void CSVCMsg_UserMessage::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CSVCMsg_UserMessage*>(&to_msg);
  auto& from = static_cast<const CSVCMsg_UserMessage&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CSVCMsg_UserMessage)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_msg_data(from._internal_msg_data());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.msg_type_ = from._impl_.msg_type_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.passthrough_ = from._impl_.passthrough_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSVCMsg_UserMessage::CopyFrom(const CSVCMsg_UserMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CSVCMsg_UserMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSVCMsg_UserMessage::IsInitialized() const {
  return true;
}

void CSVCMsg_UserMessage::InternalSwap(CSVCMsg_UserMessage* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.msg_data_, lhs_arena,
      &other->_impl_.msg_data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CSVCMsg_UserMessage, _impl_.passthrough_)
      + sizeof(CSVCMsg_UserMessage::_impl_.passthrough_)
      - PROTOBUF_FIELD_OFFSET(CSVCMsg_UserMessage, _impl_.msg_type_)>(
          reinterpret_cast<char*>(&_impl_.msg_type_),
          reinterpret_cast<char*>(&other->_impl_.msg_type_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CSVCMsg_UserMessage::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[32]);
}

// ===================================================================

class CSVCMsg_SendTable_sendprop_t::_Internal {
 public:
  using HasBits = decltype(std::declval<CSVCMsg_SendTable_sendprop_t>()._impl_._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_var_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_priority(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_dt_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_num_elements(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_low_value(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_high_value(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_num_bits(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
};

CSVCMsg_SendTable_sendprop_t::CSVCMsg_SendTable_sendprop_t(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CSVCMsg_SendTable.sendprop_t)
}
CSVCMsg_SendTable_sendprop_t::CSVCMsg_SendTable_sendprop_t(const CSVCMsg_SendTable_sendprop_t& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CSVCMsg_SendTable_sendprop_t* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.var_name_){}
    , decltype(_impl_.dt_name_){}
    , decltype(_impl_.type_){}
    , decltype(_impl_.flags_){}
    , decltype(_impl_.priority_){}
    , decltype(_impl_.num_elements_){}
    , decltype(_impl_.low_value_){}
    , decltype(_impl_.high_value_){}
    , decltype(_impl_.num_bits_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.var_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.var_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_var_name()) {
    _this->_impl_.var_name_.Set(from._internal_var_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.dt_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.dt_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_dt_name()) {
    _this->_impl_.dt_name_.Set(from._internal_dt_name(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.type_, &from._impl_.type_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.num_bits_) -
    reinterpret_cast<char*>(&_impl_.type_)) + sizeof(_impl_.num_bits_));
  // @@protoc_insertion_point(copy_constructor:CSVCMsg_SendTable.sendprop_t)
}

inline void CSVCMsg_SendTable_sendprop_t::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.var_name_){}
    , decltype(_impl_.dt_name_){}
    , decltype(_impl_.type_){0}
    , decltype(_impl_.flags_){0}
    , decltype(_impl_.priority_){0}
    , decltype(_impl_.num_elements_){0}
    , decltype(_impl_.low_value_){0}
    , decltype(_impl_.high_value_){0}
    , decltype(_impl_.num_bits_){0}
  };
  _impl_.var_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.var_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.dt_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.dt_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CSVCMsg_SendTable_sendprop_t::~CSVCMsg_SendTable_sendprop_t() {
  // @@protoc_insertion_point(destructor:CSVCMsg_SendTable.sendprop_t)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CSVCMsg_SendTable_sendprop_t::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.var_name_.Destroy();
  _impl_.dt_name_.Destroy();
}

void CSVCMsg_SendTable_sendprop_t::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CSVCMsg_SendTable_sendprop_t::Clear() {
// @@protoc_insertion_point(message_clear_start:CSVCMsg_SendTable.sendprop_t)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.var_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.dt_name_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000fcu) {
    ::memset(&_impl_.type_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.high_value_) -
        reinterpret_cast<char*>(&_impl_.type_)) + sizeof(_impl_.high_value_));
  }
  _impl_.num_bits_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSVCMsg_SendTable_sendprop_t::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_type(&has_bits);
          _impl_.type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string var_name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_var_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CSVCMsg_SendTable.sendprop_t.var_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional int32 flags = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_flags(&has_bits);
          _impl_.flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 priority = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_priority(&has_bits);
          _impl_.priority_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string dt_name = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          auto str = _internal_mutable_dt_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CSVCMsg_SendTable.sendprop_t.dt_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional int32 num_elements = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_num_elements(&has_bits);
          _impl_.num_elements_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float low_value = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 61)) {
          _Internal::set_has_low_value(&has_bits);
          _impl_.low_value_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float high_value = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 69)) {
          _Internal::set_has_high_value(&has_bits);
          _impl_.high_value_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional int32 num_bits = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_num_bits(&has_bits);
          _impl_.num_bits_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSVCMsg_SendTable_sendprop_t::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CSVCMsg_SendTable.sendprop_t)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 type = 1;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_type(), target);
  }

  // optional string var_name = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_var_name().data(), static_cast<int>(this->_internal_var_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CSVCMsg_SendTable.sendprop_t.var_name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_var_name(), target);
  }

  // optional int32 flags = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_flags(), target);
  }

  // optional int32 priority = 4;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_priority(), target);
  }

  // optional string dt_name = 5;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_dt_name().data(), static_cast<int>(this->_internal_dt_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CSVCMsg_SendTable.sendprop_t.dt_name");
    target = stream->WriteStringMaybeAliased(
        5, this->_internal_dt_name(), target);
  }

  // optional int32 num_elements = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(6, this->_internal_num_elements(), target);
  }

  // optional float low_value = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(7, this->_internal_low_value(), target);
  }

  // optional float high_value = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(8, this->_internal_high_value(), target);
  }

  // optional int32 num_bits = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(9, this->_internal_num_bits(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CSVCMsg_SendTable.sendprop_t)
  return target;
}

size_t CSVCMsg_SendTable_sendprop_t::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CSVCMsg_SendTable.sendprop_t)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string var_name = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_var_name());
    }

    // optional string dt_name = 5;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_dt_name());
    }

    // optional int32 type = 1;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_type());
    }

    // optional int32 flags = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_flags());
    }

    // optional int32 priority = 4;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_priority());
    }

    // optional int32 num_elements = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_num_elements());
    }

    // optional float low_value = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 4;
    }

    // optional float high_value = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 4;
    }

  }
  // optional int32 num_bits = 9;
  if (cached_has_bits & 0x00000100u) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_num_bits());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSVCMsg_SendTable_sendprop_t::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CSVCMsg_SendTable_sendprop_t::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSVCMsg_SendTable_sendprop_t::GetClassData() const { return &_class_data_; }


void CSVCMsg_SendTable_sendprop_t::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CSVCMsg_SendTable_sendprop_t*>(&to_msg);
  auto& from = static_cast<const CSVCMsg_SendTable_sendprop_t&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CSVCMsg_SendTable.sendprop_t)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_var_name(from._internal_var_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_dt_name(from._internal_dt_name());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.flags_ = from._impl_.flags_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.priority_ = from._impl_.priority_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.num_elements_ = from._impl_.num_elements_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.low_value_ = from._impl_.low_value_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.high_value_ = from._impl_.high_value_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000100u) {
    _this->_internal_set_num_bits(from._internal_num_bits());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSVCMsg_SendTable_sendprop_t::CopyFrom(const CSVCMsg_SendTable_sendprop_t& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CSVCMsg_SendTable.sendprop_t)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSVCMsg_SendTable_sendprop_t::IsInitialized() const {
  return true;
}

void CSVCMsg_SendTable_sendprop_t::InternalSwap(CSVCMsg_SendTable_sendprop_t* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.var_name_, lhs_arena,
      &other->_impl_.var_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.dt_name_, lhs_arena,
      &other->_impl_.dt_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CSVCMsg_SendTable_sendprop_t, _impl_.num_bits_)
      + sizeof(CSVCMsg_SendTable_sendprop_t::_impl_.num_bits_)
      - PROTOBUF_FIELD_OFFSET(CSVCMsg_SendTable_sendprop_t, _impl_.type_)>(
          reinterpret_cast<char*>(&_impl_.type_),
          reinterpret_cast<char*>(&other->_impl_.type_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CSVCMsg_SendTable_sendprop_t::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[33]);
}

// ===================================================================

class CSVCMsg_SendTable::_Internal {
 public:
  using HasBits = decltype(std::declval<CSVCMsg_SendTable>()._impl_._has_bits_);
  static void set_has_is_end(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_net_table_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_needs_decoder(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

CSVCMsg_SendTable::CSVCMsg_SendTable(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CSVCMsg_SendTable)
}
CSVCMsg_SendTable::CSVCMsg_SendTable(const CSVCMsg_SendTable& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CSVCMsg_SendTable* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.props_){from._impl_.props_}
    , decltype(_impl_.net_table_name_){}
    , decltype(_impl_.is_end_){}
    , decltype(_impl_.needs_decoder_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.net_table_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.net_table_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_net_table_name()) {
    _this->_impl_.net_table_name_.Set(from._internal_net_table_name(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.is_end_, &from._impl_.is_end_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.needs_decoder_) -
    reinterpret_cast<char*>(&_impl_.is_end_)) + sizeof(_impl_.needs_decoder_));
  // @@protoc_insertion_point(copy_constructor:CSVCMsg_SendTable)
}

inline void CSVCMsg_SendTable::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.props_){arena}
    , decltype(_impl_.net_table_name_){}
    , decltype(_impl_.is_end_){false}
    , decltype(_impl_.needs_decoder_){false}
  };
  _impl_.net_table_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.net_table_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CSVCMsg_SendTable::~CSVCMsg_SendTable() {
  // @@protoc_insertion_point(destructor:CSVCMsg_SendTable)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CSVCMsg_SendTable::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.props_.~RepeatedPtrField();
  _impl_.net_table_name_.Destroy();
}

void CSVCMsg_SendTable::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CSVCMsg_SendTable::Clear() {
// @@protoc_insertion_point(message_clear_start:CSVCMsg_SendTable)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.props_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.net_table_name_.ClearNonDefaultToEmpty();
  }
  ::memset(&_impl_.is_end_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&_impl_.needs_decoder_) -
      reinterpret_cast<char*>(&_impl_.is_end_)) + sizeof(_impl_.needs_decoder_));
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSVCMsg_SendTable::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool is_end = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_is_end(&has_bits);
          _impl_.is_end_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string net_table_name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_net_table_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CSVCMsg_SendTable.net_table_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional bool needs_decoder = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_needs_decoder(&has_bits);
          _impl_.needs_decoder_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .CSVCMsg_SendTable.sendprop_t props = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_props(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSVCMsg_SendTable::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CSVCMsg_SendTable)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool is_end = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_is_end(), target);
  }

  // optional string net_table_name = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_net_table_name().data(), static_cast<int>(this->_internal_net_table_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CSVCMsg_SendTable.net_table_name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_net_table_name(), target);
  }

  // optional bool needs_decoder = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_needs_decoder(), target);
  }

  // repeated .CSVCMsg_SendTable.sendprop_t props = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_props_size()); i < n; i++) {
    const auto& repfield = this->_internal_props(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CSVCMsg_SendTable)
  return target;
}

size_t CSVCMsg_SendTable::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CSVCMsg_SendTable)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CSVCMsg_SendTable.sendprop_t props = 4;
  total_size += 1UL * this->_internal_props_size();
  for (const auto& msg : this->_impl_.props_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional string net_table_name = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_net_table_name());
    }

    // optional bool is_end = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

    // optional bool needs_decoder = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSVCMsg_SendTable::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CSVCMsg_SendTable::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSVCMsg_SendTable::GetClassData() const { return &_class_data_; }


void CSVCMsg_SendTable::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CSVCMsg_SendTable*>(&to_msg);
  auto& from = static_cast<const CSVCMsg_SendTable&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CSVCMsg_SendTable)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.props_.MergeFrom(from._impl_.props_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_net_table_name(from._internal_net_table_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.is_end_ = from._impl_.is_end_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.needs_decoder_ = from._impl_.needs_decoder_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSVCMsg_SendTable::CopyFrom(const CSVCMsg_SendTable& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CSVCMsg_SendTable)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSVCMsg_SendTable::IsInitialized() const {
  return true;
}

void CSVCMsg_SendTable::InternalSwap(CSVCMsg_SendTable* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.props_.InternalSwap(&other->_impl_.props_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.net_table_name_, lhs_arena,
      &other->_impl_.net_table_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CSVCMsg_SendTable, _impl_.needs_decoder_)
      + sizeof(CSVCMsg_SendTable::_impl_.needs_decoder_)
      - PROTOBUF_FIELD_OFFSET(CSVCMsg_SendTable, _impl_.is_end_)>(
          reinterpret_cast<char*>(&_impl_.is_end_),
          reinterpret_cast<char*>(&other->_impl_.is_end_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CSVCMsg_SendTable::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[34]);
}

// ===================================================================

class CSVCMsg_GameEventList_key_t::_Internal {
 public:
  using HasBits = decltype(std::declval<CSVCMsg_GameEventList_key_t>()._impl_._has_bits_);
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CSVCMsg_GameEventList_key_t::CSVCMsg_GameEventList_key_t(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CSVCMsg_GameEventList.key_t)
}
CSVCMsg_GameEventList_key_t::CSVCMsg_GameEventList_key_t(const CSVCMsg_GameEventList_key_t& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CSVCMsg_GameEventList_key_t* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.type_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.type_ = from._impl_.type_;
  // @@protoc_insertion_point(copy_constructor:CSVCMsg_GameEventList.key_t)
}

inline void CSVCMsg_GameEventList_key_t::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.type_){0}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CSVCMsg_GameEventList_key_t::~CSVCMsg_GameEventList_key_t() {
  // @@protoc_insertion_point(destructor:CSVCMsg_GameEventList.key_t)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CSVCMsg_GameEventList_key_t::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
}

void CSVCMsg_GameEventList_key_t::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CSVCMsg_GameEventList_key_t::Clear() {
// @@protoc_insertion_point(message_clear_start:CSVCMsg_GameEventList.key_t)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.name_.ClearNonDefaultToEmpty();
  }
  _impl_.type_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSVCMsg_GameEventList_key_t::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_type(&has_bits);
          _impl_.type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CSVCMsg_GameEventList.key_t.name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSVCMsg_GameEventList_key_t::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CSVCMsg_GameEventList.key_t)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 type = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_type(), target);
  }

  // optional string name = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CSVCMsg_GameEventList.key_t.name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CSVCMsg_GameEventList.key_t)
  return target;
}

size_t CSVCMsg_GameEventList_key_t::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CSVCMsg_GameEventList.key_t)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string name = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional int32 type = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_type());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSVCMsg_GameEventList_key_t::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CSVCMsg_GameEventList_key_t::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSVCMsg_GameEventList_key_t::GetClassData() const { return &_class_data_; }


void CSVCMsg_GameEventList_key_t::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CSVCMsg_GameEventList_key_t*>(&to_msg);
  auto& from = static_cast<const CSVCMsg_GameEventList_key_t&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CSVCMsg_GameEventList.key_t)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSVCMsg_GameEventList_key_t::CopyFrom(const CSVCMsg_GameEventList_key_t& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CSVCMsg_GameEventList.key_t)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSVCMsg_GameEventList_key_t::IsInitialized() const {
  return true;
}

void CSVCMsg_GameEventList_key_t::InternalSwap(CSVCMsg_GameEventList_key_t* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  swap(_impl_.type_, other->_impl_.type_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CSVCMsg_GameEventList_key_t::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[35]);
}

// ===================================================================

class CSVCMsg_GameEventList_descriptor_t::_Internal {
 public:
  using HasBits = decltype(std::declval<CSVCMsg_GameEventList_descriptor_t>()._impl_._has_bits_);
  static void set_has_eventid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CSVCMsg_GameEventList_descriptor_t::CSVCMsg_GameEventList_descriptor_t(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CSVCMsg_GameEventList.descriptor_t)
}
CSVCMsg_GameEventList_descriptor_t::CSVCMsg_GameEventList_descriptor_t(const CSVCMsg_GameEventList_descriptor_t& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CSVCMsg_GameEventList_descriptor_t* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.keys_){from._impl_.keys_}
    , decltype(_impl_.name_){}
    , decltype(_impl_.eventid_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.eventid_ = from._impl_.eventid_;
  // @@protoc_insertion_point(copy_constructor:CSVCMsg_GameEventList.descriptor_t)
}

inline void CSVCMsg_GameEventList_descriptor_t::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.keys_){arena}
    , decltype(_impl_.name_){}
    , decltype(_impl_.eventid_){0}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CSVCMsg_GameEventList_descriptor_t::~CSVCMsg_GameEventList_descriptor_t() {
  // @@protoc_insertion_point(destructor:CSVCMsg_GameEventList.descriptor_t)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CSVCMsg_GameEventList_descriptor_t::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.keys_.~RepeatedPtrField();
  _impl_.name_.Destroy();
}

void CSVCMsg_GameEventList_descriptor_t::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CSVCMsg_GameEventList_descriptor_t::Clear() {
// @@protoc_insertion_point(message_clear_start:CSVCMsg_GameEventList.descriptor_t)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.keys_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.name_.ClearNonDefaultToEmpty();
  }
  _impl_.eventid_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSVCMsg_GameEventList_descriptor_t::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 eventid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_eventid(&has_bits);
          _impl_.eventid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CSVCMsg_GameEventList.descriptor_t.name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // repeated .CSVCMsg_GameEventList.key_t keys = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_keys(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSVCMsg_GameEventList_descriptor_t::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CSVCMsg_GameEventList.descriptor_t)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 eventid = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_eventid(), target);
  }

  // optional string name = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CSVCMsg_GameEventList.descriptor_t.name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_name(), target);
  }

  // repeated .CSVCMsg_GameEventList.key_t keys = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_keys_size()); i < n; i++) {
    const auto& repfield = this->_internal_keys(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CSVCMsg_GameEventList.descriptor_t)
  return target;
}

size_t CSVCMsg_GameEventList_descriptor_t::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CSVCMsg_GameEventList.descriptor_t)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CSVCMsg_GameEventList.key_t keys = 3;
  total_size += 1UL * this->_internal_keys_size();
  for (const auto& msg : this->_impl_.keys_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string name = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional int32 eventid = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_eventid());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSVCMsg_GameEventList_descriptor_t::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CSVCMsg_GameEventList_descriptor_t::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSVCMsg_GameEventList_descriptor_t::GetClassData() const { return &_class_data_; }


void CSVCMsg_GameEventList_descriptor_t::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CSVCMsg_GameEventList_descriptor_t*>(&to_msg);
  auto& from = static_cast<const CSVCMsg_GameEventList_descriptor_t&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CSVCMsg_GameEventList.descriptor_t)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.keys_.MergeFrom(from._impl_.keys_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.eventid_ = from._impl_.eventid_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSVCMsg_GameEventList_descriptor_t::CopyFrom(const CSVCMsg_GameEventList_descriptor_t& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CSVCMsg_GameEventList.descriptor_t)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSVCMsg_GameEventList_descriptor_t::IsInitialized() const {
  return true;
}

void CSVCMsg_GameEventList_descriptor_t::InternalSwap(CSVCMsg_GameEventList_descriptor_t* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.keys_.InternalSwap(&other->_impl_.keys_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  swap(_impl_.eventid_, other->_impl_.eventid_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CSVCMsg_GameEventList_descriptor_t::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[36]);
}

// ===================================================================

class CSVCMsg_GameEventList::_Internal {
 public:
};

CSVCMsg_GameEventList::CSVCMsg_GameEventList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CSVCMsg_GameEventList)
}
CSVCMsg_GameEventList::CSVCMsg_GameEventList(const CSVCMsg_GameEventList& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CSVCMsg_GameEventList* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.descriptors_){from._impl_.descriptors_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CSVCMsg_GameEventList)
}

inline void CSVCMsg_GameEventList::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.descriptors_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CSVCMsg_GameEventList::~CSVCMsg_GameEventList() {
  // @@protoc_insertion_point(destructor:CSVCMsg_GameEventList)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CSVCMsg_GameEventList::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.descriptors_.~RepeatedPtrField();
}

void CSVCMsg_GameEventList::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CSVCMsg_GameEventList::Clear() {
// @@protoc_insertion_point(message_clear_start:CSVCMsg_GameEventList)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.descriptors_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSVCMsg_GameEventList::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .CSVCMsg_GameEventList.descriptor_t descriptors = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_descriptors(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSVCMsg_GameEventList::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CSVCMsg_GameEventList)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .CSVCMsg_GameEventList.descriptor_t descriptors = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_descriptors_size()); i < n; i++) {
    const auto& repfield = this->_internal_descriptors(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CSVCMsg_GameEventList)
  return target;
}

size_t CSVCMsg_GameEventList::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CSVCMsg_GameEventList)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CSVCMsg_GameEventList.descriptor_t descriptors = 1;
  total_size += 1UL * this->_internal_descriptors_size();
  for (const auto& msg : this->_impl_.descriptors_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSVCMsg_GameEventList::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CSVCMsg_GameEventList::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSVCMsg_GameEventList::GetClassData() const { return &_class_data_; }


void CSVCMsg_GameEventList::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CSVCMsg_GameEventList*>(&to_msg);
  auto& from = static_cast<const CSVCMsg_GameEventList&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CSVCMsg_GameEventList)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.descriptors_.MergeFrom(from._impl_.descriptors_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSVCMsg_GameEventList::CopyFrom(const CSVCMsg_GameEventList& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CSVCMsg_GameEventList)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSVCMsg_GameEventList::IsInitialized() const {
  return true;
}

void CSVCMsg_GameEventList::InternalSwap(CSVCMsg_GameEventList* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.descriptors_.InternalSwap(&other->_impl_.descriptors_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CSVCMsg_GameEventList::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[37]);
}

// ===================================================================

class CSVCMsg_PacketEntities_command_queue_info_t::_Internal {
 public:
  using HasBits = decltype(std::declval<CSVCMsg_PacketEntities_command_queue_info_t>()._impl_._has_bits_);
  static void set_has_commands_queued(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_command_queue_desired_size(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_starved_command_ticks(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_time_dilation_percent(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_discarded_command_ticks(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

CSVCMsg_PacketEntities_command_queue_info_t::CSVCMsg_PacketEntities_command_queue_info_t(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CSVCMsg_PacketEntities.command_queue_info_t)
}
CSVCMsg_PacketEntities_command_queue_info_t::CSVCMsg_PacketEntities_command_queue_info_t(const CSVCMsg_PacketEntities_command_queue_info_t& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CSVCMsg_PacketEntities_command_queue_info_t* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.commands_queued_){}
    , decltype(_impl_.command_queue_desired_size_){}
    , decltype(_impl_.starved_command_ticks_){}
    , decltype(_impl_.time_dilation_percent_){}
    , decltype(_impl_.discarded_command_ticks_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.commands_queued_, &from._impl_.commands_queued_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.discarded_command_ticks_) -
    reinterpret_cast<char*>(&_impl_.commands_queued_)) + sizeof(_impl_.discarded_command_ticks_));
  // @@protoc_insertion_point(copy_constructor:CSVCMsg_PacketEntities.command_queue_info_t)
}

inline void CSVCMsg_PacketEntities_command_queue_info_t::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.commands_queued_){0u}
    , decltype(_impl_.command_queue_desired_size_){0u}
    , decltype(_impl_.starved_command_ticks_){0u}
    , decltype(_impl_.time_dilation_percent_){0}
    , decltype(_impl_.discarded_command_ticks_){0u}
  };
}

CSVCMsg_PacketEntities_command_queue_info_t::~CSVCMsg_PacketEntities_command_queue_info_t() {
  // @@protoc_insertion_point(destructor:CSVCMsg_PacketEntities.command_queue_info_t)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CSVCMsg_PacketEntities_command_queue_info_t::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CSVCMsg_PacketEntities_command_queue_info_t::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CSVCMsg_PacketEntities_command_queue_info_t::Clear() {
// @@protoc_insertion_point(message_clear_start:CSVCMsg_PacketEntities.command_queue_info_t)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&_impl_.commands_queued_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.discarded_command_ticks_) -
        reinterpret_cast<char*>(&_impl_.commands_queued_)) + sizeof(_impl_.discarded_command_ticks_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSVCMsg_PacketEntities_command_queue_info_t::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 commands_queued = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_commands_queued(&has_bits);
          _impl_.commands_queued_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 command_queue_desired_size = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_command_queue_desired_size(&has_bits);
          _impl_.command_queue_desired_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 starved_command_ticks = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_starved_command_ticks(&has_bits);
          _impl_.starved_command_ticks_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float time_dilation_percent = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          _Internal::set_has_time_dilation_percent(&has_bits);
          _impl_.time_dilation_percent_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 discarded_command_ticks = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_discarded_command_ticks(&has_bits);
          _impl_.discarded_command_ticks_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSVCMsg_PacketEntities_command_queue_info_t::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CSVCMsg_PacketEntities.command_queue_info_t)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 commands_queued = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_commands_queued(), target);
  }

  // optional uint32 command_queue_desired_size = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_command_queue_desired_size(), target);
  }

  // optional uint32 starved_command_ticks = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_starved_command_ticks(), target);
  }

  // optional float time_dilation_percent = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(4, this->_internal_time_dilation_percent(), target);
  }

  // optional uint32 discarded_command_ticks = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_discarded_command_ticks(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CSVCMsg_PacketEntities.command_queue_info_t)
  return target;
}

size_t CSVCMsg_PacketEntities_command_queue_info_t::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CSVCMsg_PacketEntities.command_queue_info_t)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional uint32 commands_queued = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_commands_queued());
    }

    // optional uint32 command_queue_desired_size = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_command_queue_desired_size());
    }

    // optional uint32 starved_command_ticks = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_starved_command_ticks());
    }

    // optional float time_dilation_percent = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 4;
    }

    // optional uint32 discarded_command_ticks = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_discarded_command_ticks());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSVCMsg_PacketEntities_command_queue_info_t::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CSVCMsg_PacketEntities_command_queue_info_t::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSVCMsg_PacketEntities_command_queue_info_t::GetClassData() const { return &_class_data_; }


void CSVCMsg_PacketEntities_command_queue_info_t::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CSVCMsg_PacketEntities_command_queue_info_t*>(&to_msg);
  auto& from = static_cast<const CSVCMsg_PacketEntities_command_queue_info_t&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CSVCMsg_PacketEntities.command_queue_info_t)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.commands_queued_ = from._impl_.commands_queued_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.command_queue_desired_size_ = from._impl_.command_queue_desired_size_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.starved_command_ticks_ = from._impl_.starved_command_ticks_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.time_dilation_percent_ = from._impl_.time_dilation_percent_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.discarded_command_ticks_ = from._impl_.discarded_command_ticks_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSVCMsg_PacketEntities_command_queue_info_t::CopyFrom(const CSVCMsg_PacketEntities_command_queue_info_t& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CSVCMsg_PacketEntities.command_queue_info_t)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSVCMsg_PacketEntities_command_queue_info_t::IsInitialized() const {
  return true;
}

void CSVCMsg_PacketEntities_command_queue_info_t::InternalSwap(CSVCMsg_PacketEntities_command_queue_info_t* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CSVCMsg_PacketEntities_command_queue_info_t, _impl_.discarded_command_ticks_)
      + sizeof(CSVCMsg_PacketEntities_command_queue_info_t::_impl_.discarded_command_ticks_)
      - PROTOBUF_FIELD_OFFSET(CSVCMsg_PacketEntities_command_queue_info_t, _impl_.commands_queued_)>(
          reinterpret_cast<char*>(&_impl_.commands_queued_),
          reinterpret_cast<char*>(&other->_impl_.commands_queued_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CSVCMsg_PacketEntities_command_queue_info_t::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[38]);
}

// ===================================================================

class CSVCMsg_PacketEntities_alternate_baseline_t::_Internal {
 public:
  using HasBits = decltype(std::declval<CSVCMsg_PacketEntities_alternate_baseline_t>()._impl_._has_bits_);
  static void set_has_entity_index(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_baseline_index(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CSVCMsg_PacketEntities_alternate_baseline_t::CSVCMsg_PacketEntities_alternate_baseline_t(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CSVCMsg_PacketEntities.alternate_baseline_t)
}
CSVCMsg_PacketEntities_alternate_baseline_t::CSVCMsg_PacketEntities_alternate_baseline_t(const CSVCMsg_PacketEntities_alternate_baseline_t& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CSVCMsg_PacketEntities_alternate_baseline_t* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.entity_index_){}
    , decltype(_impl_.baseline_index_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.entity_index_, &from._impl_.entity_index_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.baseline_index_) -
    reinterpret_cast<char*>(&_impl_.entity_index_)) + sizeof(_impl_.baseline_index_));
  // @@protoc_insertion_point(copy_constructor:CSVCMsg_PacketEntities.alternate_baseline_t)
}

inline void CSVCMsg_PacketEntities_alternate_baseline_t::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.entity_index_){0}
    , decltype(_impl_.baseline_index_){0}
  };
}

CSVCMsg_PacketEntities_alternate_baseline_t::~CSVCMsg_PacketEntities_alternate_baseline_t() {
  // @@protoc_insertion_point(destructor:CSVCMsg_PacketEntities.alternate_baseline_t)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CSVCMsg_PacketEntities_alternate_baseline_t::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CSVCMsg_PacketEntities_alternate_baseline_t::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CSVCMsg_PacketEntities_alternate_baseline_t::Clear() {
// @@protoc_insertion_point(message_clear_start:CSVCMsg_PacketEntities.alternate_baseline_t)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.entity_index_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.baseline_index_) -
        reinterpret_cast<char*>(&_impl_.entity_index_)) + sizeof(_impl_.baseline_index_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSVCMsg_PacketEntities_alternate_baseline_t::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 entity_index = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_entity_index(&has_bits);
          _impl_.entity_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 baseline_index = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_baseline_index(&has_bits);
          _impl_.baseline_index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSVCMsg_PacketEntities_alternate_baseline_t::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CSVCMsg_PacketEntities.alternate_baseline_t)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 entity_index = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_entity_index(), target);
  }

  // optional int32 baseline_index = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_baseline_index(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CSVCMsg_PacketEntities.alternate_baseline_t)
  return target;
}

size_t CSVCMsg_PacketEntities_alternate_baseline_t::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CSVCMsg_PacketEntities.alternate_baseline_t)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional int32 entity_index = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_entity_index());
    }

    // optional int32 baseline_index = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_baseline_index());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSVCMsg_PacketEntities_alternate_baseline_t::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CSVCMsg_PacketEntities_alternate_baseline_t::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSVCMsg_PacketEntities_alternate_baseline_t::GetClassData() const { return &_class_data_; }


void CSVCMsg_PacketEntities_alternate_baseline_t::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CSVCMsg_PacketEntities_alternate_baseline_t*>(&to_msg);
  auto& from = static_cast<const CSVCMsg_PacketEntities_alternate_baseline_t&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CSVCMsg_PacketEntities.alternate_baseline_t)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.entity_index_ = from._impl_.entity_index_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.baseline_index_ = from._impl_.baseline_index_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSVCMsg_PacketEntities_alternate_baseline_t::CopyFrom(const CSVCMsg_PacketEntities_alternate_baseline_t& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CSVCMsg_PacketEntities.alternate_baseline_t)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSVCMsg_PacketEntities_alternate_baseline_t::IsInitialized() const {
  return true;
}

void CSVCMsg_PacketEntities_alternate_baseline_t::InternalSwap(CSVCMsg_PacketEntities_alternate_baseline_t* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CSVCMsg_PacketEntities_alternate_baseline_t, _impl_.baseline_index_)
      + sizeof(CSVCMsg_PacketEntities_alternate_baseline_t::_impl_.baseline_index_)
      - PROTOBUF_FIELD_OFFSET(CSVCMsg_PacketEntities_alternate_baseline_t, _impl_.entity_index_)>(
          reinterpret_cast<char*>(&_impl_.entity_index_),
          reinterpret_cast<char*>(&other->_impl_.entity_index_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CSVCMsg_PacketEntities_alternate_baseline_t::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[39]);
}

// ===================================================================

class CSVCMsg_PacketEntities_non_transmitted_entities_t::_Internal {
 public:
  using HasBits = decltype(std::declval<CSVCMsg_PacketEntities_non_transmitted_entities_t>()._impl_._has_bits_);
  static void set_has_header_count(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CSVCMsg_PacketEntities_non_transmitted_entities_t::CSVCMsg_PacketEntities_non_transmitted_entities_t(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CSVCMsg_PacketEntities.non_transmitted_entities_t)
}
CSVCMsg_PacketEntities_non_transmitted_entities_t::CSVCMsg_PacketEntities_non_transmitted_entities_t(const CSVCMsg_PacketEntities_non_transmitted_entities_t& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CSVCMsg_PacketEntities_non_transmitted_entities_t* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.data_){}
    , decltype(_impl_.header_count_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_data()) {
    _this->_impl_.data_.Set(from._internal_data(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.header_count_ = from._impl_.header_count_;
  // @@protoc_insertion_point(copy_constructor:CSVCMsg_PacketEntities.non_transmitted_entities_t)
}

inline void CSVCMsg_PacketEntities_non_transmitted_entities_t::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.data_){}
    , decltype(_impl_.header_count_){0}
  };
  _impl_.data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CSVCMsg_PacketEntities_non_transmitted_entities_t::~CSVCMsg_PacketEntities_non_transmitted_entities_t() {
  // @@protoc_insertion_point(destructor:CSVCMsg_PacketEntities.non_transmitted_entities_t)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CSVCMsg_PacketEntities_non_transmitted_entities_t::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.data_.Destroy();
}

void CSVCMsg_PacketEntities_non_transmitted_entities_t::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CSVCMsg_PacketEntities_non_transmitted_entities_t::Clear() {
// @@protoc_insertion_point(message_clear_start:CSVCMsg_PacketEntities.non_transmitted_entities_t)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.data_.ClearNonDefaultToEmpty();
  }
  _impl_.header_count_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSVCMsg_PacketEntities_non_transmitted_entities_t::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 header_count = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_header_count(&has_bits);
          _impl_.header_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes data = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSVCMsg_PacketEntities_non_transmitted_entities_t::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CSVCMsg_PacketEntities.non_transmitted_entities_t)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 header_count = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_header_count(), target);
  }

  // optional bytes data = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_data(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CSVCMsg_PacketEntities.non_transmitted_entities_t)
  return target;
}

size_t CSVCMsg_PacketEntities_non_transmitted_entities_t::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CSVCMsg_PacketEntities.non_transmitted_entities_t)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bytes data = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_data());
    }

    // optional int32 header_count = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_header_count());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSVCMsg_PacketEntities_non_transmitted_entities_t::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CSVCMsg_PacketEntities_non_transmitted_entities_t::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSVCMsg_PacketEntities_non_transmitted_entities_t::GetClassData() const { return &_class_data_; }


void CSVCMsg_PacketEntities_non_transmitted_entities_t::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CSVCMsg_PacketEntities_non_transmitted_entities_t*>(&to_msg);
  auto& from = static_cast<const CSVCMsg_PacketEntities_non_transmitted_entities_t&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CSVCMsg_PacketEntities.non_transmitted_entities_t)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_data(from._internal_data());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.header_count_ = from._impl_.header_count_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSVCMsg_PacketEntities_non_transmitted_entities_t::CopyFrom(const CSVCMsg_PacketEntities_non_transmitted_entities_t& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CSVCMsg_PacketEntities.non_transmitted_entities_t)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSVCMsg_PacketEntities_non_transmitted_entities_t::IsInitialized() const {
  return true;
}

void CSVCMsg_PacketEntities_non_transmitted_entities_t::InternalSwap(CSVCMsg_PacketEntities_non_transmitted_entities_t* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.data_, lhs_arena,
      &other->_impl_.data_, rhs_arena
  );
  swap(_impl_.header_count_, other->_impl_.header_count_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CSVCMsg_PacketEntities_non_transmitted_entities_t::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[40]);
}

// ===================================================================

class CSVCMsg_PacketEntities::_Internal {
 public:
  using HasBits = decltype(std::declval<CSVCMsg_PacketEntities>()._impl_._has_bits_);
  static void set_has_max_entries(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_updated_entries(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_legacy_is_delta(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_update_baseline(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_baseline(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_delta_from(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_entity_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_pending_full_frame(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_active_spawngroup_handle(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_max_spawngroup_creationsequence(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_last_cmd_number_executed(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_last_cmd_number_recv_delta(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
  static void set_has_server_tick(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_serialized_entities(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::CSVCMsg_PacketEntities_command_queue_info_t& command_queue_info(const CSVCMsg_PacketEntities* msg);
  static void set_has_command_queue_info(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_has_pvs_vis_bits(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static void set_has_last_cmd_recv_margin(HasBits* has_bits) {
    (*has_bits)[0] |= 262144u;
  }
  static const ::CSVCMsg_PacketEntities_non_transmitted_entities_t& non_transmitted_entities(const CSVCMsg_PacketEntities* msg);
  static void set_has_non_transmitted_entities(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_dev_padding(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::CSVCMsg_PacketEntities_command_queue_info_t&
CSVCMsg_PacketEntities::_Internal::command_queue_info(const CSVCMsg_PacketEntities* msg) {
  return *msg->_impl_.command_queue_info_;
}
const ::CSVCMsg_PacketEntities_non_transmitted_entities_t&
CSVCMsg_PacketEntities::_Internal::non_transmitted_entities(const CSVCMsg_PacketEntities* msg) {
  return *msg->_impl_.non_transmitted_entities_;
}
CSVCMsg_PacketEntities::CSVCMsg_PacketEntities(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CSVCMsg_PacketEntities)
}
CSVCMsg_PacketEntities::CSVCMsg_PacketEntities(const CSVCMsg_PacketEntities& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CSVCMsg_PacketEntities* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.alternate_baselines_){from._impl_.alternate_baselines_}
    , decltype(_impl_.entity_data_){}
    , decltype(_impl_.serialized_entities_){}
    , decltype(_impl_.dev_padding_){}
    , decltype(_impl_.command_queue_info_){nullptr}
    , decltype(_impl_.non_transmitted_entities_){nullptr}
    , decltype(_impl_.max_entries_){}
    , decltype(_impl_.updated_entries_){}
    , decltype(_impl_.baseline_){}
    , decltype(_impl_.legacy_is_delta_){}
    , decltype(_impl_.update_baseline_){}
    , decltype(_impl_.pending_full_frame_){}
    , decltype(_impl_.delta_from_){}
    , decltype(_impl_.active_spawngroup_handle_){}
    , decltype(_impl_.max_spawngroup_creationsequence_){}
    , decltype(_impl_.last_cmd_number_executed_){}
    , decltype(_impl_.server_tick_){}
    , decltype(_impl_.has_pvs_vis_bits_){}
    , decltype(_impl_.last_cmd_number_recv_delta_){}
    , decltype(_impl_.last_cmd_recv_margin_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.entity_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.entity_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_entity_data()) {
    _this->_impl_.entity_data_.Set(from._internal_entity_data(), 
      _this->GetArenaForAllocation());
  }
  _impl_.serialized_entities_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.serialized_entities_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_serialized_entities()) {
    _this->_impl_.serialized_entities_.Set(from._internal_serialized_entities(), 
      _this->GetArenaForAllocation());
  }
  _impl_.dev_padding_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.dev_padding_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_dev_padding()) {
    _this->_impl_.dev_padding_.Set(from._internal_dev_padding(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_command_queue_info()) {
    _this->_impl_.command_queue_info_ = new ::CSVCMsg_PacketEntities_command_queue_info_t(*from._impl_.command_queue_info_);
  }
  if (from._internal_has_non_transmitted_entities()) {
    _this->_impl_.non_transmitted_entities_ = new ::CSVCMsg_PacketEntities_non_transmitted_entities_t(*from._impl_.non_transmitted_entities_);
  }
  ::memcpy(&_impl_.max_entries_, &from._impl_.max_entries_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.last_cmd_recv_margin_) -
    reinterpret_cast<char*>(&_impl_.max_entries_)) + sizeof(_impl_.last_cmd_recv_margin_));
  // @@protoc_insertion_point(copy_constructor:CSVCMsg_PacketEntities)
}

inline void CSVCMsg_PacketEntities::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.alternate_baselines_){arena}
    , decltype(_impl_.entity_data_){}
    , decltype(_impl_.serialized_entities_){}
    , decltype(_impl_.dev_padding_){}
    , decltype(_impl_.command_queue_info_){nullptr}
    , decltype(_impl_.non_transmitted_entities_){nullptr}
    , decltype(_impl_.max_entries_){0}
    , decltype(_impl_.updated_entries_){0}
    , decltype(_impl_.baseline_){0}
    , decltype(_impl_.legacy_is_delta_){false}
    , decltype(_impl_.update_baseline_){false}
    , decltype(_impl_.pending_full_frame_){false}
    , decltype(_impl_.delta_from_){0}
    , decltype(_impl_.active_spawngroup_handle_){0u}
    , decltype(_impl_.max_spawngroup_creationsequence_){0u}
    , decltype(_impl_.last_cmd_number_executed_){0u}
    , decltype(_impl_.server_tick_){0u}
    , decltype(_impl_.has_pvs_vis_bits_){0u}
    , decltype(_impl_.last_cmd_number_recv_delta_){0}
    , decltype(_impl_.last_cmd_recv_margin_){0u}
  };
  _impl_.entity_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.entity_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.serialized_entities_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.serialized_entities_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.dev_padding_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.dev_padding_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CSVCMsg_PacketEntities::~CSVCMsg_PacketEntities() {
  // @@protoc_insertion_point(destructor:CSVCMsg_PacketEntities)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CSVCMsg_PacketEntities::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.alternate_baselines_.~RepeatedPtrField();
  _impl_.entity_data_.Destroy();
  _impl_.serialized_entities_.Destroy();
  _impl_.dev_padding_.Destroy();
  if (this != internal_default_instance()) delete _impl_.command_queue_info_;
  if (this != internal_default_instance()) delete _impl_.non_transmitted_entities_;
}

void CSVCMsg_PacketEntities::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CSVCMsg_PacketEntities::Clear() {
// @@protoc_insertion_point(message_clear_start:CSVCMsg_PacketEntities)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.alternate_baselines_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.entity_data_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.serialized_entities_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000004u) {
      _impl_.dev_padding_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.command_queue_info_ != nullptr);
      _impl_.command_queue_info_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.non_transmitted_entities_ != nullptr);
      _impl_.non_transmitted_entities_->Clear();
    }
  }
  if (cached_has_bits & 0x000000e0u) {
    ::memset(&_impl_.max_entries_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.baseline_) -
        reinterpret_cast<char*>(&_impl_.max_entries_)) + sizeof(_impl_.baseline_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&_impl_.legacy_is_delta_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.server_tick_) -
        reinterpret_cast<char*>(&_impl_.legacy_is_delta_)) + sizeof(_impl_.server_tick_));
  }
  if (cached_has_bits & 0x00070000u) {
    ::memset(&_impl_.has_pvs_vis_bits_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.last_cmd_recv_margin_) -
        reinterpret_cast<char*>(&_impl_.has_pvs_vis_bits_)) + sizeof(_impl_.last_cmd_recv_margin_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSVCMsg_PacketEntities::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 max_entries = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_max_entries(&has_bits);
          _impl_.max_entries_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 updated_entries = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_updated_entries(&has_bits);
          _impl_.updated_entries_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool legacy_is_delta = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_legacy_is_delta(&has_bits);
          _impl_.legacy_is_delta_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool update_baseline = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_update_baseline(&has_bits);
          _impl_.update_baseline_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 baseline = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_baseline(&has_bits);
          _impl_.baseline_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 delta_from = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_delta_from(&has_bits);
          _impl_.delta_from_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes entity_data = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_entity_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool pending_full_frame = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_pending_full_frame(&has_bits);
          _impl_.pending_full_frame_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 active_spawngroup_handle = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_active_spawngroup_handle(&has_bits);
          _impl_.active_spawngroup_handle_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 max_spawngroup_creationsequence = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_max_spawngroup_creationsequence(&has_bits);
          _impl_.max_spawngroup_creationsequence_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 last_cmd_number_executed = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_last_cmd_number_executed(&has_bits);
          _impl_.last_cmd_number_executed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 server_tick = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_server_tick(&has_bits);
          _impl_.server_tick_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes serialized_entities = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 106)) {
          auto str = _internal_mutable_serialized_entities();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CSVCMsg_PacketEntities.command_queue_info_t command_queue_info = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 114)) {
          ptr = ctx->ParseMessage(_internal_mutable_command_queue_info(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .CSVCMsg_PacketEntities.alternate_baseline_t alternate_baselines = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 122)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_alternate_baselines(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<122>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional uint32 has_pvs_vis_bits = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
          _Internal::set_has_has_pvs_vis_bits(&has_bits);
          _impl_.has_pvs_vis_bits_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional sint32 last_cmd_number_recv_delta = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 136)) {
          _Internal::set_has_last_cmd_number_recv_delta(&has_bits);
          _impl_.last_cmd_number_recv_delta_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 last_cmd_recv_margin = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 144)) {
          _Internal::set_has_last_cmd_recv_margin(&has_bits);
          _impl_.last_cmd_recv_margin_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CSVCMsg_PacketEntities.non_transmitted_entities_t non_transmitted_entities = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 154)) {
          ptr = ctx->ParseMessage(_internal_mutable_non_transmitted_entities(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes dev_padding = 999;
      case 999:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_dev_padding();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSVCMsg_PacketEntities::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CSVCMsg_PacketEntities)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 max_entries = 1;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_max_entries(), target);
  }

  // optional int32 updated_entries = 2;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_updated_entries(), target);
  }

  // optional bool legacy_is_delta = 3;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_legacy_is_delta(), target);
  }

  // optional bool update_baseline = 4;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_update_baseline(), target);
  }

  // optional int32 baseline = 5;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_baseline(), target);
  }

  // optional int32 delta_from = 6;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(6, this->_internal_delta_from(), target);
  }

  // optional bytes entity_data = 7;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        7, this->_internal_entity_data(), target);
  }

  // optional bool pending_full_frame = 8;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(8, this->_internal_pending_full_frame(), target);
  }

  // optional uint32 active_spawngroup_handle = 9;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(9, this->_internal_active_spawngroup_handle(), target);
  }

  // optional uint32 max_spawngroup_creationsequence = 10;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(10, this->_internal_max_spawngroup_creationsequence(), target);
  }

  // optional uint32 last_cmd_number_executed = 11;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(11, this->_internal_last_cmd_number_executed(), target);
  }

  // optional uint32 server_tick = 12;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(12, this->_internal_server_tick(), target);
  }

  // optional bytes serialized_entities = 13;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        13, this->_internal_serialized_entities(), target);
  }

  // optional .CSVCMsg_PacketEntities.command_queue_info_t command_queue_info = 14;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(14, _Internal::command_queue_info(this),
        _Internal::command_queue_info(this).GetCachedSize(), target, stream);
  }

  // repeated .CSVCMsg_PacketEntities.alternate_baseline_t alternate_baselines = 15;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_alternate_baselines_size()); i < n; i++) {
    const auto& repfield = this->_internal_alternate_baselines(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(15, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional uint32 has_pvs_vis_bits = 16;
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(16, this->_internal_has_pvs_vis_bits(), target);
  }

  // optional sint32 last_cmd_number_recv_delta = 17;
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteSInt32ToArray(17, this->_internal_last_cmd_number_recv_delta(), target);
  }

  // optional uint32 last_cmd_recv_margin = 18;
  if (cached_has_bits & 0x00040000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(18, this->_internal_last_cmd_recv_margin(), target);
  }

  // optional .CSVCMsg_PacketEntities.non_transmitted_entities_t non_transmitted_entities = 19;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(19, _Internal::non_transmitted_entities(this),
        _Internal::non_transmitted_entities(this).GetCachedSize(), target, stream);
  }

  // optional bytes dev_padding = 999;
  if (cached_has_bits & 0x00000004u) {
    target = stream->WriteBytesMaybeAliased(
        999, this->_internal_dev_padding(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CSVCMsg_PacketEntities)
  return target;
}

size_t CSVCMsg_PacketEntities::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CSVCMsg_PacketEntities)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CSVCMsg_PacketEntities.alternate_baseline_t alternate_baselines = 15;
  total_size += 1UL * this->_internal_alternate_baselines_size();
  for (const auto& msg : this->_impl_.alternate_baselines_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional bytes entity_data = 7;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_entity_data());
    }

    // optional bytes serialized_entities = 13;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_serialized_entities());
    }

    // optional bytes dev_padding = 999;
    if (cached_has_bits & 0x00000004u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_dev_padding());
    }

    // optional .CSVCMsg_PacketEntities.command_queue_info_t command_queue_info = 14;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.command_queue_info_);
    }

    // optional .CSVCMsg_PacketEntities.non_transmitted_entities_t non_transmitted_entities = 19;
    if (cached_has_bits & 0x00000010u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.non_transmitted_entities_);
    }

    // optional int32 max_entries = 1;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_max_entries());
    }

    // optional int32 updated_entries = 2;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_updated_entries());
    }

    // optional int32 baseline = 5;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_baseline());
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional bool legacy_is_delta = 3;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 1;
    }

    // optional bool update_baseline = 4;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 1;
    }

    // optional bool pending_full_frame = 8;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 + 1;
    }

    // optional int32 delta_from = 6;
    if (cached_has_bits & 0x00000800u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_delta_from());
    }

    // optional uint32 active_spawngroup_handle = 9;
    if (cached_has_bits & 0x00001000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_active_spawngroup_handle());
    }

    // optional uint32 max_spawngroup_creationsequence = 10;
    if (cached_has_bits & 0x00002000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_max_spawngroup_creationsequence());
    }

    // optional uint32 last_cmd_number_executed = 11;
    if (cached_has_bits & 0x00004000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_last_cmd_number_executed());
    }

    // optional uint32 server_tick = 12;
    if (cached_has_bits & 0x00008000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_server_tick());
    }

  }
  if (cached_has_bits & 0x00070000u) {
    // optional uint32 has_pvs_vis_bits = 16;
    if (cached_has_bits & 0x00010000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_has_pvs_vis_bits());
    }

    // optional sint32 last_cmd_number_recv_delta = 17;
    if (cached_has_bits & 0x00020000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::SInt32Size(
          this->_internal_last_cmd_number_recv_delta());
    }

    // optional uint32 last_cmd_recv_margin = 18;
    if (cached_has_bits & 0x00040000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_last_cmd_recv_margin());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSVCMsg_PacketEntities::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CSVCMsg_PacketEntities::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSVCMsg_PacketEntities::GetClassData() const { return &_class_data_; }


void CSVCMsg_PacketEntities::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CSVCMsg_PacketEntities*>(&to_msg);
  auto& from = static_cast<const CSVCMsg_PacketEntities&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CSVCMsg_PacketEntities)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.alternate_baselines_.MergeFrom(from._impl_.alternate_baselines_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_entity_data(from._internal_entity_data());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_serialized_entities(from._internal_serialized_entities());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_set_dev_padding(from._internal_dev_padding());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_command_queue_info()->::CSVCMsg_PacketEntities_command_queue_info_t::MergeFrom(
          from._internal_command_queue_info());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_non_transmitted_entities()->::CSVCMsg_PacketEntities_non_transmitted_entities_t::MergeFrom(
          from._internal_non_transmitted_entities());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.max_entries_ = from._impl_.max_entries_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.updated_entries_ = from._impl_.updated_entries_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.baseline_ = from._impl_.baseline_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.legacy_is_delta_ = from._impl_.legacy_is_delta_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.update_baseline_ = from._impl_.update_baseline_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.pending_full_frame_ = from._impl_.pending_full_frame_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.delta_from_ = from._impl_.delta_from_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.active_spawngroup_handle_ = from._impl_.active_spawngroup_handle_;
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.max_spawngroup_creationsequence_ = from._impl_.max_spawngroup_creationsequence_;
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_impl_.last_cmd_number_executed_ = from._impl_.last_cmd_number_executed_;
    }
    if (cached_has_bits & 0x00008000u) {
      _this->_impl_.server_tick_ = from._impl_.server_tick_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00070000u) {
    if (cached_has_bits & 0x00010000u) {
      _this->_impl_.has_pvs_vis_bits_ = from._impl_.has_pvs_vis_bits_;
    }
    if (cached_has_bits & 0x00020000u) {
      _this->_impl_.last_cmd_number_recv_delta_ = from._impl_.last_cmd_number_recv_delta_;
    }
    if (cached_has_bits & 0x00040000u) {
      _this->_impl_.last_cmd_recv_margin_ = from._impl_.last_cmd_recv_margin_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSVCMsg_PacketEntities::CopyFrom(const CSVCMsg_PacketEntities& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CSVCMsg_PacketEntities)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSVCMsg_PacketEntities::IsInitialized() const {
  return true;
}

void CSVCMsg_PacketEntities::InternalSwap(CSVCMsg_PacketEntities* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.alternate_baselines_.InternalSwap(&other->_impl_.alternate_baselines_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.entity_data_, lhs_arena,
      &other->_impl_.entity_data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.serialized_entities_, lhs_arena,
      &other->_impl_.serialized_entities_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.dev_padding_, lhs_arena,
      &other->_impl_.dev_padding_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CSVCMsg_PacketEntities, _impl_.last_cmd_recv_margin_)
      + sizeof(CSVCMsg_PacketEntities::_impl_.last_cmd_recv_margin_)
      - PROTOBUF_FIELD_OFFSET(CSVCMsg_PacketEntities, _impl_.command_queue_info_)>(
          reinterpret_cast<char*>(&_impl_.command_queue_info_),
          reinterpret_cast<char*>(&other->_impl_.command_queue_info_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CSVCMsg_PacketEntities::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[41]);
}

// ===================================================================

class CSVCMsg_TempEntities::_Internal {
 public:
  using HasBits = decltype(std::declval<CSVCMsg_TempEntities>()._impl_._has_bits_);
  static void set_has_reliable(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_num_entries(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_entity_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CSVCMsg_TempEntities::CSVCMsg_TempEntities(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CSVCMsg_TempEntities)
}
CSVCMsg_TempEntities::CSVCMsg_TempEntities(const CSVCMsg_TempEntities& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CSVCMsg_TempEntities* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.entity_data_){}
    , decltype(_impl_.reliable_){}
    , decltype(_impl_.num_entries_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.entity_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.entity_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_entity_data()) {
    _this->_impl_.entity_data_.Set(from._internal_entity_data(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.reliable_, &from._impl_.reliable_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.num_entries_) -
    reinterpret_cast<char*>(&_impl_.reliable_)) + sizeof(_impl_.num_entries_));
  // @@protoc_insertion_point(copy_constructor:CSVCMsg_TempEntities)
}

inline void CSVCMsg_TempEntities::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.entity_data_){}
    , decltype(_impl_.reliable_){false}
    , decltype(_impl_.num_entries_){0}
  };
  _impl_.entity_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.entity_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CSVCMsg_TempEntities::~CSVCMsg_TempEntities() {
  // @@protoc_insertion_point(destructor:CSVCMsg_TempEntities)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CSVCMsg_TempEntities::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.entity_data_.Destroy();
}

void CSVCMsg_TempEntities::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CSVCMsg_TempEntities::Clear() {
// @@protoc_insertion_point(message_clear_start:CSVCMsg_TempEntities)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.entity_data_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.reliable_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.num_entries_) -
        reinterpret_cast<char*>(&_impl_.reliable_)) + sizeof(_impl_.num_entries_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSVCMsg_TempEntities::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool reliable = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_reliable(&has_bits);
          _impl_.reliable_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 num_entries = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_num_entries(&has_bits);
          _impl_.num_entries_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes entity_data = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_entity_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSVCMsg_TempEntities::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CSVCMsg_TempEntities)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool reliable = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_reliable(), target);
  }

  // optional int32 num_entries = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_num_entries(), target);
  }

  // optional bytes entity_data = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_entity_data(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CSVCMsg_TempEntities)
  return target;
}

size_t CSVCMsg_TempEntities::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CSVCMsg_TempEntities)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional bytes entity_data = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_entity_data());
    }

    // optional bool reliable = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

    // optional int32 num_entries = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_num_entries());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSVCMsg_TempEntities::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CSVCMsg_TempEntities::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSVCMsg_TempEntities::GetClassData() const { return &_class_data_; }


void CSVCMsg_TempEntities::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CSVCMsg_TempEntities*>(&to_msg);
  auto& from = static_cast<const CSVCMsg_TempEntities&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CSVCMsg_TempEntities)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_entity_data(from._internal_entity_data());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.reliable_ = from._impl_.reliable_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.num_entries_ = from._impl_.num_entries_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSVCMsg_TempEntities::CopyFrom(const CSVCMsg_TempEntities& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CSVCMsg_TempEntities)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSVCMsg_TempEntities::IsInitialized() const {
  return true;
}

void CSVCMsg_TempEntities::InternalSwap(CSVCMsg_TempEntities* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.entity_data_, lhs_arena,
      &other->_impl_.entity_data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CSVCMsg_TempEntities, _impl_.num_entries_)
      + sizeof(CSVCMsg_TempEntities::_impl_.num_entries_)
      - PROTOBUF_FIELD_OFFSET(CSVCMsg_TempEntities, _impl_.reliable_)>(
          reinterpret_cast<char*>(&_impl_.reliable_),
          reinterpret_cast<char*>(&other->_impl_.reliable_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CSVCMsg_TempEntities::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[42]);
}

// ===================================================================

class CSVCMsg_CreateStringTable::_Internal {
 public:
  using HasBits = decltype(std::declval<CSVCMsg_CreateStringTable>()._impl_._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_num_entries(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_user_data_fixed_size(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_user_data_size(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_user_data_size_bits(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_string_data(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_uncompressed_size(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_data_compressed(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_using_varint_bitcounts(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
};

CSVCMsg_CreateStringTable::CSVCMsg_CreateStringTable(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CSVCMsg_CreateStringTable)
}
CSVCMsg_CreateStringTable::CSVCMsg_CreateStringTable(const CSVCMsg_CreateStringTable& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CSVCMsg_CreateStringTable* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.string_data_){}
    , decltype(_impl_.num_entries_){}
    , decltype(_impl_.user_data_size_){}
    , decltype(_impl_.user_data_size_bits_){}
    , decltype(_impl_.flags_){}
    , decltype(_impl_.user_data_fixed_size_){}
    , decltype(_impl_.data_compressed_){}
    , decltype(_impl_.using_varint_bitcounts_){}
    , decltype(_impl_.uncompressed_size_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _impl_.string_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.string_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_string_data()) {
    _this->_impl_.string_data_.Set(from._internal_string_data(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.num_entries_, &from._impl_.num_entries_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.uncompressed_size_) -
    reinterpret_cast<char*>(&_impl_.num_entries_)) + sizeof(_impl_.uncompressed_size_));
  // @@protoc_insertion_point(copy_constructor:CSVCMsg_CreateStringTable)
}

inline void CSVCMsg_CreateStringTable::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.string_data_){}
    , decltype(_impl_.num_entries_){0}
    , decltype(_impl_.user_data_size_){0}
    , decltype(_impl_.user_data_size_bits_){0}
    , decltype(_impl_.flags_){0}
    , decltype(_impl_.user_data_fixed_size_){false}
    , decltype(_impl_.data_compressed_){false}
    , decltype(_impl_.using_varint_bitcounts_){false}
    , decltype(_impl_.uncompressed_size_){0}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.string_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.string_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CSVCMsg_CreateStringTable::~CSVCMsg_CreateStringTable() {
  // @@protoc_insertion_point(destructor:CSVCMsg_CreateStringTable)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CSVCMsg_CreateStringTable::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
  _impl_.string_data_.Destroy();
}

void CSVCMsg_CreateStringTable::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CSVCMsg_CreateStringTable::Clear() {
// @@protoc_insertion_point(message_clear_start:CSVCMsg_CreateStringTable)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.string_data_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x000000fcu) {
    ::memset(&_impl_.num_entries_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.data_compressed_) -
        reinterpret_cast<char*>(&_impl_.num_entries_)) + sizeof(_impl_.data_compressed_));
  }
  if (cached_has_bits & 0x00000300u) {
    ::memset(&_impl_.using_varint_bitcounts_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.uncompressed_size_) -
        reinterpret_cast<char*>(&_impl_.using_varint_bitcounts_)) + sizeof(_impl_.uncompressed_size_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSVCMsg_CreateStringTable::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CSVCMsg_CreateStringTable.name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional int32 num_entries = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_num_entries(&has_bits);
          _impl_.num_entries_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool user_data_fixed_size = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_user_data_fixed_size(&has_bits);
          _impl_.user_data_fixed_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 user_data_size = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_user_data_size(&has_bits);
          _impl_.user_data_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 user_data_size_bits = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_user_data_size_bits(&has_bits);
          _impl_.user_data_size_bits_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 flags = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_flags(&has_bits);
          _impl_.flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes string_data = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          auto str = _internal_mutable_string_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 uncompressed_size = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_uncompressed_size(&has_bits);
          _impl_.uncompressed_size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool data_compressed = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_data_compressed(&has_bits);
          _impl_.data_compressed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool using_varint_bitcounts = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_using_varint_bitcounts(&has_bits);
          _impl_.using_varint_bitcounts_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSVCMsg_CreateStringTable::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CSVCMsg_CreateStringTable)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string name = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CSVCMsg_CreateStringTable.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // optional int32 num_entries = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_num_entries(), target);
  }

  // optional bool user_data_fixed_size = 3;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_user_data_fixed_size(), target);
  }

  // optional int32 user_data_size = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_user_data_size(), target);
  }

  // optional int32 user_data_size_bits = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_user_data_size_bits(), target);
  }

  // optional int32 flags = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(6, this->_internal_flags(), target);
  }

  // optional bytes string_data = 7;
  if (cached_has_bits & 0x00000002u) {
    target = stream->WriteBytesMaybeAliased(
        7, this->_internal_string_data(), target);
  }

  // optional int32 uncompressed_size = 8;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(8, this->_internal_uncompressed_size(), target);
  }

  // optional bool data_compressed = 9;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(9, this->_internal_data_compressed(), target);
  }

  // optional bool using_varint_bitcounts = 10;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(10, this->_internal_using_varint_bitcounts(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CSVCMsg_CreateStringTable)
  return target;
}

size_t CSVCMsg_CreateStringTable::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CSVCMsg_CreateStringTable)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string name = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional bytes string_data = 7;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_string_data());
    }

    // optional int32 num_entries = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_num_entries());
    }

    // optional int32 user_data_size = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_user_data_size());
    }

    // optional int32 user_data_size_bits = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_user_data_size_bits());
    }

    // optional int32 flags = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_flags());
    }

    // optional bool user_data_fixed_size = 3;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 1;
    }

    // optional bool data_compressed = 9;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 1;
    }

  }
  if (cached_has_bits & 0x00000300u) {
    // optional bool using_varint_bitcounts = 10;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 1;
    }

    // optional int32 uncompressed_size = 8;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_uncompressed_size());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSVCMsg_CreateStringTable::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CSVCMsg_CreateStringTable::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSVCMsg_CreateStringTable::GetClassData() const { return &_class_data_; }


void CSVCMsg_CreateStringTable::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CSVCMsg_CreateStringTable*>(&to_msg);
  auto& from = static_cast<const CSVCMsg_CreateStringTable&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CSVCMsg_CreateStringTable)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_string_data(from._internal_string_data());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.num_entries_ = from._impl_.num_entries_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.user_data_size_ = from._impl_.user_data_size_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.user_data_size_bits_ = from._impl_.user_data_size_bits_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.flags_ = from._impl_.flags_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.user_data_fixed_size_ = from._impl_.user_data_fixed_size_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.data_compressed_ = from._impl_.data_compressed_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000300u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.using_varint_bitcounts_ = from._impl_.using_varint_bitcounts_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.uncompressed_size_ = from._impl_.uncompressed_size_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSVCMsg_CreateStringTable::CopyFrom(const CSVCMsg_CreateStringTable& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CSVCMsg_CreateStringTable)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSVCMsg_CreateStringTable::IsInitialized() const {
  return true;
}

void CSVCMsg_CreateStringTable::InternalSwap(CSVCMsg_CreateStringTable* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.string_data_, lhs_arena,
      &other->_impl_.string_data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CSVCMsg_CreateStringTable, _impl_.uncompressed_size_)
      + sizeof(CSVCMsg_CreateStringTable::_impl_.uncompressed_size_)
      - PROTOBUF_FIELD_OFFSET(CSVCMsg_CreateStringTable, _impl_.num_entries_)>(
          reinterpret_cast<char*>(&_impl_.num_entries_),
          reinterpret_cast<char*>(&other->_impl_.num_entries_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CSVCMsg_CreateStringTable::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[43]);
}

// ===================================================================

class CSVCMsg_UpdateStringTable::_Internal {
 public:
  using HasBits = decltype(std::declval<CSVCMsg_UpdateStringTable>()._impl_._has_bits_);
  static void set_has_table_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_num_changed_entries(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_string_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CSVCMsg_UpdateStringTable::CSVCMsg_UpdateStringTable(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CSVCMsg_UpdateStringTable)
}
CSVCMsg_UpdateStringTable::CSVCMsg_UpdateStringTable(const CSVCMsg_UpdateStringTable& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CSVCMsg_UpdateStringTable* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.string_data_){}
    , decltype(_impl_.table_id_){}
    , decltype(_impl_.num_changed_entries_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.string_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.string_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_string_data()) {
    _this->_impl_.string_data_.Set(from._internal_string_data(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.table_id_, &from._impl_.table_id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.num_changed_entries_) -
    reinterpret_cast<char*>(&_impl_.table_id_)) + sizeof(_impl_.num_changed_entries_));
  // @@protoc_insertion_point(copy_constructor:CSVCMsg_UpdateStringTable)
}

inline void CSVCMsg_UpdateStringTable::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.string_data_){}
    , decltype(_impl_.table_id_){0}
    , decltype(_impl_.num_changed_entries_){0}
  };
  _impl_.string_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.string_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CSVCMsg_UpdateStringTable::~CSVCMsg_UpdateStringTable() {
  // @@protoc_insertion_point(destructor:CSVCMsg_UpdateStringTable)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CSVCMsg_UpdateStringTable::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.string_data_.Destroy();
}

void CSVCMsg_UpdateStringTable::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CSVCMsg_UpdateStringTable::Clear() {
// @@protoc_insertion_point(message_clear_start:CSVCMsg_UpdateStringTable)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.string_data_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.table_id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.num_changed_entries_) -
        reinterpret_cast<char*>(&_impl_.table_id_)) + sizeof(_impl_.num_changed_entries_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSVCMsg_UpdateStringTable::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 table_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_table_id(&has_bits);
          _impl_.table_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 num_changed_entries = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_num_changed_entries(&has_bits);
          _impl_.num_changed_entries_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes string_data = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_string_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSVCMsg_UpdateStringTable::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CSVCMsg_UpdateStringTable)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 table_id = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_table_id(), target);
  }

  // optional int32 num_changed_entries = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_num_changed_entries(), target);
  }

  // optional bytes string_data = 3;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        3, this->_internal_string_data(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CSVCMsg_UpdateStringTable)
  return target;
}

size_t CSVCMsg_UpdateStringTable::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CSVCMsg_UpdateStringTable)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional bytes string_data = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_string_data());
    }

    // optional int32 table_id = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_table_id());
    }

    // optional int32 num_changed_entries = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_num_changed_entries());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSVCMsg_UpdateStringTable::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CSVCMsg_UpdateStringTable::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSVCMsg_UpdateStringTable::GetClassData() const { return &_class_data_; }


void CSVCMsg_UpdateStringTable::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CSVCMsg_UpdateStringTable*>(&to_msg);
  auto& from = static_cast<const CSVCMsg_UpdateStringTable&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CSVCMsg_UpdateStringTable)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_string_data(from._internal_string_data());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.table_id_ = from._impl_.table_id_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.num_changed_entries_ = from._impl_.num_changed_entries_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSVCMsg_UpdateStringTable::CopyFrom(const CSVCMsg_UpdateStringTable& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CSVCMsg_UpdateStringTable)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSVCMsg_UpdateStringTable::IsInitialized() const {
  return true;
}

void CSVCMsg_UpdateStringTable::InternalSwap(CSVCMsg_UpdateStringTable* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.string_data_, lhs_arena,
      &other->_impl_.string_data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CSVCMsg_UpdateStringTable, _impl_.num_changed_entries_)
      + sizeof(CSVCMsg_UpdateStringTable::_impl_.num_changed_entries_)
      - PROTOBUF_FIELD_OFFSET(CSVCMsg_UpdateStringTable, _impl_.table_id_)>(
          reinterpret_cast<char*>(&_impl_.table_id_),
          reinterpret_cast<char*>(&other->_impl_.table_id_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CSVCMsg_UpdateStringTable::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[44]);
}

// ===================================================================

class CSVCMsg_VoiceData::_Internal {
 public:
  using HasBits = decltype(std::declval<CSVCMsg_VoiceData>()._impl_._has_bits_);
  static const ::CMsgVoiceAudio& audio(const CSVCMsg_VoiceData* msg);
  static void set_has_audio(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_client(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_proximity(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_xuid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_audible_mask(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_tick(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_passthrough(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
};

const ::CMsgVoiceAudio&
CSVCMsg_VoiceData::_Internal::audio(const CSVCMsg_VoiceData* msg) {
  return *msg->_impl_.audio_;
}
CSVCMsg_VoiceData::CSVCMsg_VoiceData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CSVCMsg_VoiceData)
}
CSVCMsg_VoiceData::CSVCMsg_VoiceData(const CSVCMsg_VoiceData& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CSVCMsg_VoiceData* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.audio_){nullptr}
    , decltype(_impl_.xuid_){}
    , decltype(_impl_.proximity_){}
    , decltype(_impl_.audible_mask_){}
    , decltype(_impl_.tick_){}
    , decltype(_impl_.passthrough_){}
    , decltype(_impl_.client_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_audio()) {
    _this->_impl_.audio_ = new ::CMsgVoiceAudio(*from._impl_.audio_);
  }
  ::memcpy(&_impl_.xuid_, &from._impl_.xuid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.client_) -
    reinterpret_cast<char*>(&_impl_.xuid_)) + sizeof(_impl_.client_));
  // @@protoc_insertion_point(copy_constructor:CSVCMsg_VoiceData)
}

inline void CSVCMsg_VoiceData::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.audio_){nullptr}
    , decltype(_impl_.xuid_){uint64_t{0u}}
    , decltype(_impl_.proximity_){false}
    , decltype(_impl_.audible_mask_){0}
    , decltype(_impl_.tick_){0u}
    , decltype(_impl_.passthrough_){0}
    , decltype(_impl_.client_){-1}
  };
}

CSVCMsg_VoiceData::~CSVCMsg_VoiceData() {
  // @@protoc_insertion_point(destructor:CSVCMsg_VoiceData)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CSVCMsg_VoiceData::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.audio_;
}

void CSVCMsg_VoiceData::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CSVCMsg_VoiceData::Clear() {
// @@protoc_insertion_point(message_clear_start:CSVCMsg_VoiceData)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.audio_ != nullptr);
    _impl_.audio_->Clear();
  }
  if (cached_has_bits & 0x0000007eu) {
    ::memset(&_impl_.xuid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.passthrough_) -
        reinterpret_cast<char*>(&_impl_.xuid_)) + sizeof(_impl_.passthrough_));
    _impl_.client_ = -1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSVCMsg_VoiceData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .CMsgVoiceAudio audio = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_audio(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 client = 2 [default = -1];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_client(&has_bits);
          _impl_.client_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool proximity = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_proximity(&has_bits);
          _impl_.proximity_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional fixed64 xuid = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 33)) {
          _Internal::set_has_xuid(&has_bits);
          _impl_.xuid_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // optional int32 audible_mask = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_audible_mask(&has_bits);
          _impl_.audible_mask_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 tick = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_tick(&has_bits);
          _impl_.tick_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 passthrough = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_passthrough(&has_bits);
          _impl_.passthrough_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSVCMsg_VoiceData::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CSVCMsg_VoiceData)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .CMsgVoiceAudio audio = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::audio(this),
        _Internal::audio(this).GetCachedSize(), target, stream);
  }

  // optional int32 client = 2 [default = -1];
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_client(), target);
  }

  // optional bool proximity = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_proximity(), target);
  }

  // optional fixed64 xuid = 4;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(4, this->_internal_xuid(), target);
  }

  // optional int32 audible_mask = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_audible_mask(), target);
  }

  // optional uint32 tick = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_tick(), target);
  }

  // optional int32 passthrough = 7;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(7, this->_internal_passthrough(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CSVCMsg_VoiceData)
  return target;
}

size_t CSVCMsg_VoiceData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CSVCMsg_VoiceData)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    // optional .CMsgVoiceAudio audio = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.audio_);
    }

    // optional fixed64 xuid = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional bool proximity = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

    // optional int32 audible_mask = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_audible_mask());
    }

    // optional uint32 tick = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_tick());
    }

    // optional int32 passthrough = 7;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_passthrough());
    }

    // optional int32 client = 2 [default = -1];
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_client());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSVCMsg_VoiceData::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CSVCMsg_VoiceData::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSVCMsg_VoiceData::GetClassData() const { return &_class_data_; }


void CSVCMsg_VoiceData::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CSVCMsg_VoiceData*>(&to_msg);
  auto& from = static_cast<const CSVCMsg_VoiceData&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CSVCMsg_VoiceData)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_audio()->::CMsgVoiceAudio::MergeFrom(
          from._internal_audio());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.xuid_ = from._impl_.xuid_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.proximity_ = from._impl_.proximity_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.audible_mask_ = from._impl_.audible_mask_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.tick_ = from._impl_.tick_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.passthrough_ = from._impl_.passthrough_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.client_ = from._impl_.client_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSVCMsg_VoiceData::CopyFrom(const CSVCMsg_VoiceData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CSVCMsg_VoiceData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSVCMsg_VoiceData::IsInitialized() const {
  return true;
}

void CSVCMsg_VoiceData::InternalSwap(CSVCMsg_VoiceData* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CSVCMsg_VoiceData, _impl_.passthrough_)
      + sizeof(CSVCMsg_VoiceData::_impl_.passthrough_)
      - PROTOBUF_FIELD_OFFSET(CSVCMsg_VoiceData, _impl_.audio_)>(
          reinterpret_cast<char*>(&_impl_.audio_),
          reinterpret_cast<char*>(&other->_impl_.audio_));
  swap(_impl_.client_, other->_impl_.client_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CSVCMsg_VoiceData::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[45]);
}

// ===================================================================

class CSVCMsg_PacketReliable::_Internal {
 public:
  using HasBits = decltype(std::declval<CSVCMsg_PacketReliable>()._impl_._has_bits_);
  static void set_has_tick(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_messagessize(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_state(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

CSVCMsg_PacketReliable::CSVCMsg_PacketReliable(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CSVCMsg_PacketReliable)
}
CSVCMsg_PacketReliable::CSVCMsg_PacketReliable(const CSVCMsg_PacketReliable& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CSVCMsg_PacketReliable* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.tick_){}
    , decltype(_impl_.messagessize_){}
    , decltype(_impl_.state_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.tick_, &from._impl_.tick_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.state_) -
    reinterpret_cast<char*>(&_impl_.tick_)) + sizeof(_impl_.state_));
  // @@protoc_insertion_point(copy_constructor:CSVCMsg_PacketReliable)
}

inline void CSVCMsg_PacketReliable::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.tick_){0}
    , decltype(_impl_.messagessize_){0}
    , decltype(_impl_.state_){false}
  };
}

CSVCMsg_PacketReliable::~CSVCMsg_PacketReliable() {
  // @@protoc_insertion_point(destructor:CSVCMsg_PacketReliable)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CSVCMsg_PacketReliable::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CSVCMsg_PacketReliable::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CSVCMsg_PacketReliable::Clear() {
// @@protoc_insertion_point(message_clear_start:CSVCMsg_PacketReliable)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.tick_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.state_) -
        reinterpret_cast<char*>(&_impl_.tick_)) + sizeof(_impl_.state_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSVCMsg_PacketReliable::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 tick = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_tick(&has_bits);
          _impl_.tick_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 messagessize = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_messagessize(&has_bits);
          _impl_.messagessize_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool state = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_state(&has_bits);
          _impl_.state_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSVCMsg_PacketReliable::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CSVCMsg_PacketReliable)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 tick = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_tick(), target);
  }

  // optional int32 messagessize = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_messagessize(), target);
  }

  // optional bool state = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_state(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CSVCMsg_PacketReliable)
  return target;
}

size_t CSVCMsg_PacketReliable::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CSVCMsg_PacketReliable)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional int32 tick = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_tick());
    }

    // optional int32 messagessize = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_messagessize());
    }

    // optional bool state = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSVCMsg_PacketReliable::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CSVCMsg_PacketReliable::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSVCMsg_PacketReliable::GetClassData() const { return &_class_data_; }


void CSVCMsg_PacketReliable::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CSVCMsg_PacketReliable*>(&to_msg);
  auto& from = static_cast<const CSVCMsg_PacketReliable&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CSVCMsg_PacketReliable)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.tick_ = from._impl_.tick_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.messagessize_ = from._impl_.messagessize_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.state_ = from._impl_.state_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSVCMsg_PacketReliable::CopyFrom(const CSVCMsg_PacketReliable& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CSVCMsg_PacketReliable)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSVCMsg_PacketReliable::IsInitialized() const {
  return true;
}

void CSVCMsg_PacketReliable::InternalSwap(CSVCMsg_PacketReliable* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CSVCMsg_PacketReliable, _impl_.state_)
      + sizeof(CSVCMsg_PacketReliable::_impl_.state_)
      - PROTOBUF_FIELD_OFFSET(CSVCMsg_PacketReliable, _impl_.tick_)>(
          reinterpret_cast<char*>(&_impl_.tick_),
          reinterpret_cast<char*>(&other->_impl_.tick_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CSVCMsg_PacketReliable::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[46]);
}

// ===================================================================

class CSVCMsg_FullFrameSplit::_Internal {
 public:
  using HasBits = decltype(std::declval<CSVCMsg_FullFrameSplit>()._impl_._has_bits_);
  static void set_has_tick(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_section(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_total(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CSVCMsg_FullFrameSplit::CSVCMsg_FullFrameSplit(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CSVCMsg_FullFrameSplit)
}
CSVCMsg_FullFrameSplit::CSVCMsg_FullFrameSplit(const CSVCMsg_FullFrameSplit& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CSVCMsg_FullFrameSplit* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.data_){}
    , decltype(_impl_.tick_){}
    , decltype(_impl_.section_){}
    , decltype(_impl_.total_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_data()) {
    _this->_impl_.data_.Set(from._internal_data(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.tick_, &from._impl_.tick_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.total_) -
    reinterpret_cast<char*>(&_impl_.tick_)) + sizeof(_impl_.total_));
  // @@protoc_insertion_point(copy_constructor:CSVCMsg_FullFrameSplit)
}

inline void CSVCMsg_FullFrameSplit::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.data_){}
    , decltype(_impl_.tick_){0}
    , decltype(_impl_.section_){0}
    , decltype(_impl_.total_){0}
  };
  _impl_.data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CSVCMsg_FullFrameSplit::~CSVCMsg_FullFrameSplit() {
  // @@protoc_insertion_point(destructor:CSVCMsg_FullFrameSplit)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CSVCMsg_FullFrameSplit::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.data_.Destroy();
}

void CSVCMsg_FullFrameSplit::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CSVCMsg_FullFrameSplit::Clear() {
// @@protoc_insertion_point(message_clear_start:CSVCMsg_FullFrameSplit)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.data_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&_impl_.tick_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.total_) -
        reinterpret_cast<char*>(&_impl_.tick_)) + sizeof(_impl_.total_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSVCMsg_FullFrameSplit::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 tick = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_tick(&has_bits);
          _impl_.tick_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 section = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_section(&has_bits);
          _impl_.section_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 total = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_total(&has_bits);
          _impl_.total_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes data = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSVCMsg_FullFrameSplit::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CSVCMsg_FullFrameSplit)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 tick = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_tick(), target);
  }

  // optional int32 section = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_section(), target);
  }

  // optional int32 total = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_total(), target);
  }

  // optional bytes data = 4;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_data(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CSVCMsg_FullFrameSplit)
  return target;
}

size_t CSVCMsg_FullFrameSplit::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CSVCMsg_FullFrameSplit)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional bytes data = 4;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_data());
    }

    // optional int32 tick = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_tick());
    }

    // optional int32 section = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_section());
    }

    // optional int32 total = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_total());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSVCMsg_FullFrameSplit::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CSVCMsg_FullFrameSplit::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSVCMsg_FullFrameSplit::GetClassData() const { return &_class_data_; }


void CSVCMsg_FullFrameSplit::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CSVCMsg_FullFrameSplit*>(&to_msg);
  auto& from = static_cast<const CSVCMsg_FullFrameSplit&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CSVCMsg_FullFrameSplit)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_data(from._internal_data());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.tick_ = from._impl_.tick_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.section_ = from._impl_.section_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.total_ = from._impl_.total_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSVCMsg_FullFrameSplit::CopyFrom(const CSVCMsg_FullFrameSplit& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CSVCMsg_FullFrameSplit)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSVCMsg_FullFrameSplit::IsInitialized() const {
  return true;
}

void CSVCMsg_FullFrameSplit::InternalSwap(CSVCMsg_FullFrameSplit* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.data_, lhs_arena,
      &other->_impl_.data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CSVCMsg_FullFrameSplit, _impl_.total_)
      + sizeof(CSVCMsg_FullFrameSplit::_impl_.total_)
      - PROTOBUF_FIELD_OFFSET(CSVCMsg_FullFrameSplit, _impl_.tick_)>(
          reinterpret_cast<char*>(&_impl_.tick_),
          reinterpret_cast<char*>(&other->_impl_.tick_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CSVCMsg_FullFrameSplit::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[47]);
}

// ===================================================================

class CSVCMsg_HLTVStatus::_Internal {
 public:
  using HasBits = decltype(std::declval<CSVCMsg_HLTVStatus>()._impl_._has_bits_);
  static void set_has_master(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_clients(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_slots(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_proxies(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

CSVCMsg_HLTVStatus::CSVCMsg_HLTVStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CSVCMsg_HLTVStatus)
}
CSVCMsg_HLTVStatus::CSVCMsg_HLTVStatus(const CSVCMsg_HLTVStatus& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CSVCMsg_HLTVStatus* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.master_){}
    , decltype(_impl_.clients_){}
    , decltype(_impl_.slots_){}
    , decltype(_impl_.proxies_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.master_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.master_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_master()) {
    _this->_impl_.master_.Set(from._internal_master(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.clients_, &from._impl_.clients_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.proxies_) -
    reinterpret_cast<char*>(&_impl_.clients_)) + sizeof(_impl_.proxies_));
  // @@protoc_insertion_point(copy_constructor:CSVCMsg_HLTVStatus)
}

inline void CSVCMsg_HLTVStatus::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.master_){}
    , decltype(_impl_.clients_){0}
    , decltype(_impl_.slots_){0}
    , decltype(_impl_.proxies_){0}
  };
  _impl_.master_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.master_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CSVCMsg_HLTVStatus::~CSVCMsg_HLTVStatus() {
  // @@protoc_insertion_point(destructor:CSVCMsg_HLTVStatus)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CSVCMsg_HLTVStatus::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.master_.Destroy();
}

void CSVCMsg_HLTVStatus::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CSVCMsg_HLTVStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:CSVCMsg_HLTVStatus)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.master_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&_impl_.clients_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.proxies_) -
        reinterpret_cast<char*>(&_impl_.clients_)) + sizeof(_impl_.proxies_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSVCMsg_HLTVStatus::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string master = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_master();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CSVCMsg_HLTVStatus.master");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional int32 clients = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_clients(&has_bits);
          _impl_.clients_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 slots = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_slots(&has_bits);
          _impl_.slots_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 proxies = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_proxies(&has_bits);
          _impl_.proxies_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSVCMsg_HLTVStatus::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CSVCMsg_HLTVStatus)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string master = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_master().data(), static_cast<int>(this->_internal_master().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CSVCMsg_HLTVStatus.master");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_master(), target);
  }

  // optional int32 clients = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_clients(), target);
  }

  // optional int32 slots = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_slots(), target);
  }

  // optional int32 proxies = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_proxies(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CSVCMsg_HLTVStatus)
  return target;
}

size_t CSVCMsg_HLTVStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CSVCMsg_HLTVStatus)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional string master = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_master());
    }

    // optional int32 clients = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_clients());
    }

    // optional int32 slots = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_slots());
    }

    // optional int32 proxies = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_proxies());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSVCMsg_HLTVStatus::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CSVCMsg_HLTVStatus::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSVCMsg_HLTVStatus::GetClassData() const { return &_class_data_; }


void CSVCMsg_HLTVStatus::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CSVCMsg_HLTVStatus*>(&to_msg);
  auto& from = static_cast<const CSVCMsg_HLTVStatus&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CSVCMsg_HLTVStatus)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_master(from._internal_master());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.clients_ = from._impl_.clients_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.slots_ = from._impl_.slots_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.proxies_ = from._impl_.proxies_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSVCMsg_HLTVStatus::CopyFrom(const CSVCMsg_HLTVStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CSVCMsg_HLTVStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSVCMsg_HLTVStatus::IsInitialized() const {
  return true;
}

void CSVCMsg_HLTVStatus::InternalSwap(CSVCMsg_HLTVStatus* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.master_, lhs_arena,
      &other->_impl_.master_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CSVCMsg_HLTVStatus, _impl_.proxies_)
      + sizeof(CSVCMsg_HLTVStatus::_impl_.proxies_)
      - PROTOBUF_FIELD_OFFSET(CSVCMsg_HLTVStatus, _impl_.clients_)>(
          reinterpret_cast<char*>(&_impl_.clients_),
          reinterpret_cast<char*>(&other->_impl_.clients_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CSVCMsg_HLTVStatus::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[48]);
}

// ===================================================================

class CSVCMsg_ServerSteamID::_Internal {
 public:
  using HasBits = decltype(std::declval<CSVCMsg_ServerSteamID>()._impl_._has_bits_);
  static void set_has_steam_id(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CSVCMsg_ServerSteamID::CSVCMsg_ServerSteamID(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CSVCMsg_ServerSteamID)
}
CSVCMsg_ServerSteamID::CSVCMsg_ServerSteamID(const CSVCMsg_ServerSteamID& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CSVCMsg_ServerSteamID* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.steam_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.steam_id_ = from._impl_.steam_id_;
  // @@protoc_insertion_point(copy_constructor:CSVCMsg_ServerSteamID)
}

inline void CSVCMsg_ServerSteamID::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.steam_id_){uint64_t{0u}}
  };
}

CSVCMsg_ServerSteamID::~CSVCMsg_ServerSteamID() {
  // @@protoc_insertion_point(destructor:CSVCMsg_ServerSteamID)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CSVCMsg_ServerSteamID::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CSVCMsg_ServerSteamID::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CSVCMsg_ServerSteamID::Clear() {
// @@protoc_insertion_point(message_clear_start:CSVCMsg_ServerSteamID)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.steam_id_ = uint64_t{0u};
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSVCMsg_ServerSteamID::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 steam_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_steam_id(&has_bits);
          _impl_.steam_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSVCMsg_ServerSteamID::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CSVCMsg_ServerSteamID)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 steam_id = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_steam_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CSVCMsg_ServerSteamID)
  return target;
}

size_t CSVCMsg_ServerSteamID::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CSVCMsg_ServerSteamID)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional uint64 steam_id = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_steam_id());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSVCMsg_ServerSteamID::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CSVCMsg_ServerSteamID::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSVCMsg_ServerSteamID::GetClassData() const { return &_class_data_; }


void CSVCMsg_ServerSteamID::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CSVCMsg_ServerSteamID*>(&to_msg);
  auto& from = static_cast<const CSVCMsg_ServerSteamID&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CSVCMsg_ServerSteamID)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_steam_id()) {
    _this->_internal_set_steam_id(from._internal_steam_id());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSVCMsg_ServerSteamID::CopyFrom(const CSVCMsg_ServerSteamID& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CSVCMsg_ServerSteamID)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSVCMsg_ServerSteamID::IsInitialized() const {
  return true;
}

void CSVCMsg_ServerSteamID::InternalSwap(CSVCMsg_ServerSteamID* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.steam_id_, other->_impl_.steam_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CSVCMsg_ServerSteamID::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[49]);
}

// ===================================================================

class CSVCMsg_CmdKeyValues::_Internal {
 public:
  using HasBits = decltype(std::declval<CSVCMsg_CmdKeyValues>()._impl_._has_bits_);
  static void set_has_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CSVCMsg_CmdKeyValues::CSVCMsg_CmdKeyValues(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CSVCMsg_CmdKeyValues)
}
CSVCMsg_CmdKeyValues::CSVCMsg_CmdKeyValues(const CSVCMsg_CmdKeyValues& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CSVCMsg_CmdKeyValues* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.data_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_data()) {
    _this->_impl_.data_.Set(from._internal_data(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:CSVCMsg_CmdKeyValues)
}

inline void CSVCMsg_CmdKeyValues::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.data_){}
  };
  _impl_.data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CSVCMsg_CmdKeyValues::~CSVCMsg_CmdKeyValues() {
  // @@protoc_insertion_point(destructor:CSVCMsg_CmdKeyValues)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CSVCMsg_CmdKeyValues::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.data_.Destroy();
}

void CSVCMsg_CmdKeyValues::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CSVCMsg_CmdKeyValues::Clear() {
// @@protoc_insertion_point(message_clear_start:CSVCMsg_CmdKeyValues)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.data_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSVCMsg_CmdKeyValues::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes data = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSVCMsg_CmdKeyValues::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CSVCMsg_CmdKeyValues)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes data = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_data(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CSVCMsg_CmdKeyValues)
  return target;
}

size_t CSVCMsg_CmdKeyValues::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CSVCMsg_CmdKeyValues)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional bytes data = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_data());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSVCMsg_CmdKeyValues::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CSVCMsg_CmdKeyValues::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSVCMsg_CmdKeyValues::GetClassData() const { return &_class_data_; }


void CSVCMsg_CmdKeyValues::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CSVCMsg_CmdKeyValues*>(&to_msg);
  auto& from = static_cast<const CSVCMsg_CmdKeyValues&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CSVCMsg_CmdKeyValues)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_data()) {
    _this->_internal_set_data(from._internal_data());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSVCMsg_CmdKeyValues::CopyFrom(const CSVCMsg_CmdKeyValues& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CSVCMsg_CmdKeyValues)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSVCMsg_CmdKeyValues::IsInitialized() const {
  return true;
}

void CSVCMsg_CmdKeyValues::InternalSwap(CSVCMsg_CmdKeyValues* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.data_, lhs_arena,
      &other->_impl_.data_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata CSVCMsg_CmdKeyValues::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[50]);
}

// ===================================================================

class CSVCMsg_RconServerDetails::_Internal {
 public:
  using HasBits = decltype(std::declval<CSVCMsg_RconServerDetails>()._impl_._has_bits_);
  static void set_has_token(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_details(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CSVCMsg_RconServerDetails::CSVCMsg_RconServerDetails(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CSVCMsg_RconServerDetails)
}
CSVCMsg_RconServerDetails::CSVCMsg_RconServerDetails(const CSVCMsg_RconServerDetails& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CSVCMsg_RconServerDetails* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.token_){}
    , decltype(_impl_.details_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_token()) {
    _this->_impl_.token_.Set(from._internal_token(), 
      _this->GetArenaForAllocation());
  }
  _impl_.details_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.details_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_details()) {
    _this->_impl_.details_.Set(from._internal_details(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:CSVCMsg_RconServerDetails)
}

inline void CSVCMsg_RconServerDetails::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.token_){}
    , decltype(_impl_.details_){}
  };
  _impl_.token_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.token_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.details_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.details_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CSVCMsg_RconServerDetails::~CSVCMsg_RconServerDetails() {
  // @@protoc_insertion_point(destructor:CSVCMsg_RconServerDetails)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CSVCMsg_RconServerDetails::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.token_.Destroy();
  _impl_.details_.Destroy();
}

void CSVCMsg_RconServerDetails::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CSVCMsg_RconServerDetails::Clear() {
// @@protoc_insertion_point(message_clear_start:CSVCMsg_RconServerDetails)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.token_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.details_.ClearNonDefaultToEmpty();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSVCMsg_RconServerDetails::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bytes token = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_token();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string details = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_details();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CSVCMsg_RconServerDetails.details");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSVCMsg_RconServerDetails::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CSVCMsg_RconServerDetails)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bytes token = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        1, this->_internal_token(), target);
  }

  // optional string details = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_details().data(), static_cast<int>(this->_internal_details().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CSVCMsg_RconServerDetails.details");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_details(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CSVCMsg_RconServerDetails)
  return target;
}

size_t CSVCMsg_RconServerDetails::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CSVCMsg_RconServerDetails)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bytes token = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_token());
    }

    // optional string details = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_details());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSVCMsg_RconServerDetails::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CSVCMsg_RconServerDetails::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSVCMsg_RconServerDetails::GetClassData() const { return &_class_data_; }


void CSVCMsg_RconServerDetails::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CSVCMsg_RconServerDetails*>(&to_msg);
  auto& from = static_cast<const CSVCMsg_RconServerDetails&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CSVCMsg_RconServerDetails)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_token(from._internal_token());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_details(from._internal_details());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSVCMsg_RconServerDetails::CopyFrom(const CSVCMsg_RconServerDetails& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CSVCMsg_RconServerDetails)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSVCMsg_RconServerDetails::IsInitialized() const {
  return true;
}

void CSVCMsg_RconServerDetails::InternalSwap(CSVCMsg_RconServerDetails* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.token_, lhs_arena,
      &other->_impl_.token_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.details_, lhs_arena,
      &other->_impl_.details_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata CSVCMsg_RconServerDetails::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[51]);
}

// ===================================================================

class CMsgIPCAddress::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgIPCAddress>()._impl_._has_bits_);
  static void set_has_computer_guid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_process_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CMsgIPCAddress::CMsgIPCAddress(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgIPCAddress)
}
CMsgIPCAddress::CMsgIPCAddress(const CMsgIPCAddress& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgIPCAddress* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.computer_guid_){}
    , decltype(_impl_.process_id_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.computer_guid_, &from._impl_.computer_guid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.process_id_) -
    reinterpret_cast<char*>(&_impl_.computer_guid_)) + sizeof(_impl_.process_id_));
  // @@protoc_insertion_point(copy_constructor:CMsgIPCAddress)
}

inline void CMsgIPCAddress::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.computer_guid_){uint64_t{0u}}
    , decltype(_impl_.process_id_){0u}
  };
}

CMsgIPCAddress::~CMsgIPCAddress() {
  // @@protoc_insertion_point(destructor:CMsgIPCAddress)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgIPCAddress::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgIPCAddress::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgIPCAddress::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgIPCAddress)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.computer_guid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.process_id_) -
        reinterpret_cast<char*>(&_impl_.computer_guid_)) + sizeof(_impl_.process_id_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgIPCAddress::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional fixed64 computer_guid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _Internal::set_has_computer_guid(&has_bits);
          _impl_.computer_guid_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 process_id = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_process_id(&has_bits);
          _impl_.process_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgIPCAddress::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgIPCAddress)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional fixed64 computer_guid = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(1, this->_internal_computer_guid(), target);
  }

  // optional uint32 process_id = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_process_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgIPCAddress)
  return target;
}

size_t CMsgIPCAddress::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgIPCAddress)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional fixed64 computer_guid = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 8;
    }

    // optional uint32 process_id = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_process_id());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgIPCAddress::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgIPCAddress::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgIPCAddress::GetClassData() const { return &_class_data_; }


void CMsgIPCAddress::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgIPCAddress*>(&to_msg);
  auto& from = static_cast<const CMsgIPCAddress&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgIPCAddress)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.computer_guid_ = from._impl_.computer_guid_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.process_id_ = from._impl_.process_id_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgIPCAddress::CopyFrom(const CMsgIPCAddress& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgIPCAddress)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgIPCAddress::IsInitialized() const {
  return true;
}

void CMsgIPCAddress::InternalSwap(CMsgIPCAddress* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgIPCAddress, _impl_.process_id_)
      + sizeof(CMsgIPCAddress::_impl_.process_id_)
      - PROTOBUF_FIELD_OFFSET(CMsgIPCAddress, _impl_.computer_guid_)>(
          reinterpret_cast<char*>(&_impl_.computer_guid_),
          reinterpret_cast<char*>(&other->_impl_.computer_guid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgIPCAddress::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[52]);
}

// ===================================================================

class CMsgServerPeer::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgServerPeer>()._impl_._has_bits_);
  static void set_has_player_slot(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_steamid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::CMsgIPCAddress& ipc(const CMsgServerPeer* msg);
  static void set_has_ipc(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_they_hear_you(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_you_hear_them(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_is_listenserver_host(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

const ::CMsgIPCAddress&
CMsgServerPeer::_Internal::ipc(const CMsgServerPeer* msg) {
  return *msg->_impl_.ipc_;
}
CMsgServerPeer::CMsgServerPeer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgServerPeer)
}
CMsgServerPeer::CMsgServerPeer(const CMsgServerPeer& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgServerPeer* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ipc_){nullptr}
    , decltype(_impl_.steamid_){}
    , decltype(_impl_.they_hear_you_){}
    , decltype(_impl_.you_hear_them_){}
    , decltype(_impl_.is_listenserver_host_){}
    , decltype(_impl_.player_slot_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_ipc()) {
    _this->_impl_.ipc_ = new ::CMsgIPCAddress(*from._impl_.ipc_);
  }
  ::memcpy(&_impl_.steamid_, &from._impl_.steamid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.player_slot_) -
    reinterpret_cast<char*>(&_impl_.steamid_)) + sizeof(_impl_.player_slot_));
  // @@protoc_insertion_point(copy_constructor:CMsgServerPeer)
}

inline void CMsgServerPeer::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ipc_){nullptr}
    , decltype(_impl_.steamid_){uint64_t{0u}}
    , decltype(_impl_.they_hear_you_){false}
    , decltype(_impl_.you_hear_them_){false}
    , decltype(_impl_.is_listenserver_host_){false}
    , decltype(_impl_.player_slot_){-1}
  };
}

CMsgServerPeer::~CMsgServerPeer() {
  // @@protoc_insertion_point(destructor:CMsgServerPeer)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgServerPeer::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.ipc_;
}

void CMsgServerPeer::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgServerPeer::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgServerPeer)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.ipc_ != nullptr);
    _impl_.ipc_->Clear();
  }
  if (cached_has_bits & 0x0000003eu) {
    ::memset(&_impl_.steamid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.is_listenserver_host_) -
        reinterpret_cast<char*>(&_impl_.steamid_)) + sizeof(_impl_.is_listenserver_host_));
    _impl_.player_slot_ = -1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgServerPeer::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 player_slot = 1 [default = -1];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_player_slot(&has_bits);
          _impl_.player_slot_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional fixed64 steamid = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_steamid(&has_bits);
          _impl_.steamid_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgIPCAddress ipc = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_ipc(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool they_hear_you = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_they_hear_you(&has_bits);
          _impl_.they_hear_you_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool you_hear_them = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_you_hear_them(&has_bits);
          _impl_.you_hear_them_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_listenserver_host = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_is_listenserver_host(&has_bits);
          _impl_.is_listenserver_host_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgServerPeer::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgServerPeer)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 player_slot = 1 [default = -1];
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_player_slot(), target);
  }

  // optional fixed64 steamid = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(2, this->_internal_steamid(), target);
  }

  // optional .CMsgIPCAddress ipc = 3;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::ipc(this),
        _Internal::ipc(this).GetCachedSize(), target, stream);
  }

  // optional bool they_hear_you = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(4, this->_internal_they_hear_you(), target);
  }

  // optional bool you_hear_them = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_you_hear_them(), target);
  }

  // optional bool is_listenserver_host = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_is_listenserver_host(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgServerPeer)
  return target;
}

size_t CMsgServerPeer::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgServerPeer)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    // optional .CMsgIPCAddress ipc = 3;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.ipc_);
    }

    // optional fixed64 steamid = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional bool they_hear_you = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

    // optional bool you_hear_them = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 1;
    }

    // optional bool is_listenserver_host = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

    // optional int32 player_slot = 1 [default = -1];
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_player_slot());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgServerPeer::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgServerPeer::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgServerPeer::GetClassData() const { return &_class_data_; }


void CMsgServerPeer::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgServerPeer*>(&to_msg);
  auto& from = static_cast<const CMsgServerPeer&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgServerPeer)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000003fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_ipc()->::CMsgIPCAddress::MergeFrom(
          from._internal_ipc());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.steamid_ = from._impl_.steamid_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.they_hear_you_ = from._impl_.they_hear_you_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.you_hear_them_ = from._impl_.you_hear_them_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.is_listenserver_host_ = from._impl_.is_listenserver_host_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.player_slot_ = from._impl_.player_slot_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgServerPeer::CopyFrom(const CMsgServerPeer& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgServerPeer)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgServerPeer::IsInitialized() const {
  return true;
}

void CMsgServerPeer::InternalSwap(CMsgServerPeer* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgServerPeer, _impl_.is_listenserver_host_)
      + sizeof(CMsgServerPeer::_impl_.is_listenserver_host_)
      - PROTOBUF_FIELD_OFFSET(CMsgServerPeer, _impl_.ipc_)>(
          reinterpret_cast<char*>(&_impl_.ipc_),
          reinterpret_cast<char*>(&other->_impl_.ipc_));
  swap(_impl_.player_slot_, other->_impl_.player_slot_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgServerPeer::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[53]);
}

// ===================================================================

class CSVCMsg_PeerList::_Internal {
 public:
};

CSVCMsg_PeerList::CSVCMsg_PeerList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CSVCMsg_PeerList)
}
CSVCMsg_PeerList::CSVCMsg_PeerList(const CSVCMsg_PeerList& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CSVCMsg_PeerList* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.peer_){from._impl_.peer_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CSVCMsg_PeerList)
}

inline void CSVCMsg_PeerList::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.peer_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CSVCMsg_PeerList::~CSVCMsg_PeerList() {
  // @@protoc_insertion_point(destructor:CSVCMsg_PeerList)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CSVCMsg_PeerList::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.peer_.~RepeatedPtrField();
}

void CSVCMsg_PeerList::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CSVCMsg_PeerList::Clear() {
// @@protoc_insertion_point(message_clear_start:CSVCMsg_PeerList)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.peer_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSVCMsg_PeerList::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .CMsgServerPeer peer = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_peer(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSVCMsg_PeerList::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CSVCMsg_PeerList)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .CMsgServerPeer peer = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_peer_size()); i < n; i++) {
    const auto& repfield = this->_internal_peer(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CSVCMsg_PeerList)
  return target;
}

size_t CSVCMsg_PeerList::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CSVCMsg_PeerList)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgServerPeer peer = 1;
  total_size += 1UL * this->_internal_peer_size();
  for (const auto& msg : this->_impl_.peer_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSVCMsg_PeerList::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CSVCMsg_PeerList::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSVCMsg_PeerList::GetClassData() const { return &_class_data_; }


void CSVCMsg_PeerList::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CSVCMsg_PeerList*>(&to_msg);
  auto& from = static_cast<const CSVCMsg_PeerList&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CSVCMsg_PeerList)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.peer_.MergeFrom(from._impl_.peer_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSVCMsg_PeerList::CopyFrom(const CSVCMsg_PeerList& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CSVCMsg_PeerList)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSVCMsg_PeerList::IsInitialized() const {
  return true;
}

void CSVCMsg_PeerList::InternalSwap(CSVCMsg_PeerList* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.peer_.InternalSwap(&other->_impl_.peer_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CSVCMsg_PeerList::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[54]);
}

// ===================================================================

class CSVCMsg_ClearAllStringTables::_Internal {
 public:
  using HasBits = decltype(std::declval<CSVCMsg_ClearAllStringTables>()._impl_._has_bits_);
  static void set_has_mapname(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_create_tables_skipped(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CSVCMsg_ClearAllStringTables::CSVCMsg_ClearAllStringTables(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CSVCMsg_ClearAllStringTables)
}
CSVCMsg_ClearAllStringTables::CSVCMsg_ClearAllStringTables(const CSVCMsg_ClearAllStringTables& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CSVCMsg_ClearAllStringTables* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.mapname_){}
    , decltype(_impl_.create_tables_skipped_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.mapname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.mapname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_mapname()) {
    _this->_impl_.mapname_.Set(from._internal_mapname(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.create_tables_skipped_ = from._impl_.create_tables_skipped_;
  // @@protoc_insertion_point(copy_constructor:CSVCMsg_ClearAllStringTables)
}

inline void CSVCMsg_ClearAllStringTables::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.mapname_){}
    , decltype(_impl_.create_tables_skipped_){false}
  };
  _impl_.mapname_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.mapname_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CSVCMsg_ClearAllStringTables::~CSVCMsg_ClearAllStringTables() {
  // @@protoc_insertion_point(destructor:CSVCMsg_ClearAllStringTables)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CSVCMsg_ClearAllStringTables::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.mapname_.Destroy();
}

void CSVCMsg_ClearAllStringTables::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CSVCMsg_ClearAllStringTables::Clear() {
// @@protoc_insertion_point(message_clear_start:CSVCMsg_ClearAllStringTables)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.mapname_.ClearNonDefaultToEmpty();
  }
  _impl_.create_tables_skipped_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSVCMsg_ClearAllStringTables::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string mapname = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_mapname();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CSVCMsg_ClearAllStringTables.mapname");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional bool create_tables_skipped = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_create_tables_skipped(&has_bits);
          _impl_.create_tables_skipped_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSVCMsg_ClearAllStringTables::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CSVCMsg_ClearAllStringTables)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string mapname = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_mapname().data(), static_cast<int>(this->_internal_mapname().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CSVCMsg_ClearAllStringTables.mapname");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_mapname(), target);
  }

  // optional bool create_tables_skipped = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_create_tables_skipped(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CSVCMsg_ClearAllStringTables)
  return target;
}

size_t CSVCMsg_ClearAllStringTables::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CSVCMsg_ClearAllStringTables)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string mapname = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_mapname());
    }

    // optional bool create_tables_skipped = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSVCMsg_ClearAllStringTables::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CSVCMsg_ClearAllStringTables::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSVCMsg_ClearAllStringTables::GetClassData() const { return &_class_data_; }


void CSVCMsg_ClearAllStringTables::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CSVCMsg_ClearAllStringTables*>(&to_msg);
  auto& from = static_cast<const CSVCMsg_ClearAllStringTables&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CSVCMsg_ClearAllStringTables)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_mapname(from._internal_mapname());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.create_tables_skipped_ = from._impl_.create_tables_skipped_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSVCMsg_ClearAllStringTables::CopyFrom(const CSVCMsg_ClearAllStringTables& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CSVCMsg_ClearAllStringTables)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSVCMsg_ClearAllStringTables::IsInitialized() const {
  return true;
}

void CSVCMsg_ClearAllStringTables::InternalSwap(CSVCMsg_ClearAllStringTables* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.mapname_, lhs_arena,
      &other->_impl_.mapname_, rhs_arena
  );
  swap(_impl_.create_tables_skipped_, other->_impl_.create_tables_skipped_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CSVCMsg_ClearAllStringTables::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[55]);
}

// ===================================================================

class ProtoFlattenedSerializerField_t_polymorphic_field_t::_Internal {
 public:
  using HasBits = decltype(std::declval<ProtoFlattenedSerializerField_t_polymorphic_field_t>()._impl_._has_bits_);
  static void set_has_polymorphic_field_serializer_name_sym(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_polymorphic_field_serializer_version(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

ProtoFlattenedSerializerField_t_polymorphic_field_t::ProtoFlattenedSerializerField_t_polymorphic_field_t(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:ProtoFlattenedSerializerField_t.polymorphic_field_t)
}
ProtoFlattenedSerializerField_t_polymorphic_field_t::ProtoFlattenedSerializerField_t_polymorphic_field_t(const ProtoFlattenedSerializerField_t_polymorphic_field_t& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ProtoFlattenedSerializerField_t_polymorphic_field_t* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.polymorphic_field_serializer_name_sym_){}
    , decltype(_impl_.polymorphic_field_serializer_version_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.polymorphic_field_serializer_name_sym_, &from._impl_.polymorphic_field_serializer_name_sym_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.polymorphic_field_serializer_version_) -
    reinterpret_cast<char*>(&_impl_.polymorphic_field_serializer_name_sym_)) + sizeof(_impl_.polymorphic_field_serializer_version_));
  // @@protoc_insertion_point(copy_constructor:ProtoFlattenedSerializerField_t.polymorphic_field_t)
}

inline void ProtoFlattenedSerializerField_t_polymorphic_field_t::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.polymorphic_field_serializer_name_sym_){0}
    , decltype(_impl_.polymorphic_field_serializer_version_){0}
  };
}

ProtoFlattenedSerializerField_t_polymorphic_field_t::~ProtoFlattenedSerializerField_t_polymorphic_field_t() {
  // @@protoc_insertion_point(destructor:ProtoFlattenedSerializerField_t.polymorphic_field_t)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ProtoFlattenedSerializerField_t_polymorphic_field_t::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void ProtoFlattenedSerializerField_t_polymorphic_field_t::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ProtoFlattenedSerializerField_t_polymorphic_field_t::Clear() {
// @@protoc_insertion_point(message_clear_start:ProtoFlattenedSerializerField_t.polymorphic_field_t)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.polymorphic_field_serializer_name_sym_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.polymorphic_field_serializer_version_) -
        reinterpret_cast<char*>(&_impl_.polymorphic_field_serializer_name_sym_)) + sizeof(_impl_.polymorphic_field_serializer_version_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ProtoFlattenedSerializerField_t_polymorphic_field_t::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 polymorphic_field_serializer_name_sym = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_polymorphic_field_serializer_name_sym(&has_bits);
          _impl_.polymorphic_field_serializer_name_sym_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 polymorphic_field_serializer_version = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_polymorphic_field_serializer_version(&has_bits);
          _impl_.polymorphic_field_serializer_version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ProtoFlattenedSerializerField_t_polymorphic_field_t::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ProtoFlattenedSerializerField_t.polymorphic_field_t)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 polymorphic_field_serializer_name_sym = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_polymorphic_field_serializer_name_sym(), target);
  }

  // optional int32 polymorphic_field_serializer_version = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_polymorphic_field_serializer_version(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ProtoFlattenedSerializerField_t.polymorphic_field_t)
  return target;
}

size_t ProtoFlattenedSerializerField_t_polymorphic_field_t::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ProtoFlattenedSerializerField_t.polymorphic_field_t)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional int32 polymorphic_field_serializer_name_sym = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_polymorphic_field_serializer_name_sym());
    }

    // optional int32 polymorphic_field_serializer_version = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_polymorphic_field_serializer_version());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ProtoFlattenedSerializerField_t_polymorphic_field_t::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ProtoFlattenedSerializerField_t_polymorphic_field_t::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ProtoFlattenedSerializerField_t_polymorphic_field_t::GetClassData() const { return &_class_data_; }


void ProtoFlattenedSerializerField_t_polymorphic_field_t::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ProtoFlattenedSerializerField_t_polymorphic_field_t*>(&to_msg);
  auto& from = static_cast<const ProtoFlattenedSerializerField_t_polymorphic_field_t&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:ProtoFlattenedSerializerField_t.polymorphic_field_t)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.polymorphic_field_serializer_name_sym_ = from._impl_.polymorphic_field_serializer_name_sym_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.polymorphic_field_serializer_version_ = from._impl_.polymorphic_field_serializer_version_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ProtoFlattenedSerializerField_t_polymorphic_field_t::CopyFrom(const ProtoFlattenedSerializerField_t_polymorphic_field_t& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ProtoFlattenedSerializerField_t.polymorphic_field_t)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ProtoFlattenedSerializerField_t_polymorphic_field_t::IsInitialized() const {
  return true;
}

void ProtoFlattenedSerializerField_t_polymorphic_field_t::InternalSwap(ProtoFlattenedSerializerField_t_polymorphic_field_t* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ProtoFlattenedSerializerField_t_polymorphic_field_t, _impl_.polymorphic_field_serializer_version_)
      + sizeof(ProtoFlattenedSerializerField_t_polymorphic_field_t::_impl_.polymorphic_field_serializer_version_)
      - PROTOBUF_FIELD_OFFSET(ProtoFlattenedSerializerField_t_polymorphic_field_t, _impl_.polymorphic_field_serializer_name_sym_)>(
          reinterpret_cast<char*>(&_impl_.polymorphic_field_serializer_name_sym_),
          reinterpret_cast<char*>(&other->_impl_.polymorphic_field_serializer_name_sym_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ProtoFlattenedSerializerField_t_polymorphic_field_t::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[56]);
}

// ===================================================================

class ProtoFlattenedSerializerField_t::_Internal {
 public:
  using HasBits = decltype(std::declval<ProtoFlattenedSerializerField_t>()._impl_._has_bits_);
  static void set_has_var_type_sym(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_var_name_sym(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_bit_count(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_low_value(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_high_value(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_encode_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_field_serializer_name_sym(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_field_serializer_version(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_send_node_sym(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_var_encoder_sym(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_var_serializer_sym(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
};

ProtoFlattenedSerializerField_t::ProtoFlattenedSerializerField_t(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:ProtoFlattenedSerializerField_t)
}
ProtoFlattenedSerializerField_t::ProtoFlattenedSerializerField_t(const ProtoFlattenedSerializerField_t& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ProtoFlattenedSerializerField_t* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.polymorphic_types_){from._impl_.polymorphic_types_}
    , decltype(_impl_.var_type_sym_){}
    , decltype(_impl_.var_name_sym_){}
    , decltype(_impl_.bit_count_){}
    , decltype(_impl_.low_value_){}
    , decltype(_impl_.high_value_){}
    , decltype(_impl_.encode_flags_){}
    , decltype(_impl_.field_serializer_name_sym_){}
    , decltype(_impl_.field_serializer_version_){}
    , decltype(_impl_.send_node_sym_){}
    , decltype(_impl_.var_encoder_sym_){}
    , decltype(_impl_.var_serializer_sym_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.var_type_sym_, &from._impl_.var_type_sym_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.var_serializer_sym_) -
    reinterpret_cast<char*>(&_impl_.var_type_sym_)) + sizeof(_impl_.var_serializer_sym_));
  // @@protoc_insertion_point(copy_constructor:ProtoFlattenedSerializerField_t)
}

inline void ProtoFlattenedSerializerField_t::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.polymorphic_types_){arena}
    , decltype(_impl_.var_type_sym_){0}
    , decltype(_impl_.var_name_sym_){0}
    , decltype(_impl_.bit_count_){0}
    , decltype(_impl_.low_value_){0}
    , decltype(_impl_.high_value_){0}
    , decltype(_impl_.encode_flags_){0}
    , decltype(_impl_.field_serializer_name_sym_){0}
    , decltype(_impl_.field_serializer_version_){0}
    , decltype(_impl_.send_node_sym_){0}
    , decltype(_impl_.var_encoder_sym_){0}
    , decltype(_impl_.var_serializer_sym_){0}
  };
}

ProtoFlattenedSerializerField_t::~ProtoFlattenedSerializerField_t() {
  // @@protoc_insertion_point(destructor:ProtoFlattenedSerializerField_t)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ProtoFlattenedSerializerField_t::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.polymorphic_types_.~RepeatedPtrField();
}

void ProtoFlattenedSerializerField_t::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ProtoFlattenedSerializerField_t::Clear() {
// @@protoc_insertion_point(message_clear_start:ProtoFlattenedSerializerField_t)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.polymorphic_types_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&_impl_.var_type_sym_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.field_serializer_version_) -
        reinterpret_cast<char*>(&_impl_.var_type_sym_)) + sizeof(_impl_.field_serializer_version_));
  }
  if (cached_has_bits & 0x00000700u) {
    ::memset(&_impl_.send_node_sym_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.var_serializer_sym_) -
        reinterpret_cast<char*>(&_impl_.send_node_sym_)) + sizeof(_impl_.var_serializer_sym_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ProtoFlattenedSerializerField_t::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 var_type_sym = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_var_type_sym(&has_bits);
          _impl_.var_type_sym_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 var_name_sym = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_var_name_sym(&has_bits);
          _impl_.var_name_sym_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 bit_count = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_bit_count(&has_bits);
          _impl_.bit_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float low_value = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          _Internal::set_has_low_value(&has_bits);
          _impl_.low_value_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float high_value = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 45)) {
          _Internal::set_has_high_value(&has_bits);
          _impl_.high_value_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional int32 encode_flags = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_encode_flags(&has_bits);
          _impl_.encode_flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 field_serializer_name_sym = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_field_serializer_name_sym(&has_bits);
          _impl_.field_serializer_name_sym_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 field_serializer_version = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_field_serializer_version(&has_bits);
          _impl_.field_serializer_version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 send_node_sym = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_send_node_sym(&has_bits);
          _impl_.send_node_sym_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 var_encoder_sym = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_var_encoder_sym(&has_bits);
          _impl_.var_encoder_sym_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .ProtoFlattenedSerializerField_t.polymorphic_field_t polymorphic_types = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_polymorphic_types(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<90>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional int32 var_serializer_sym = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_var_serializer_sym(&has_bits);
          _impl_.var_serializer_sym_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ProtoFlattenedSerializerField_t::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ProtoFlattenedSerializerField_t)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 var_type_sym = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_var_type_sym(), target);
  }

  // optional int32 var_name_sym = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_var_name_sym(), target);
  }

  // optional int32 bit_count = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_bit_count(), target);
  }

  // optional float low_value = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(4, this->_internal_low_value(), target);
  }

  // optional float high_value = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(5, this->_internal_high_value(), target);
  }

  // optional int32 encode_flags = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(6, this->_internal_encode_flags(), target);
  }

  // optional int32 field_serializer_name_sym = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(7, this->_internal_field_serializer_name_sym(), target);
  }

  // optional int32 field_serializer_version = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(8, this->_internal_field_serializer_version(), target);
  }

  // optional int32 send_node_sym = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(9, this->_internal_send_node_sym(), target);
  }

  // optional int32 var_encoder_sym = 10;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(10, this->_internal_var_encoder_sym(), target);
  }

  // repeated .ProtoFlattenedSerializerField_t.polymorphic_field_t polymorphic_types = 11;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_polymorphic_types_size()); i < n; i++) {
    const auto& repfield = this->_internal_polymorphic_types(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(11, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional int32 var_serializer_sym = 12;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(12, this->_internal_var_serializer_sym(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ProtoFlattenedSerializerField_t)
  return target;
}

size_t ProtoFlattenedSerializerField_t::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ProtoFlattenedSerializerField_t)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .ProtoFlattenedSerializerField_t.polymorphic_field_t polymorphic_types = 11;
  total_size += 1UL * this->_internal_polymorphic_types_size();
  for (const auto& msg : this->_impl_.polymorphic_types_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional int32 var_type_sym = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_var_type_sym());
    }

    // optional int32 var_name_sym = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_var_name_sym());
    }

    // optional int32 bit_count = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_bit_count());
    }

    // optional float low_value = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 4;
    }

    // optional float high_value = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 4;
    }

    // optional int32 encode_flags = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_encode_flags());
    }

    // optional int32 field_serializer_name_sym = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_field_serializer_name_sym());
    }

    // optional int32 field_serializer_version = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_field_serializer_version());
    }

  }
  if (cached_has_bits & 0x00000700u) {
    // optional int32 send_node_sym = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_send_node_sym());
    }

    // optional int32 var_encoder_sym = 10;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_var_encoder_sym());
    }

    // optional int32 var_serializer_sym = 12;
    if (cached_has_bits & 0x00000400u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_var_serializer_sym());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ProtoFlattenedSerializerField_t::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ProtoFlattenedSerializerField_t::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ProtoFlattenedSerializerField_t::GetClassData() const { return &_class_data_; }


void ProtoFlattenedSerializerField_t::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ProtoFlattenedSerializerField_t*>(&to_msg);
  auto& from = static_cast<const ProtoFlattenedSerializerField_t&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:ProtoFlattenedSerializerField_t)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.polymorphic_types_.MergeFrom(from._impl_.polymorphic_types_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.var_type_sym_ = from._impl_.var_type_sym_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.var_name_sym_ = from._impl_.var_name_sym_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.bit_count_ = from._impl_.bit_count_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.low_value_ = from._impl_.low_value_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.high_value_ = from._impl_.high_value_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.encode_flags_ = from._impl_.encode_flags_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.field_serializer_name_sym_ = from._impl_.field_serializer_name_sym_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.field_serializer_version_ = from._impl_.field_serializer_version_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000700u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.send_node_sym_ = from._impl_.send_node_sym_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.var_encoder_sym_ = from._impl_.var_encoder_sym_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.var_serializer_sym_ = from._impl_.var_serializer_sym_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ProtoFlattenedSerializerField_t::CopyFrom(const ProtoFlattenedSerializerField_t& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ProtoFlattenedSerializerField_t)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ProtoFlattenedSerializerField_t::IsInitialized() const {
  return true;
}

void ProtoFlattenedSerializerField_t::InternalSwap(ProtoFlattenedSerializerField_t* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.polymorphic_types_.InternalSwap(&other->_impl_.polymorphic_types_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ProtoFlattenedSerializerField_t, _impl_.var_serializer_sym_)
      + sizeof(ProtoFlattenedSerializerField_t::_impl_.var_serializer_sym_)
      - PROTOBUF_FIELD_OFFSET(ProtoFlattenedSerializerField_t, _impl_.var_type_sym_)>(
          reinterpret_cast<char*>(&_impl_.var_type_sym_),
          reinterpret_cast<char*>(&other->_impl_.var_type_sym_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ProtoFlattenedSerializerField_t::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[57]);
}

// ===================================================================

class ProtoFlattenedSerializer_t::_Internal {
 public:
  using HasBits = decltype(std::declval<ProtoFlattenedSerializer_t>()._impl_._has_bits_);
  static void set_has_serializer_name_sym(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_serializer_version(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

ProtoFlattenedSerializer_t::ProtoFlattenedSerializer_t(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:ProtoFlattenedSerializer_t)
}
ProtoFlattenedSerializer_t::ProtoFlattenedSerializer_t(const ProtoFlattenedSerializer_t& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  ProtoFlattenedSerializer_t* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.fields_index_){from._impl_.fields_index_}
    , decltype(_impl_.serializer_name_sym_){}
    , decltype(_impl_.serializer_version_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.serializer_name_sym_, &from._impl_.serializer_name_sym_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.serializer_version_) -
    reinterpret_cast<char*>(&_impl_.serializer_name_sym_)) + sizeof(_impl_.serializer_version_));
  // @@protoc_insertion_point(copy_constructor:ProtoFlattenedSerializer_t)
}

inline void ProtoFlattenedSerializer_t::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.fields_index_){arena}
    , decltype(_impl_.serializer_name_sym_){0}
    , decltype(_impl_.serializer_version_){0}
  };
}

ProtoFlattenedSerializer_t::~ProtoFlattenedSerializer_t() {
  // @@protoc_insertion_point(destructor:ProtoFlattenedSerializer_t)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ProtoFlattenedSerializer_t::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.fields_index_.~RepeatedField();
}

void ProtoFlattenedSerializer_t::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void ProtoFlattenedSerializer_t::Clear() {
// @@protoc_insertion_point(message_clear_start:ProtoFlattenedSerializer_t)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.fields_index_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.serializer_name_sym_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.serializer_version_) -
        reinterpret_cast<char*>(&_impl_.serializer_name_sym_)) + sizeof(_impl_.serializer_version_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* ProtoFlattenedSerializer_t::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 serializer_name_sym = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_serializer_name_sym(&has_bits);
          _impl_.serializer_name_sym_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 serializer_version = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_serializer_version(&has_bits);
          _impl_.serializer_version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated int32 fields_index = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_fields_index(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<24>(ptr));
        } else if (static_cast<uint8_t>(tag) == 26) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_fields_index(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ProtoFlattenedSerializer_t::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:ProtoFlattenedSerializer_t)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 serializer_name_sym = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_serializer_name_sym(), target);
  }

  // optional int32 serializer_version = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_serializer_version(), target);
  }

  // repeated int32 fields_index = 3;
  for (int i = 0, n = this->_internal_fields_index_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_fields_index(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:ProtoFlattenedSerializer_t)
  return target;
}

size_t ProtoFlattenedSerializer_t::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:ProtoFlattenedSerializer_t)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int32 fields_index = 3;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int32Size(this->_impl_.fields_index_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_fields_index_size());
    total_size += data_size;
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional int32 serializer_name_sym = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_serializer_name_sym());
    }

    // optional int32 serializer_version = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_serializer_version());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData ProtoFlattenedSerializer_t::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    ProtoFlattenedSerializer_t::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*ProtoFlattenedSerializer_t::GetClassData() const { return &_class_data_; }


void ProtoFlattenedSerializer_t::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<ProtoFlattenedSerializer_t*>(&to_msg);
  auto& from = static_cast<const ProtoFlattenedSerializer_t&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:ProtoFlattenedSerializer_t)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.fields_index_.MergeFrom(from._impl_.fields_index_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.serializer_name_sym_ = from._impl_.serializer_name_sym_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.serializer_version_ = from._impl_.serializer_version_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void ProtoFlattenedSerializer_t::CopyFrom(const ProtoFlattenedSerializer_t& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:ProtoFlattenedSerializer_t)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ProtoFlattenedSerializer_t::IsInitialized() const {
  return true;
}

void ProtoFlattenedSerializer_t::InternalSwap(ProtoFlattenedSerializer_t* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.fields_index_.InternalSwap(&other->_impl_.fields_index_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(ProtoFlattenedSerializer_t, _impl_.serializer_version_)
      + sizeof(ProtoFlattenedSerializer_t::_impl_.serializer_version_)
      - PROTOBUF_FIELD_OFFSET(ProtoFlattenedSerializer_t, _impl_.serializer_name_sym_)>(
          reinterpret_cast<char*>(&_impl_.serializer_name_sym_),
          reinterpret_cast<char*>(&other->_impl_.serializer_name_sym_));
}

::PROTOBUF_NAMESPACE_ID::Metadata ProtoFlattenedSerializer_t::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[58]);
}

// ===================================================================

class CSVCMsg_FlattenedSerializer::_Internal {
 public:
};

CSVCMsg_FlattenedSerializer::CSVCMsg_FlattenedSerializer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CSVCMsg_FlattenedSerializer)
}
CSVCMsg_FlattenedSerializer::CSVCMsg_FlattenedSerializer(const CSVCMsg_FlattenedSerializer& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CSVCMsg_FlattenedSerializer* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.serializers_){from._impl_.serializers_}
    , decltype(_impl_.symbols_){from._impl_.symbols_}
    , decltype(_impl_.fields_){from._impl_.fields_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:CSVCMsg_FlattenedSerializer)
}

inline void CSVCMsg_FlattenedSerializer::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.serializers_){arena}
    , decltype(_impl_.symbols_){arena}
    , decltype(_impl_.fields_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

CSVCMsg_FlattenedSerializer::~CSVCMsg_FlattenedSerializer() {
  // @@protoc_insertion_point(destructor:CSVCMsg_FlattenedSerializer)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CSVCMsg_FlattenedSerializer::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.serializers_.~RepeatedPtrField();
  _impl_.symbols_.~RepeatedPtrField();
  _impl_.fields_.~RepeatedPtrField();
}

void CSVCMsg_FlattenedSerializer::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CSVCMsg_FlattenedSerializer::Clear() {
// @@protoc_insertion_point(message_clear_start:CSVCMsg_FlattenedSerializer)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.serializers_.Clear();
  _impl_.symbols_.Clear();
  _impl_.fields_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSVCMsg_FlattenedSerializer::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .ProtoFlattenedSerializer_t serializers = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_serializers(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated string symbols = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_symbols();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            #ifndef NDEBUG
            ::_pbi::VerifyUTF8(str, "CSVCMsg_FlattenedSerializer.symbols");
            #endif  // !NDEBUG
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .ProtoFlattenedSerializerField_t fields = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_fields(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSVCMsg_FlattenedSerializer::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CSVCMsg_FlattenedSerializer)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .ProtoFlattenedSerializer_t serializers = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_serializers_size()); i < n; i++) {
    const auto& repfield = this->_internal_serializers(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated string symbols = 2;
  for (int i = 0, n = this->_internal_symbols_size(); i < n; i++) {
    const auto& s = this->_internal_symbols(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CSVCMsg_FlattenedSerializer.symbols");
    target = stream->WriteString(2, s, target);
  }

  // repeated .ProtoFlattenedSerializerField_t fields = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_fields_size()); i < n; i++) {
    const auto& repfield = this->_internal_fields(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CSVCMsg_FlattenedSerializer)
  return target;
}

size_t CSVCMsg_FlattenedSerializer::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CSVCMsg_FlattenedSerializer)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .ProtoFlattenedSerializer_t serializers = 1;
  total_size += 1UL * this->_internal_serializers_size();
  for (const auto& msg : this->_impl_.serializers_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated string symbols = 2;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.symbols_.size());
  for (int i = 0, n = _impl_.symbols_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.symbols_.Get(i));
  }

  // repeated .ProtoFlattenedSerializerField_t fields = 3;
  total_size += 1UL * this->_internal_fields_size();
  for (const auto& msg : this->_impl_.fields_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSVCMsg_FlattenedSerializer::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CSVCMsg_FlattenedSerializer::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSVCMsg_FlattenedSerializer::GetClassData() const { return &_class_data_; }


void CSVCMsg_FlattenedSerializer::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CSVCMsg_FlattenedSerializer*>(&to_msg);
  auto& from = static_cast<const CSVCMsg_FlattenedSerializer&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CSVCMsg_FlattenedSerializer)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.serializers_.MergeFrom(from._impl_.serializers_);
  _this->_impl_.symbols_.MergeFrom(from._impl_.symbols_);
  _this->_impl_.fields_.MergeFrom(from._impl_.fields_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSVCMsg_FlattenedSerializer::CopyFrom(const CSVCMsg_FlattenedSerializer& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CSVCMsg_FlattenedSerializer)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSVCMsg_FlattenedSerializer::IsInitialized() const {
  return true;
}

void CSVCMsg_FlattenedSerializer::InternalSwap(CSVCMsg_FlattenedSerializer* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.serializers_.InternalSwap(&other->_impl_.serializers_);
  _impl_.symbols_.InternalSwap(&other->_impl_.symbols_);
  _impl_.fields_.InternalSwap(&other->_impl_.fields_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CSVCMsg_FlattenedSerializer::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[59]);
}

// ===================================================================

class CSVCMsg_StopSound::_Internal {
 public:
  using HasBits = decltype(std::declval<CSVCMsg_StopSound>()._impl_._has_bits_);
  static void set_has_guid(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CSVCMsg_StopSound::CSVCMsg_StopSound(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CSVCMsg_StopSound)
}
CSVCMsg_StopSound::CSVCMsg_StopSound(const CSVCMsg_StopSound& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CSVCMsg_StopSound* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.guid_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.guid_ = from._impl_.guid_;
  // @@protoc_insertion_point(copy_constructor:CSVCMsg_StopSound)
}

inline void CSVCMsg_StopSound::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.guid_){0u}
  };
}

CSVCMsg_StopSound::~CSVCMsg_StopSound() {
  // @@protoc_insertion_point(destructor:CSVCMsg_StopSound)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CSVCMsg_StopSound::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CSVCMsg_StopSound::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CSVCMsg_StopSound::Clear() {
// @@protoc_insertion_point(message_clear_start:CSVCMsg_StopSound)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.guid_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSVCMsg_StopSound::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional fixed32 guid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          _Internal::set_has_guid(&has_bits);
          _impl_.guid_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSVCMsg_StopSound::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CSVCMsg_StopSound)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional fixed32 guid = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(1, this->_internal_guid(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CSVCMsg_StopSound)
  return target;
}

size_t CSVCMsg_StopSound::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CSVCMsg_StopSound)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional fixed32 guid = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 + 4;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSVCMsg_StopSound::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CSVCMsg_StopSound::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSVCMsg_StopSound::GetClassData() const { return &_class_data_; }


void CSVCMsg_StopSound::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CSVCMsg_StopSound*>(&to_msg);
  auto& from = static_cast<const CSVCMsg_StopSound&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CSVCMsg_StopSound)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_guid()) {
    _this->_internal_set_guid(from._internal_guid());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSVCMsg_StopSound::CopyFrom(const CSVCMsg_StopSound& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CSVCMsg_StopSound)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSVCMsg_StopSound::IsInitialized() const {
  return true;
}

void CSVCMsg_StopSound::InternalSwap(CSVCMsg_StopSound* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.guid_, other->_impl_.guid_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CSVCMsg_StopSound::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[60]);
}

// ===================================================================

class CBidirMsg_RebroadcastGameEvent::_Internal {
 public:
  using HasBits = decltype(std::declval<CBidirMsg_RebroadcastGameEvent>()._impl_._has_bits_);
  static void set_has_posttoserver(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_buftype(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_clientbitcount(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_receivingclients(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

CBidirMsg_RebroadcastGameEvent::CBidirMsg_RebroadcastGameEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CBidirMsg_RebroadcastGameEvent)
}
CBidirMsg_RebroadcastGameEvent::CBidirMsg_RebroadcastGameEvent(const CBidirMsg_RebroadcastGameEvent& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CBidirMsg_RebroadcastGameEvent* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.posttoserver_){}
    , decltype(_impl_.buftype_){}
    , decltype(_impl_.receivingclients_){}
    , decltype(_impl_.clientbitcount_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.posttoserver_, &from._impl_.posttoserver_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.clientbitcount_) -
    reinterpret_cast<char*>(&_impl_.posttoserver_)) + sizeof(_impl_.clientbitcount_));
  // @@protoc_insertion_point(copy_constructor:CBidirMsg_RebroadcastGameEvent)
}

inline void CBidirMsg_RebroadcastGameEvent::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.posttoserver_){false}
    , decltype(_impl_.buftype_){0}
    , decltype(_impl_.receivingclients_){uint64_t{0u}}
    , decltype(_impl_.clientbitcount_){0u}
  };
}

CBidirMsg_RebroadcastGameEvent::~CBidirMsg_RebroadcastGameEvent() {
  // @@protoc_insertion_point(destructor:CBidirMsg_RebroadcastGameEvent)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CBidirMsg_RebroadcastGameEvent::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CBidirMsg_RebroadcastGameEvent::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CBidirMsg_RebroadcastGameEvent::Clear() {
// @@protoc_insertion_point(message_clear_start:CBidirMsg_RebroadcastGameEvent)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&_impl_.posttoserver_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.clientbitcount_) -
        reinterpret_cast<char*>(&_impl_.posttoserver_)) + sizeof(_impl_.clientbitcount_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CBidirMsg_RebroadcastGameEvent::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool posttoserver = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_posttoserver(&has_bits);
          _impl_.posttoserver_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 buftype = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_buftype(&has_bits);
          _impl_.buftype_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 clientbitcount = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_clientbitcount(&has_bits);
          _impl_.clientbitcount_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 receivingclients = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_receivingclients(&has_bits);
          _impl_.receivingclients_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CBidirMsg_RebroadcastGameEvent::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CBidirMsg_RebroadcastGameEvent)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool posttoserver = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_posttoserver(), target);
  }

  // optional int32 buftype = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_buftype(), target);
  }

  // optional uint32 clientbitcount = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_clientbitcount(), target);
  }

  // optional uint64 receivingclients = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(4, this->_internal_receivingclients(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CBidirMsg_RebroadcastGameEvent)
  return target;
}

size_t CBidirMsg_RebroadcastGameEvent::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CBidirMsg_RebroadcastGameEvent)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional bool posttoserver = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 1;
    }

    // optional int32 buftype = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_buftype());
    }

    // optional uint64 receivingclients = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_receivingclients());
    }

    // optional uint32 clientbitcount = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_clientbitcount());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CBidirMsg_RebroadcastGameEvent::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CBidirMsg_RebroadcastGameEvent::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CBidirMsg_RebroadcastGameEvent::GetClassData() const { return &_class_data_; }


void CBidirMsg_RebroadcastGameEvent::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CBidirMsg_RebroadcastGameEvent*>(&to_msg);
  auto& from = static_cast<const CBidirMsg_RebroadcastGameEvent&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CBidirMsg_RebroadcastGameEvent)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.posttoserver_ = from._impl_.posttoserver_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.buftype_ = from._impl_.buftype_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.receivingclients_ = from._impl_.receivingclients_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.clientbitcount_ = from._impl_.clientbitcount_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CBidirMsg_RebroadcastGameEvent::CopyFrom(const CBidirMsg_RebroadcastGameEvent& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CBidirMsg_RebroadcastGameEvent)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CBidirMsg_RebroadcastGameEvent::IsInitialized() const {
  return true;
}

void CBidirMsg_RebroadcastGameEvent::InternalSwap(CBidirMsg_RebroadcastGameEvent* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CBidirMsg_RebroadcastGameEvent, _impl_.clientbitcount_)
      + sizeof(CBidirMsg_RebroadcastGameEvent::_impl_.clientbitcount_)
      - PROTOBUF_FIELD_OFFSET(CBidirMsg_RebroadcastGameEvent, _impl_.posttoserver_)>(
          reinterpret_cast<char*>(&_impl_.posttoserver_),
          reinterpret_cast<char*>(&other->_impl_.posttoserver_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CBidirMsg_RebroadcastGameEvent::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[61]);
}

// ===================================================================

class CBidirMsg_RebroadcastSource::_Internal {
 public:
  using HasBits = decltype(std::declval<CBidirMsg_RebroadcastSource>()._impl_._has_bits_);
  static void set_has_eventsource(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CBidirMsg_RebroadcastSource::CBidirMsg_RebroadcastSource(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CBidirMsg_RebroadcastSource)
}
CBidirMsg_RebroadcastSource::CBidirMsg_RebroadcastSource(const CBidirMsg_RebroadcastSource& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CBidirMsg_RebroadcastSource* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.eventsource_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.eventsource_ = from._impl_.eventsource_;
  // @@protoc_insertion_point(copy_constructor:CBidirMsg_RebroadcastSource)
}

inline void CBidirMsg_RebroadcastSource::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.eventsource_){0}
  };
}

CBidirMsg_RebroadcastSource::~CBidirMsg_RebroadcastSource() {
  // @@protoc_insertion_point(destructor:CBidirMsg_RebroadcastSource)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CBidirMsg_RebroadcastSource::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CBidirMsg_RebroadcastSource::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CBidirMsg_RebroadcastSource::Clear() {
// @@protoc_insertion_point(message_clear_start:CBidirMsg_RebroadcastSource)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.eventsource_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CBidirMsg_RebroadcastSource::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 eventsource = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_eventsource(&has_bits);
          _impl_.eventsource_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CBidirMsg_RebroadcastSource::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CBidirMsg_RebroadcastSource)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 eventsource = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_eventsource(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CBidirMsg_RebroadcastSource)
  return target;
}

size_t CBidirMsg_RebroadcastSource::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CBidirMsg_RebroadcastSource)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional int32 eventsource = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_eventsource());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CBidirMsg_RebroadcastSource::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CBidirMsg_RebroadcastSource::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CBidirMsg_RebroadcastSource::GetClassData() const { return &_class_data_; }


void CBidirMsg_RebroadcastSource::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CBidirMsg_RebroadcastSource*>(&to_msg);
  auto& from = static_cast<const CBidirMsg_RebroadcastSource&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CBidirMsg_RebroadcastSource)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_eventsource()) {
    _this->_internal_set_eventsource(from._internal_eventsource());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CBidirMsg_RebroadcastSource::CopyFrom(const CBidirMsg_RebroadcastSource& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CBidirMsg_RebroadcastSource)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CBidirMsg_RebroadcastSource::IsInitialized() const {
  return true;
}

void CBidirMsg_RebroadcastSource::InternalSwap(CBidirMsg_RebroadcastSource* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.eventsource_, other->_impl_.eventsource_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CBidirMsg_RebroadcastSource::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[62]);
}

// ===================================================================

class CMsgServerNetworkStats_Port::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgServerNetworkStats_Port>()._impl_._has_bits_);
  static void set_has_port(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CMsgServerNetworkStats_Port::CMsgServerNetworkStats_Port(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgServerNetworkStats.Port)
}
CMsgServerNetworkStats_Port::CMsgServerNetworkStats_Port(const CMsgServerNetworkStats_Port& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgServerNetworkStats_Port* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.port_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.port_ = from._impl_.port_;
  // @@protoc_insertion_point(copy_constructor:CMsgServerNetworkStats.Port)
}

inline void CMsgServerNetworkStats_Port::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.name_){}
    , decltype(_impl_.port_){0}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgServerNetworkStats_Port::~CMsgServerNetworkStats_Port() {
  // @@protoc_insertion_point(destructor:CMsgServerNetworkStats.Port)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgServerNetworkStats_Port::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.name_.Destroy();
}

void CMsgServerNetworkStats_Port::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgServerNetworkStats_Port::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgServerNetworkStats.Port)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.name_.ClearNonDefaultToEmpty();
  }
  _impl_.port_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgServerNetworkStats_Port::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 port = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_port(&has_bits);
          _impl_.port_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgServerNetworkStats.Port.name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgServerNetworkStats_Port::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgServerNetworkStats.Port)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 port = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_port(), target);
  }

  // optional string name = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgServerNetworkStats.Port.name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgServerNetworkStats.Port)
  return target;
}

size_t CMsgServerNetworkStats_Port::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgServerNetworkStats.Port)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string name = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional int32 port = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_port());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgServerNetworkStats_Port::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgServerNetworkStats_Port::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgServerNetworkStats_Port::GetClassData() const { return &_class_data_; }


void CMsgServerNetworkStats_Port::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgServerNetworkStats_Port*>(&to_msg);
  auto& from = static_cast<const CMsgServerNetworkStats_Port&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgServerNetworkStats.Port)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.port_ = from._impl_.port_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgServerNetworkStats_Port::CopyFrom(const CMsgServerNetworkStats_Port& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgServerNetworkStats.Port)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgServerNetworkStats_Port::IsInitialized() const {
  return true;
}

void CMsgServerNetworkStats_Port::InternalSwap(CMsgServerNetworkStats_Port* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  swap(_impl_.port_, other->_impl_.port_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgServerNetworkStats_Port::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[63]);
}

// ===================================================================

class CMsgServerNetworkStats_Player::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgServerNetworkStats_Player>()._impl_._has_bits_);
  static void set_has_steamid(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_remote_addr(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_ping_avg_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_packet_loss_pct(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_is_bot(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_loss_in(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_loss_out(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_engine_latency_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
};

CMsgServerNetworkStats_Player::CMsgServerNetworkStats_Player(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgServerNetworkStats.Player)
}
CMsgServerNetworkStats_Player::CMsgServerNetworkStats_Player(const CMsgServerNetworkStats_Player& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgServerNetworkStats_Player* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.remote_addr_){}
    , decltype(_impl_.steamid_){}
    , decltype(_impl_.ping_avg_ms_){}
    , decltype(_impl_.packet_loss_pct_){}
    , decltype(_impl_.is_bot_){}
    , decltype(_impl_.loss_in_){}
    , decltype(_impl_.loss_out_){}
    , decltype(_impl_.engine_latency_ms_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.remote_addr_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.remote_addr_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_remote_addr()) {
    _this->_impl_.remote_addr_.Set(from._internal_remote_addr(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.steamid_, &from._impl_.steamid_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.engine_latency_ms_) -
    reinterpret_cast<char*>(&_impl_.steamid_)) + sizeof(_impl_.engine_latency_ms_));
  // @@protoc_insertion_point(copy_constructor:CMsgServerNetworkStats.Player)
}

inline void CMsgServerNetworkStats_Player::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.remote_addr_){}
    , decltype(_impl_.steamid_){uint64_t{0u}}
    , decltype(_impl_.ping_avg_ms_){0}
    , decltype(_impl_.packet_loss_pct_){0}
    , decltype(_impl_.is_bot_){false}
    , decltype(_impl_.loss_in_){0}
    , decltype(_impl_.loss_out_){0}
    , decltype(_impl_.engine_latency_ms_){0}
  };
  _impl_.remote_addr_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.remote_addr_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgServerNetworkStats_Player::~CMsgServerNetworkStats_Player() {
  // @@protoc_insertion_point(destructor:CMsgServerNetworkStats.Player)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgServerNetworkStats_Player::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.remote_addr_.Destroy();
}

void CMsgServerNetworkStats_Player::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgServerNetworkStats_Player::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgServerNetworkStats.Player)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.remote_addr_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x000000feu) {
    ::memset(&_impl_.steamid_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.engine_latency_ms_) -
        reinterpret_cast<char*>(&_impl_.steamid_)) + sizeof(_impl_.engine_latency_ms_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgServerNetworkStats_Player::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint64 steamid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_steamid(&has_bits);
          _impl_.steamid_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string remote_addr = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_remote_addr();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgServerNetworkStats.Player.remote_addr");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional int32 ping_avg_ms = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_ping_avg_ms(&has_bits);
          _impl_.ping_avg_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float packet_loss_pct = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 45)) {
          _Internal::set_has_packet_loss_pct(&has_bits);
          _impl_.packet_loss_pct_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_bot = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_is_bot(&has_bits);
          _impl_.is_bot_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float loss_in = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 61)) {
          _Internal::set_has_loss_in(&has_bits);
          _impl_.loss_in_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float loss_out = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 69)) {
          _Internal::set_has_loss_out(&has_bits);
          _impl_.loss_out_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional int32 engine_latency_ms = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_engine_latency_ms(&has_bits);
          _impl_.engine_latency_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgServerNetworkStats_Player::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgServerNetworkStats.Player)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint64 steamid = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(1, this->_internal_steamid(), target);
  }

  // optional string remote_addr = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_remote_addr().data(), static_cast<int>(this->_internal_remote_addr().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgServerNetworkStats.Player.remote_addr");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_remote_addr(), target);
  }

  // optional int32 ping_avg_ms = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_ping_avg_ms(), target);
  }

  // optional float packet_loss_pct = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(5, this->_internal_packet_loss_pct(), target);
  }

  // optional bool is_bot = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_is_bot(), target);
  }

  // optional float loss_in = 7;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(7, this->_internal_loss_in(), target);
  }

  // optional float loss_out = 8;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(8, this->_internal_loss_out(), target);
  }

  // optional int32 engine_latency_ms = 9;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(9, this->_internal_engine_latency_ms(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgServerNetworkStats.Player)
  return target;
}

size_t CMsgServerNetworkStats_Player::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgServerNetworkStats.Player)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string remote_addr = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_remote_addr());
    }

    // optional uint64 steamid = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt64SizePlusOne(this->_internal_steamid());
    }

    // optional int32 ping_avg_ms = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_ping_avg_ms());
    }

    // optional float packet_loss_pct = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 4;
    }

    // optional bool is_bot = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 1;
    }

    // optional float loss_in = 7;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 4;
    }

    // optional float loss_out = 8;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 4;
    }

    // optional int32 engine_latency_ms = 9;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_engine_latency_ms());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgServerNetworkStats_Player::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgServerNetworkStats_Player::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgServerNetworkStats_Player::GetClassData() const { return &_class_data_; }


void CMsgServerNetworkStats_Player::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgServerNetworkStats_Player*>(&to_msg);
  auto& from = static_cast<const CMsgServerNetworkStats_Player&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgServerNetworkStats.Player)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_remote_addr(from._internal_remote_addr());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.steamid_ = from._impl_.steamid_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.ping_avg_ms_ = from._impl_.ping_avg_ms_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.packet_loss_pct_ = from._impl_.packet_loss_pct_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.is_bot_ = from._impl_.is_bot_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.loss_in_ = from._impl_.loss_in_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.loss_out_ = from._impl_.loss_out_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.engine_latency_ms_ = from._impl_.engine_latency_ms_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgServerNetworkStats_Player::CopyFrom(const CMsgServerNetworkStats_Player& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgServerNetworkStats.Player)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgServerNetworkStats_Player::IsInitialized() const {
  return true;
}

void CMsgServerNetworkStats_Player::InternalSwap(CMsgServerNetworkStats_Player* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.remote_addr_, lhs_arena,
      &other->_impl_.remote_addr_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgServerNetworkStats_Player, _impl_.engine_latency_ms_)
      + sizeof(CMsgServerNetworkStats_Player::_impl_.engine_latency_ms_)
      - PROTOBUF_FIELD_OFFSET(CMsgServerNetworkStats_Player, _impl_.steamid_)>(
          reinterpret_cast<char*>(&_impl_.steamid_),
          reinterpret_cast<char*>(&other->_impl_.steamid_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgServerNetworkStats_Player::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[64]);
}

// ===================================================================

class CMsgServerNetworkStats::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgServerNetworkStats>()._impl_._has_bits_);
  static void set_has_dedicated(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_cpu_usage(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_memory_used_mb(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_memory_free_mb(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_uptime(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_spawn_count(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_num_clients(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_num_bots(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_num_spectators(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_num_tv_relays(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_fps(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_avg_ping_ms(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_avg_engine_latency_out(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_avg_packets_out(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_avg_packets_in(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_avg_loss_out(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_avg_loss_in(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
  static void set_has_avg_data_out(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
  static void set_has_avg_data_in(HasBits* has_bits) {
    (*has_bits)[0] |= 4194304u;
  }
  static void set_has_total_data_in(HasBits* has_bits) {
    (*has_bits)[0] |= 262144u;
  }
  static void set_has_total_packets_in(HasBits* has_bits) {
    (*has_bits)[0] |= 524288u;
  }
  static void set_has_total_data_out(HasBits* has_bits) {
    (*has_bits)[0] |= 1048576u;
  }
  static void set_has_total_packets_out(HasBits* has_bits) {
    (*has_bits)[0] |= 2097152u;
  }
};

CMsgServerNetworkStats::CMsgServerNetworkStats(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgServerNetworkStats)
}
CMsgServerNetworkStats::CMsgServerNetworkStats(const CMsgServerNetworkStats& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgServerNetworkStats* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ports_){from._impl_.ports_}
    , decltype(_impl_.players_){from._impl_.players_}
    , decltype(_impl_.dedicated_){}
    , decltype(_impl_.cpu_usage_){}
    , decltype(_impl_.memory_used_mb_){}
    , decltype(_impl_.memory_free_mb_){}
    , decltype(_impl_.uptime_){}
    , decltype(_impl_.spawn_count_){}
    , decltype(_impl_.num_clients_){}
    , decltype(_impl_.num_bots_){}
    , decltype(_impl_.num_spectators_){}
    , decltype(_impl_.num_tv_relays_){}
    , decltype(_impl_.fps_){}
    , decltype(_impl_.avg_ping_ms_){}
    , decltype(_impl_.avg_engine_latency_out_){}
    , decltype(_impl_.avg_packets_out_){}
    , decltype(_impl_.avg_packets_in_){}
    , decltype(_impl_.avg_loss_out_){}
    , decltype(_impl_.avg_loss_in_){}
    , decltype(_impl_.avg_data_out_){}
    , decltype(_impl_.total_data_in_){}
    , decltype(_impl_.total_packets_in_){}
    , decltype(_impl_.total_data_out_){}
    , decltype(_impl_.total_packets_out_){}
    , decltype(_impl_.avg_data_in_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.dedicated_, &from._impl_.dedicated_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.avg_data_in_) -
    reinterpret_cast<char*>(&_impl_.dedicated_)) + sizeof(_impl_.avg_data_in_));
  // @@protoc_insertion_point(copy_constructor:CMsgServerNetworkStats)
}

inline void CMsgServerNetworkStats::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.ports_){arena}
    , decltype(_impl_.players_){arena}
    , decltype(_impl_.dedicated_){false}
    , decltype(_impl_.cpu_usage_){0}
    , decltype(_impl_.memory_used_mb_){0}
    , decltype(_impl_.memory_free_mb_){0}
    , decltype(_impl_.uptime_){0}
    , decltype(_impl_.spawn_count_){0}
    , decltype(_impl_.num_clients_){0}
    , decltype(_impl_.num_bots_){0}
    , decltype(_impl_.num_spectators_){0}
    , decltype(_impl_.num_tv_relays_){0}
    , decltype(_impl_.fps_){0}
    , decltype(_impl_.avg_ping_ms_){0}
    , decltype(_impl_.avg_engine_latency_out_){0}
    , decltype(_impl_.avg_packets_out_){0}
    , decltype(_impl_.avg_packets_in_){0}
    , decltype(_impl_.avg_loss_out_){0}
    , decltype(_impl_.avg_loss_in_){0}
    , decltype(_impl_.avg_data_out_){0}
    , decltype(_impl_.total_data_in_){uint64_t{0u}}
    , decltype(_impl_.total_packets_in_){uint64_t{0u}}
    , decltype(_impl_.total_data_out_){uint64_t{0u}}
    , decltype(_impl_.total_packets_out_){uint64_t{0u}}
    , decltype(_impl_.avg_data_in_){0}
  };
}

CMsgServerNetworkStats::~CMsgServerNetworkStats() {
  // @@protoc_insertion_point(destructor:CMsgServerNetworkStats)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgServerNetworkStats::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.ports_.~RepeatedPtrField();
  _impl_.players_.~RepeatedPtrField();
}

void CMsgServerNetworkStats::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgServerNetworkStats::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgServerNetworkStats)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.ports_.Clear();
  _impl_.players_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&_impl_.dedicated_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.num_bots_) -
        reinterpret_cast<char*>(&_impl_.dedicated_)) + sizeof(_impl_.num_bots_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&_impl_.num_spectators_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.avg_loss_out_) -
        reinterpret_cast<char*>(&_impl_.num_spectators_)) + sizeof(_impl_.avg_loss_out_));
  }
  if (cached_has_bits & 0x007f0000u) {
    ::memset(&_impl_.avg_loss_in_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.avg_data_in_) -
        reinterpret_cast<char*>(&_impl_.avg_loss_in_)) + sizeof(_impl_.avg_data_in_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgServerNetworkStats::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional bool dedicated = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_dedicated(&has_bits);
          _impl_.dedicated_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 cpu_usage = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_cpu_usage(&has_bits);
          _impl_.cpu_usage_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 memory_used_mb = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_memory_used_mb(&has_bits);
          _impl_.memory_used_mb_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 memory_free_mb = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_memory_free_mb(&has_bits);
          _impl_.memory_free_mb_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 uptime = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_uptime(&has_bits);
          _impl_.uptime_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 spawn_count = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_spawn_count(&has_bits);
          _impl_.spawn_count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 num_clients = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_num_clients(&has_bits);
          _impl_.num_clients_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 num_bots = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_num_bots(&has_bits);
          _impl_.num_bots_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 num_spectators = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 80)) {
          _Internal::set_has_num_spectators(&has_bits);
          _impl_.num_spectators_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 num_tv_relays = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_num_tv_relays(&has_bits);
          _impl_.num_tv_relays_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float fps = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 101)) {
          _Internal::set_has_fps(&has_bits);
          _impl_.fps_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgServerNetworkStats.Port ports = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 138)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_ports(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<138>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional float avg_ping_ms = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 149)) {
          _Internal::set_has_avg_ping_ms(&has_bits);
          _impl_.avg_ping_ms_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float avg_engine_latency_out = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 157)) {
          _Internal::set_has_avg_engine_latency_out(&has_bits);
          _impl_.avg_engine_latency_out_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float avg_packets_out = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 165)) {
          _Internal::set_has_avg_packets_out(&has_bits);
          _impl_.avg_packets_out_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float avg_packets_in = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 173)) {
          _Internal::set_has_avg_packets_in(&has_bits);
          _impl_.avg_packets_in_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float avg_loss_out = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 181)) {
          _Internal::set_has_avg_loss_out(&has_bits);
          _impl_.avg_loss_out_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float avg_loss_in = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 189)) {
          _Internal::set_has_avg_loss_in(&has_bits);
          _impl_.avg_loss_in_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float avg_data_out = 24;
      case 24:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 197)) {
          _Internal::set_has_avg_data_out(&has_bits);
          _impl_.avg_data_out_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float avg_data_in = 25;
      case 25:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 205)) {
          _Internal::set_has_avg_data_in(&has_bits);
          _impl_.avg_data_in_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 total_data_in = 26;
      case 26:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 208)) {
          _Internal::set_has_total_data_in(&has_bits);
          _impl_.total_data_in_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 total_packets_in = 27;
      case 27:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 216)) {
          _Internal::set_has_total_packets_in(&has_bits);
          _impl_.total_packets_in_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 total_data_out = 28;
      case 28:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 224)) {
          _Internal::set_has_total_data_out(&has_bits);
          _impl_.total_data_out_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint64 total_packets_out = 29;
      case 29:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 232)) {
          _Internal::set_has_total_packets_out(&has_bits);
          _impl_.total_packets_out_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .CMsgServerNetworkStats.Player players = 30;
      case 30:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 242)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_players(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<242>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgServerNetworkStats::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgServerNetworkStats)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional bool dedicated = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(1, this->_internal_dedicated(), target);
  }

  // optional int32 cpu_usage = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_cpu_usage(), target);
  }

  // optional int32 memory_used_mb = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_memory_used_mb(), target);
  }

  // optional int32 memory_free_mb = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_memory_free_mb(), target);
  }

  // optional int32 uptime = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_uptime(), target);
  }

  // optional int32 spawn_count = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(6, this->_internal_spawn_count(), target);
  }

  // optional int32 num_clients = 8;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(8, this->_internal_num_clients(), target);
  }

  // optional int32 num_bots = 9;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(9, this->_internal_num_bots(), target);
  }

  // optional int32 num_spectators = 10;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(10, this->_internal_num_spectators(), target);
  }

  // optional int32 num_tv_relays = 11;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(11, this->_internal_num_tv_relays(), target);
  }

  // optional float fps = 12;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(12, this->_internal_fps(), target);
  }

  // repeated .CMsgServerNetworkStats.Port ports = 17;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_ports_size()); i < n; i++) {
    const auto& repfield = this->_internal_ports(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(17, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional float avg_ping_ms = 18;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(18, this->_internal_avg_ping_ms(), target);
  }

  // optional float avg_engine_latency_out = 19;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(19, this->_internal_avg_engine_latency_out(), target);
  }

  // optional float avg_packets_out = 20;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(20, this->_internal_avg_packets_out(), target);
  }

  // optional float avg_packets_in = 21;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(21, this->_internal_avg_packets_in(), target);
  }

  // optional float avg_loss_out = 22;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(22, this->_internal_avg_loss_out(), target);
  }

  // optional float avg_loss_in = 23;
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(23, this->_internal_avg_loss_in(), target);
  }

  // optional float avg_data_out = 24;
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(24, this->_internal_avg_data_out(), target);
  }

  // optional float avg_data_in = 25;
  if (cached_has_bits & 0x00400000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(25, this->_internal_avg_data_in(), target);
  }

  // optional uint64 total_data_in = 26;
  if (cached_has_bits & 0x00040000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(26, this->_internal_total_data_in(), target);
  }

  // optional uint64 total_packets_in = 27;
  if (cached_has_bits & 0x00080000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(27, this->_internal_total_packets_in(), target);
  }

  // optional uint64 total_data_out = 28;
  if (cached_has_bits & 0x00100000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(28, this->_internal_total_data_out(), target);
  }

  // optional uint64 total_packets_out = 29;
  if (cached_has_bits & 0x00200000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt64ToArray(29, this->_internal_total_packets_out(), target);
  }

  // repeated .CMsgServerNetworkStats.Player players = 30;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_players_size()); i < n; i++) {
    const auto& repfield = this->_internal_players(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(30, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgServerNetworkStats)
  return target;
}

size_t CMsgServerNetworkStats::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgServerNetworkStats)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .CMsgServerNetworkStats.Port ports = 17;
  total_size += 2UL * this->_internal_ports_size();
  for (const auto& msg : this->_impl_.ports_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .CMsgServerNetworkStats.Player players = 30;
  total_size += 2UL * this->_internal_players_size();
  for (const auto& msg : this->_impl_.players_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional bool dedicated = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 1;
    }

    // optional int32 cpu_usage = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_cpu_usage());
    }

    // optional int32 memory_used_mb = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_memory_used_mb());
    }

    // optional int32 memory_free_mb = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_memory_free_mb());
    }

    // optional int32 uptime = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_uptime());
    }

    // optional int32 spawn_count = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_spawn_count());
    }

    // optional int32 num_clients = 8;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_num_clients());
    }

    // optional int32 num_bots = 9;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_num_bots());
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional int32 num_spectators = 10;
    if (cached_has_bits & 0x00000100u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_num_spectators());
    }

    // optional int32 num_tv_relays = 11;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_num_tv_relays());
    }

    // optional float fps = 12;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 + 4;
    }

    // optional float avg_ping_ms = 18;
    if (cached_has_bits & 0x00000800u) {
      total_size += 2 + 4;
    }

    // optional float avg_engine_latency_out = 19;
    if (cached_has_bits & 0x00001000u) {
      total_size += 2 + 4;
    }

    // optional float avg_packets_out = 20;
    if (cached_has_bits & 0x00002000u) {
      total_size += 2 + 4;
    }

    // optional float avg_packets_in = 21;
    if (cached_has_bits & 0x00004000u) {
      total_size += 2 + 4;
    }

    // optional float avg_loss_out = 22;
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 + 4;
    }

  }
  if (cached_has_bits & 0x007f0000u) {
    // optional float avg_loss_in = 23;
    if (cached_has_bits & 0x00010000u) {
      total_size += 2 + 4;
    }

    // optional float avg_data_out = 24;
    if (cached_has_bits & 0x00020000u) {
      total_size += 2 + 4;
    }

    // optional uint64 total_data_in = 26;
    if (cached_has_bits & 0x00040000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt64Size(
          this->_internal_total_data_in());
    }

    // optional uint64 total_packets_in = 27;
    if (cached_has_bits & 0x00080000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt64Size(
          this->_internal_total_packets_in());
    }

    // optional uint64 total_data_out = 28;
    if (cached_has_bits & 0x00100000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt64Size(
          this->_internal_total_data_out());
    }

    // optional uint64 total_packets_out = 29;
    if (cached_has_bits & 0x00200000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt64Size(
          this->_internal_total_packets_out());
    }

    // optional float avg_data_in = 25;
    if (cached_has_bits & 0x00400000u) {
      total_size += 2 + 4;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgServerNetworkStats::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgServerNetworkStats::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgServerNetworkStats::GetClassData() const { return &_class_data_; }


void CMsgServerNetworkStats::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgServerNetworkStats*>(&to_msg);
  auto& from = static_cast<const CMsgServerNetworkStats&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgServerNetworkStats)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.ports_.MergeFrom(from._impl_.ports_);
  _this->_impl_.players_.MergeFrom(from._impl_.players_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.dedicated_ = from._impl_.dedicated_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.cpu_usage_ = from._impl_.cpu_usage_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.memory_used_mb_ = from._impl_.memory_used_mb_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.memory_free_mb_ = from._impl_.memory_free_mb_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.uptime_ = from._impl_.uptime_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.spawn_count_ = from._impl_.spawn_count_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.num_clients_ = from._impl_.num_clients_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.num_bots_ = from._impl_.num_bots_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.num_spectators_ = from._impl_.num_spectators_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.num_tv_relays_ = from._impl_.num_tv_relays_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.fps_ = from._impl_.fps_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.avg_ping_ms_ = from._impl_.avg_ping_ms_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.avg_engine_latency_out_ = from._impl_.avg_engine_latency_out_;
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.avg_packets_out_ = from._impl_.avg_packets_out_;
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_impl_.avg_packets_in_ = from._impl_.avg_packets_in_;
    }
    if (cached_has_bits & 0x00008000u) {
      _this->_impl_.avg_loss_out_ = from._impl_.avg_loss_out_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x007f0000u) {
    if (cached_has_bits & 0x00010000u) {
      _this->_impl_.avg_loss_in_ = from._impl_.avg_loss_in_;
    }
    if (cached_has_bits & 0x00020000u) {
      _this->_impl_.avg_data_out_ = from._impl_.avg_data_out_;
    }
    if (cached_has_bits & 0x00040000u) {
      _this->_impl_.total_data_in_ = from._impl_.total_data_in_;
    }
    if (cached_has_bits & 0x00080000u) {
      _this->_impl_.total_packets_in_ = from._impl_.total_packets_in_;
    }
    if (cached_has_bits & 0x00100000u) {
      _this->_impl_.total_data_out_ = from._impl_.total_data_out_;
    }
    if (cached_has_bits & 0x00200000u) {
      _this->_impl_.total_packets_out_ = from._impl_.total_packets_out_;
    }
    if (cached_has_bits & 0x00400000u) {
      _this->_impl_.avg_data_in_ = from._impl_.avg_data_in_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgServerNetworkStats::CopyFrom(const CMsgServerNetworkStats& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgServerNetworkStats)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgServerNetworkStats::IsInitialized() const {
  return true;
}

void CMsgServerNetworkStats::InternalSwap(CMsgServerNetworkStats* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.ports_.InternalSwap(&other->_impl_.ports_);
  _impl_.players_.InternalSwap(&other->_impl_.players_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgServerNetworkStats, _impl_.avg_data_in_)
      + sizeof(CMsgServerNetworkStats::_impl_.avg_data_in_)
      - PROTOBUF_FIELD_OFFSET(CMsgServerNetworkStats, _impl_.dedicated_)>(
          reinterpret_cast<char*>(&_impl_.dedicated_),
          reinterpret_cast<char*>(&other->_impl_.dedicated_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgServerNetworkStats::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[65]);
}

// ===================================================================

class CSVCMsg_HltvReplay::_Internal {
 public:
  using HasBits = decltype(std::declval<CSVCMsg_HltvReplay>()._impl_._has_bits_);
  static void set_has_delay(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_primary_target(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_replay_stop_at(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_replay_start_at(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_replay_slowdown_begin(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_replay_slowdown_end(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_replay_slowdown_rate(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_reason(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
};

CSVCMsg_HltvReplay::CSVCMsg_HltvReplay(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CSVCMsg_HltvReplay)
}
CSVCMsg_HltvReplay::CSVCMsg_HltvReplay(const CSVCMsg_HltvReplay& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CSVCMsg_HltvReplay* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.delay_){}
    , decltype(_impl_.replay_stop_at_){}
    , decltype(_impl_.replay_start_at_){}
    , decltype(_impl_.replay_slowdown_begin_){}
    , decltype(_impl_.replay_slowdown_end_){}
    , decltype(_impl_.replay_slowdown_rate_){}
    , decltype(_impl_.reason_){}
    , decltype(_impl_.primary_target_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.delay_, &from._impl_.delay_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.primary_target_) -
    reinterpret_cast<char*>(&_impl_.delay_)) + sizeof(_impl_.primary_target_));
  // @@protoc_insertion_point(copy_constructor:CSVCMsg_HltvReplay)
}

inline void CSVCMsg_HltvReplay::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.delay_){0}
    , decltype(_impl_.replay_stop_at_){0}
    , decltype(_impl_.replay_start_at_){0}
    , decltype(_impl_.replay_slowdown_begin_){0}
    , decltype(_impl_.replay_slowdown_end_){0}
    , decltype(_impl_.replay_slowdown_rate_){0}
    , decltype(_impl_.reason_){0}
    , decltype(_impl_.primary_target_){-1}
  };
}

CSVCMsg_HltvReplay::~CSVCMsg_HltvReplay() {
  // @@protoc_insertion_point(destructor:CSVCMsg_HltvReplay)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CSVCMsg_HltvReplay::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CSVCMsg_HltvReplay::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CSVCMsg_HltvReplay::Clear() {
// @@protoc_insertion_point(message_clear_start:CSVCMsg_HltvReplay)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&_impl_.delay_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.reason_) -
        reinterpret_cast<char*>(&_impl_.delay_)) + sizeof(_impl_.reason_));
    _impl_.primary_target_ = -1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSVCMsg_HltvReplay::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 delay = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_delay(&has_bits);
          _impl_.delay_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 primary_target = 2 [default = -1];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_primary_target(&has_bits);
          _impl_.primary_target_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 replay_stop_at = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_replay_stop_at(&has_bits);
          _impl_.replay_stop_at_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 replay_start_at = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_replay_start_at(&has_bits);
          _impl_.replay_start_at_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 replay_slowdown_begin = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_replay_slowdown_begin(&has_bits);
          _impl_.replay_slowdown_begin_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 replay_slowdown_end = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_replay_slowdown_end(&has_bits);
          _impl_.replay_slowdown_end_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float replay_slowdown_rate = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 61)) {
          _Internal::set_has_replay_slowdown_rate(&has_bits);
          _impl_.replay_slowdown_rate_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional int32 reason = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_reason(&has_bits);
          _impl_.reason_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSVCMsg_HltvReplay::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CSVCMsg_HltvReplay)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 delay = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_delay(), target);
  }

  // optional int32 primary_target = 2 [default = -1];
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_primary_target(), target);
  }

  // optional int32 replay_stop_at = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_replay_stop_at(), target);
  }

  // optional int32 replay_start_at = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_replay_start_at(), target);
  }

  // optional int32 replay_slowdown_begin = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_replay_slowdown_begin(), target);
  }

  // optional int32 replay_slowdown_end = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(6, this->_internal_replay_slowdown_end(), target);
  }

  // optional float replay_slowdown_rate = 7;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(7, this->_internal_replay_slowdown_rate(), target);
  }

  // optional int32 reason = 8;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(8, this->_internal_reason(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CSVCMsg_HltvReplay)
  return target;
}

size_t CSVCMsg_HltvReplay::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CSVCMsg_HltvReplay)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional int32 delay = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_delay());
    }

    // optional int32 replay_stop_at = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_replay_stop_at());
    }

    // optional int32 replay_start_at = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_replay_start_at());
    }

    // optional int32 replay_slowdown_begin = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_replay_slowdown_begin());
    }

    // optional int32 replay_slowdown_end = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_replay_slowdown_end());
    }

    // optional float replay_slowdown_rate = 7;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 4;
    }

    // optional int32 reason = 8;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_reason());
    }

    // optional int32 primary_target = 2 [default = -1];
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_primary_target());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSVCMsg_HltvReplay::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CSVCMsg_HltvReplay::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSVCMsg_HltvReplay::GetClassData() const { return &_class_data_; }


void CSVCMsg_HltvReplay::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CSVCMsg_HltvReplay*>(&to_msg);
  auto& from = static_cast<const CSVCMsg_HltvReplay&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CSVCMsg_HltvReplay)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.delay_ = from._impl_.delay_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.replay_stop_at_ = from._impl_.replay_stop_at_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.replay_start_at_ = from._impl_.replay_start_at_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.replay_slowdown_begin_ = from._impl_.replay_slowdown_begin_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.replay_slowdown_end_ = from._impl_.replay_slowdown_end_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.replay_slowdown_rate_ = from._impl_.replay_slowdown_rate_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.reason_ = from._impl_.reason_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.primary_target_ = from._impl_.primary_target_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSVCMsg_HltvReplay::CopyFrom(const CSVCMsg_HltvReplay& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CSVCMsg_HltvReplay)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSVCMsg_HltvReplay::IsInitialized() const {
  return true;
}

void CSVCMsg_HltvReplay::InternalSwap(CSVCMsg_HltvReplay* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CSVCMsg_HltvReplay, _impl_.reason_)
      + sizeof(CSVCMsg_HltvReplay::_impl_.reason_)
      - PROTOBUF_FIELD_OFFSET(CSVCMsg_HltvReplay, _impl_.delay_)>(
          reinterpret_cast<char*>(&_impl_.delay_),
          reinterpret_cast<char*>(&other->_impl_.delay_));
  swap(_impl_.primary_target_, other->_impl_.primary_target_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CSVCMsg_HltvReplay::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[66]);
}

// ===================================================================

class CCLCMsg_HltvReplay::_Internal {
 public:
  using HasBits = decltype(std::declval<CCLCMsg_HltvReplay>()._impl_._has_bits_);
  static void set_has_request(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_slowdown_length(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_slowdown_rate(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_primary_target(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_event_time(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

CCLCMsg_HltvReplay::CCLCMsg_HltvReplay(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CCLCMsg_HltvReplay)
}
CCLCMsg_HltvReplay::CCLCMsg_HltvReplay(const CCLCMsg_HltvReplay& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CCLCMsg_HltvReplay* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.request_){}
    , decltype(_impl_.slowdown_length_){}
    , decltype(_impl_.slowdown_rate_){}
    , decltype(_impl_.event_time_){}
    , decltype(_impl_.primary_target_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.request_, &from._impl_.request_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.primary_target_) -
    reinterpret_cast<char*>(&_impl_.request_)) + sizeof(_impl_.primary_target_));
  // @@protoc_insertion_point(copy_constructor:CCLCMsg_HltvReplay)
}

inline void CCLCMsg_HltvReplay::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.request_){0}
    , decltype(_impl_.slowdown_length_){0}
    , decltype(_impl_.slowdown_rate_){0}
    , decltype(_impl_.event_time_){0}
    , decltype(_impl_.primary_target_){-1}
  };
}

CCLCMsg_HltvReplay::~CCLCMsg_HltvReplay() {
  // @@protoc_insertion_point(destructor:CCLCMsg_HltvReplay)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CCLCMsg_HltvReplay::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CCLCMsg_HltvReplay::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CCLCMsg_HltvReplay::Clear() {
// @@protoc_insertion_point(message_clear_start:CCLCMsg_HltvReplay)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&_impl_.request_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.event_time_) -
        reinterpret_cast<char*>(&_impl_.request_)) + sizeof(_impl_.event_time_));
    _impl_.primary_target_ = -1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CCLCMsg_HltvReplay::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 request = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_request(&has_bits);
          _impl_.request_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float slowdown_length = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _Internal::set_has_slowdown_length(&has_bits);
          _impl_.slowdown_length_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float slowdown_rate = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _Internal::set_has_slowdown_rate(&has_bits);
          _impl_.slowdown_rate_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional int32 primary_target = 4 [default = -1];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_primary_target(&has_bits);
          _impl_.primary_target_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float event_time = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 45)) {
          _Internal::set_has_event_time(&has_bits);
          _impl_.event_time_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CCLCMsg_HltvReplay::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CCLCMsg_HltvReplay)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 request = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_request(), target);
  }

  // optional float slowdown_length = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_slowdown_length(), target);
  }

  // optional float slowdown_rate = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_slowdown_rate(), target);
  }

  // optional int32 primary_target = 4 [default = -1];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_primary_target(), target);
  }

  // optional float event_time = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(5, this->_internal_event_time(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CCLCMsg_HltvReplay)
  return target;
}

size_t CCLCMsg_HltvReplay::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CCLCMsg_HltvReplay)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional int32 request = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_request());
    }

    // optional float slowdown_length = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

    // optional float slowdown_rate = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

    // optional float event_time = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 4;
    }

    // optional int32 primary_target = 4 [default = -1];
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_primary_target());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CCLCMsg_HltvReplay::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CCLCMsg_HltvReplay::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CCLCMsg_HltvReplay::GetClassData() const { return &_class_data_; }


void CCLCMsg_HltvReplay::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CCLCMsg_HltvReplay*>(&to_msg);
  auto& from = static_cast<const CCLCMsg_HltvReplay&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CCLCMsg_HltvReplay)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.request_ = from._impl_.request_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.slowdown_length_ = from._impl_.slowdown_length_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.slowdown_rate_ = from._impl_.slowdown_rate_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.event_time_ = from._impl_.event_time_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.primary_target_ = from._impl_.primary_target_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CCLCMsg_HltvReplay::CopyFrom(const CCLCMsg_HltvReplay& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CCLCMsg_HltvReplay)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CCLCMsg_HltvReplay::IsInitialized() const {
  return true;
}

void CCLCMsg_HltvReplay::InternalSwap(CCLCMsg_HltvReplay* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CCLCMsg_HltvReplay, _impl_.event_time_)
      + sizeof(CCLCMsg_HltvReplay::_impl_.event_time_)
      - PROTOBUF_FIELD_OFFSET(CCLCMsg_HltvReplay, _impl_.request_)>(
          reinterpret_cast<char*>(&_impl_.request_),
          reinterpret_cast<char*>(&other->_impl_.request_));
  swap(_impl_.primary_target_, other->_impl_.primary_target_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CCLCMsg_HltvReplay::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[67]);
}

// ===================================================================

class CSVCMsg_Broadcast_Command::_Internal {
 public:
  using HasBits = decltype(std::declval<CSVCMsg_Broadcast_Command>()._impl_._has_bits_);
  static void set_has_cmd(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CSVCMsg_Broadcast_Command::CSVCMsg_Broadcast_Command(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CSVCMsg_Broadcast_Command)
}
CSVCMsg_Broadcast_Command::CSVCMsg_Broadcast_Command(const CSVCMsg_Broadcast_Command& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CSVCMsg_Broadcast_Command* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.cmd_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.cmd_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.cmd_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_cmd()) {
    _this->_impl_.cmd_.Set(from._internal_cmd(), 
      _this->GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:CSVCMsg_Broadcast_Command)
}

inline void CSVCMsg_Broadcast_Command::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.cmd_){}
  };
  _impl_.cmd_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.cmd_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CSVCMsg_Broadcast_Command::~CSVCMsg_Broadcast_Command() {
  // @@protoc_insertion_point(destructor:CSVCMsg_Broadcast_Command)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CSVCMsg_Broadcast_Command::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.cmd_.Destroy();
}

void CSVCMsg_Broadcast_Command::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CSVCMsg_Broadcast_Command::Clear() {
// @@protoc_insertion_point(message_clear_start:CSVCMsg_Broadcast_Command)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.cmd_.ClearNonDefaultToEmpty();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSVCMsg_Broadcast_Command::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional string cmd = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_cmd();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CSVCMsg_Broadcast_Command.cmd");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSVCMsg_Broadcast_Command::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CSVCMsg_Broadcast_Command)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional string cmd = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_cmd().data(), static_cast<int>(this->_internal_cmd().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CSVCMsg_Broadcast_Command.cmd");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_cmd(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CSVCMsg_Broadcast_Command)
  return target;
}

size_t CSVCMsg_Broadcast_Command::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CSVCMsg_Broadcast_Command)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string cmd = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_cmd());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSVCMsg_Broadcast_Command::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CSVCMsg_Broadcast_Command::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSVCMsg_Broadcast_Command::GetClassData() const { return &_class_data_; }


void CSVCMsg_Broadcast_Command::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CSVCMsg_Broadcast_Command*>(&to_msg);
  auto& from = static_cast<const CSVCMsg_Broadcast_Command&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CSVCMsg_Broadcast_Command)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_cmd()) {
    _this->_internal_set_cmd(from._internal_cmd());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSVCMsg_Broadcast_Command::CopyFrom(const CSVCMsg_Broadcast_Command& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CSVCMsg_Broadcast_Command)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSVCMsg_Broadcast_Command::IsInitialized() const {
  return true;
}

void CSVCMsg_Broadcast_Command::InternalSwap(CSVCMsg_Broadcast_Command* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.cmd_, lhs_arena,
      &other->_impl_.cmd_, rhs_arena
  );
}

::PROTOBUF_NAMESPACE_ID::Metadata CSVCMsg_Broadcast_Command::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[68]);
}

// ===================================================================

class CCLCMsg_HltvFixupOperatorTick::_Internal {
 public:
  using HasBits = decltype(std::declval<CCLCMsg_HltvFixupOperatorTick>()._impl_._has_bits_);
  static void set_has_tick(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_props_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::CMsgVector& origin(const CCLCMsg_HltvFixupOperatorTick* msg);
  static void set_has_origin(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::CMsgQAngle& eye_angles(const CCLCMsg_HltvFixupOperatorTick* msg);
  static void set_has_eye_angles(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_observer_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_cameraman_scoreboard(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_observer_target(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static const ::CMsgVector& view_offset(const CCLCMsg_HltvFixupOperatorTick* msg);
  static void set_has_view_offset(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::CMsgVector&
CCLCMsg_HltvFixupOperatorTick::_Internal::origin(const CCLCMsg_HltvFixupOperatorTick* msg) {
  return *msg->_impl_.origin_;
}
const ::CMsgQAngle&
CCLCMsg_HltvFixupOperatorTick::_Internal::eye_angles(const CCLCMsg_HltvFixupOperatorTick* msg) {
  return *msg->_impl_.eye_angles_;
}
const ::CMsgVector&
CCLCMsg_HltvFixupOperatorTick::_Internal::view_offset(const CCLCMsg_HltvFixupOperatorTick* msg) {
  return *msg->_impl_.view_offset_;
}
void CCLCMsg_HltvFixupOperatorTick::clear_origin() {
  if (_impl_.origin_ != nullptr) _impl_.origin_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void CCLCMsg_HltvFixupOperatorTick::clear_eye_angles() {
  if (_impl_.eye_angles_ != nullptr) _impl_.eye_angles_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
void CCLCMsg_HltvFixupOperatorTick::clear_view_offset() {
  if (_impl_.view_offset_ != nullptr) _impl_.view_offset_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
CCLCMsg_HltvFixupOperatorTick::CCLCMsg_HltvFixupOperatorTick(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CCLCMsg_HltvFixupOperatorTick)
}
CCLCMsg_HltvFixupOperatorTick::CCLCMsg_HltvFixupOperatorTick(const CCLCMsg_HltvFixupOperatorTick& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CCLCMsg_HltvFixupOperatorTick* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.props_data_){}
    , decltype(_impl_.origin_){nullptr}
    , decltype(_impl_.eye_angles_){nullptr}
    , decltype(_impl_.view_offset_){nullptr}
    , decltype(_impl_.tick_){}
    , decltype(_impl_.observer_mode_){}
    , decltype(_impl_.cameraman_scoreboard_){}
    , decltype(_impl_.observer_target_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.props_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.props_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_props_data()) {
    _this->_impl_.props_data_.Set(from._internal_props_data(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_origin()) {
    _this->_impl_.origin_ = new ::CMsgVector(*from._impl_.origin_);
  }
  if (from._internal_has_eye_angles()) {
    _this->_impl_.eye_angles_ = new ::CMsgQAngle(*from._impl_.eye_angles_);
  }
  if (from._internal_has_view_offset()) {
    _this->_impl_.view_offset_ = new ::CMsgVector(*from._impl_.view_offset_);
  }
  ::memcpy(&_impl_.tick_, &from._impl_.tick_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.observer_target_) -
    reinterpret_cast<char*>(&_impl_.tick_)) + sizeof(_impl_.observer_target_));
  // @@protoc_insertion_point(copy_constructor:CCLCMsg_HltvFixupOperatorTick)
}

inline void CCLCMsg_HltvFixupOperatorTick::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.props_data_){}
    , decltype(_impl_.origin_){nullptr}
    , decltype(_impl_.eye_angles_){nullptr}
    , decltype(_impl_.view_offset_){nullptr}
    , decltype(_impl_.tick_){0}
    , decltype(_impl_.observer_mode_){0}
    , decltype(_impl_.cameraman_scoreboard_){false}
    , decltype(_impl_.observer_target_){0}
  };
  _impl_.props_data_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.props_data_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CCLCMsg_HltvFixupOperatorTick::~CCLCMsg_HltvFixupOperatorTick() {
  // @@protoc_insertion_point(destructor:CCLCMsg_HltvFixupOperatorTick)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CCLCMsg_HltvFixupOperatorTick::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.props_data_.Destroy();
  if (this != internal_default_instance()) delete _impl_.origin_;
  if (this != internal_default_instance()) delete _impl_.eye_angles_;
  if (this != internal_default_instance()) delete _impl_.view_offset_;
}

void CCLCMsg_HltvFixupOperatorTick::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CCLCMsg_HltvFixupOperatorTick::Clear() {
// @@protoc_insertion_point(message_clear_start:CCLCMsg_HltvFixupOperatorTick)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.props_data_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.origin_ != nullptr);
      _impl_.origin_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.eye_angles_ != nullptr);
      _impl_.eye_angles_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.view_offset_ != nullptr);
      _impl_.view_offset_->Clear();
    }
  }
  if (cached_has_bits & 0x000000f0u) {
    ::memset(&_impl_.tick_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.observer_target_) -
        reinterpret_cast<char*>(&_impl_.tick_)) + sizeof(_impl_.observer_target_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CCLCMsg_HltvFixupOperatorTick::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 tick = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_tick(&has_bits);
          _impl_.tick_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes props_data = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_props_data();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgVector origin = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_origin(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgQAngle eye_angles = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_eye_angles(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 observer_mode = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_observer_mode(&has_bits);
          _impl_.observer_mode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool cameraman_scoreboard = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_cameraman_scoreboard(&has_bits);
          _impl_.cameraman_scoreboard_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 observer_target = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_observer_target(&has_bits);
          _impl_.observer_target_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgVector view_offset = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_view_offset(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CCLCMsg_HltvFixupOperatorTick::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CCLCMsg_HltvFixupOperatorTick)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 tick = 1;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_tick(), target);
  }

  // optional bytes props_data = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_props_data(), target);
  }

  // optional .CMsgVector origin = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::origin(this),
        _Internal::origin(this).GetCachedSize(), target, stream);
  }

  // optional .CMsgQAngle eye_angles = 4;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::eye_angles(this),
        _Internal::eye_angles(this).GetCachedSize(), target, stream);
  }

  // optional int32 observer_mode = 5;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_observer_mode(), target);
  }

  // optional bool cameraman_scoreboard = 6;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(6, this->_internal_cameraman_scoreboard(), target);
  }

  // optional int32 observer_target = 7;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(7, this->_internal_observer_target(), target);
  }

  // optional .CMsgVector view_offset = 8;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::view_offset(this),
        _Internal::view_offset(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CCLCMsg_HltvFixupOperatorTick)
  return target;
}

size_t CCLCMsg_HltvFixupOperatorTick::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CCLCMsg_HltvFixupOperatorTick)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional bytes props_data = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_props_data());
    }

    // optional .CMsgVector origin = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.origin_);
    }

    // optional .CMsgQAngle eye_angles = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.eye_angles_);
    }

    // optional .CMsgVector view_offset = 8;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.view_offset_);
    }

    // optional int32 tick = 1;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_tick());
    }

    // optional int32 observer_mode = 5;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_observer_mode());
    }

    // optional bool cameraman_scoreboard = 6;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 1;
    }

    // optional int32 observer_target = 7;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_observer_target());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CCLCMsg_HltvFixupOperatorTick::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CCLCMsg_HltvFixupOperatorTick::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CCLCMsg_HltvFixupOperatorTick::GetClassData() const { return &_class_data_; }


void CCLCMsg_HltvFixupOperatorTick::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CCLCMsg_HltvFixupOperatorTick*>(&to_msg);
  auto& from = static_cast<const CCLCMsg_HltvFixupOperatorTick&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CCLCMsg_HltvFixupOperatorTick)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_props_data(from._internal_props_data());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_origin()->::CMsgVector::MergeFrom(
          from._internal_origin());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_eye_angles()->::CMsgQAngle::MergeFrom(
          from._internal_eye_angles());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_view_offset()->::CMsgVector::MergeFrom(
          from._internal_view_offset());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.tick_ = from._impl_.tick_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.observer_mode_ = from._impl_.observer_mode_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.cameraman_scoreboard_ = from._impl_.cameraman_scoreboard_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.observer_target_ = from._impl_.observer_target_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CCLCMsg_HltvFixupOperatorTick::CopyFrom(const CCLCMsg_HltvFixupOperatorTick& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CCLCMsg_HltvFixupOperatorTick)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CCLCMsg_HltvFixupOperatorTick::IsInitialized() const {
  return true;
}

void CCLCMsg_HltvFixupOperatorTick::InternalSwap(CCLCMsg_HltvFixupOperatorTick* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.props_data_, lhs_arena,
      &other->_impl_.props_data_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CCLCMsg_HltvFixupOperatorTick, _impl_.observer_target_)
      + sizeof(CCLCMsg_HltvFixupOperatorTick::_impl_.observer_target_)
      - PROTOBUF_FIELD_OFFSET(CCLCMsg_HltvFixupOperatorTick, _impl_.origin_)>(
          reinterpret_cast<char*>(&_impl_.origin_),
          reinterpret_cast<char*>(&other->_impl_.origin_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CCLCMsg_HltvFixupOperatorTick::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[69]);
}

// ===================================================================

class CSVCMsg_HltvFixupOperatorStatus::_Internal {
 public:
  using HasBits = decltype(std::declval<CSVCMsg_HltvFixupOperatorStatus>()._impl_._has_bits_);
  static void set_has_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_override_operator_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

CSVCMsg_HltvFixupOperatorStatus::CSVCMsg_HltvFixupOperatorStatus(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CSVCMsg_HltvFixupOperatorStatus)
}
CSVCMsg_HltvFixupOperatorStatus::CSVCMsg_HltvFixupOperatorStatus(const CSVCMsg_HltvFixupOperatorStatus& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CSVCMsg_HltvFixupOperatorStatus* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.override_operator_name_){}
    , decltype(_impl_.mode_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.override_operator_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.override_operator_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_override_operator_name()) {
    _this->_impl_.override_operator_name_.Set(from._internal_override_operator_name(), 
      _this->GetArenaForAllocation());
  }
  _this->_impl_.mode_ = from._impl_.mode_;
  // @@protoc_insertion_point(copy_constructor:CSVCMsg_HltvFixupOperatorStatus)
}

inline void CSVCMsg_HltvFixupOperatorStatus::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.override_operator_name_){}
    , decltype(_impl_.mode_){0u}
  };
  _impl_.override_operator_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.override_operator_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CSVCMsg_HltvFixupOperatorStatus::~CSVCMsg_HltvFixupOperatorStatus() {
  // @@protoc_insertion_point(destructor:CSVCMsg_HltvFixupOperatorStatus)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CSVCMsg_HltvFixupOperatorStatus::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.override_operator_name_.Destroy();
}

void CSVCMsg_HltvFixupOperatorStatus::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CSVCMsg_HltvFixupOperatorStatus::Clear() {
// @@protoc_insertion_point(message_clear_start:CSVCMsg_HltvFixupOperatorStatus)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    _impl_.override_operator_name_.ClearNonDefaultToEmpty();
  }
  _impl_.mode_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CSVCMsg_HltvFixupOperatorStatus::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional uint32 mode = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_mode(&has_bits);
          _impl_.mode_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string override_operator_name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_override_operator_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CSVCMsg_HltvFixupOperatorStatus.override_operator_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSVCMsg_HltvFixupOperatorStatus::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CSVCMsg_HltvFixupOperatorStatus)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional uint32 mode = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(1, this->_internal_mode(), target);
  }

  // optional string override_operator_name = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_override_operator_name().data(), static_cast<int>(this->_internal_override_operator_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CSVCMsg_HltvFixupOperatorStatus.override_operator_name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_override_operator_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CSVCMsg_HltvFixupOperatorStatus)
  return target;
}

size_t CSVCMsg_HltvFixupOperatorStatus::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CSVCMsg_HltvFixupOperatorStatus)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional string override_operator_name = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_override_operator_name());
    }

    // optional uint32 mode = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_mode());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CSVCMsg_HltvFixupOperatorStatus::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CSVCMsg_HltvFixupOperatorStatus::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CSVCMsg_HltvFixupOperatorStatus::GetClassData() const { return &_class_data_; }


void CSVCMsg_HltvFixupOperatorStatus::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CSVCMsg_HltvFixupOperatorStatus*>(&to_msg);
  auto& from = static_cast<const CSVCMsg_HltvFixupOperatorStatus&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CSVCMsg_HltvFixupOperatorStatus)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_override_operator_name(from._internal_override_operator_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.mode_ = from._impl_.mode_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CSVCMsg_HltvFixupOperatorStatus::CopyFrom(const CSVCMsg_HltvFixupOperatorStatus& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CSVCMsg_HltvFixupOperatorStatus)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSVCMsg_HltvFixupOperatorStatus::IsInitialized() const {
  return true;
}

void CSVCMsg_HltvFixupOperatorStatus::InternalSwap(CSVCMsg_HltvFixupOperatorStatus* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.override_operator_name_, lhs_arena,
      &other->_impl_.override_operator_name_, rhs_arena
  );
  swap(_impl_.mode_, other->_impl_.mode_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CSVCMsg_HltvFixupOperatorStatus::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_netmessages_2eproto_getter, &descriptor_table_netmessages_2eproto_once,
      file_level_metadata_netmessages_2eproto[70]);
}

// @@protoc_insertion_point(namespace_scope)
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::CCLCMsg_ClientInfo*
Arena::CreateMaybeMessage< ::CCLCMsg_ClientInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CCLCMsg_ClientInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::CCLCMsg_Move*
Arena::CreateMaybeMessage< ::CCLCMsg_Move >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CCLCMsg_Move >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgVoiceAudio*
Arena::CreateMaybeMessage< ::CMsgVoiceAudio >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgVoiceAudio >(arena);
}
template<> PROTOBUF_NOINLINE ::CCLCMsg_VoiceData*
Arena::CreateMaybeMessage< ::CCLCMsg_VoiceData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CCLCMsg_VoiceData >(arena);
}
template<> PROTOBUF_NOINLINE ::CCLCMsg_BaselineAck*
Arena::CreateMaybeMessage< ::CCLCMsg_BaselineAck >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CCLCMsg_BaselineAck >(arena);
}
template<> PROTOBUF_NOINLINE ::CCLCMsg_ListenEvents*
Arena::CreateMaybeMessage< ::CCLCMsg_ListenEvents >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CCLCMsg_ListenEvents >(arena);
}
template<> PROTOBUF_NOINLINE ::CCLCMsg_RespondCvarValue*
Arena::CreateMaybeMessage< ::CCLCMsg_RespondCvarValue >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CCLCMsg_RespondCvarValue >(arena);
}
template<> PROTOBUF_NOINLINE ::CCLCMsg_FileCRCCheck*
Arena::CreateMaybeMessage< ::CCLCMsg_FileCRCCheck >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CCLCMsg_FileCRCCheck >(arena);
}
template<> PROTOBUF_NOINLINE ::CCLCMsg_LoadingProgress*
Arena::CreateMaybeMessage< ::CCLCMsg_LoadingProgress >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CCLCMsg_LoadingProgress >(arena);
}
template<> PROTOBUF_NOINLINE ::CCLCMsg_SplitPlayerConnect*
Arena::CreateMaybeMessage< ::CCLCMsg_SplitPlayerConnect >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CCLCMsg_SplitPlayerConnect >(arena);
}
template<> PROTOBUF_NOINLINE ::CCLCMsg_ClientMessage*
Arena::CreateMaybeMessage< ::CCLCMsg_ClientMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CCLCMsg_ClientMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::CCLCMsg_SplitPlayerDisconnect*
Arena::CreateMaybeMessage< ::CCLCMsg_SplitPlayerDisconnect >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CCLCMsg_SplitPlayerDisconnect >(arena);
}
template<> PROTOBUF_NOINLINE ::CCLCMsg_ServerStatus*
Arena::CreateMaybeMessage< ::CCLCMsg_ServerStatus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CCLCMsg_ServerStatus >(arena);
}
template<> PROTOBUF_NOINLINE ::CCLCMsg_RequestPause*
Arena::CreateMaybeMessage< ::CCLCMsg_RequestPause >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CCLCMsg_RequestPause >(arena);
}
template<> PROTOBUF_NOINLINE ::CCLCMsg_CmdKeyValues*
Arena::CreateMaybeMessage< ::CCLCMsg_CmdKeyValues >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CCLCMsg_CmdKeyValues >(arena);
}
template<> PROTOBUF_NOINLINE ::CCLCMsg_RconServerDetails*
Arena::CreateMaybeMessage< ::CCLCMsg_RconServerDetails >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CCLCMsg_RconServerDetails >(arena);
}
template<> PROTOBUF_NOINLINE ::CSVCMsg_ServerInfo*
Arena::CreateMaybeMessage< ::CSVCMsg_ServerInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSVCMsg_ServerInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::CSVCMsg_ClassInfo_class_t*
Arena::CreateMaybeMessage< ::CSVCMsg_ClassInfo_class_t >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSVCMsg_ClassInfo_class_t >(arena);
}
template<> PROTOBUF_NOINLINE ::CSVCMsg_ClassInfo*
Arena::CreateMaybeMessage< ::CSVCMsg_ClassInfo >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSVCMsg_ClassInfo >(arena);
}
template<> PROTOBUF_NOINLINE ::CSVCMsg_SetPause*
Arena::CreateMaybeMessage< ::CSVCMsg_SetPause >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSVCMsg_SetPause >(arena);
}
template<> PROTOBUF_NOINLINE ::CSVCMsg_VoiceInit*
Arena::CreateMaybeMessage< ::CSVCMsg_VoiceInit >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSVCMsg_VoiceInit >(arena);
}
template<> PROTOBUF_NOINLINE ::CSVCMsg_Print*
Arena::CreateMaybeMessage< ::CSVCMsg_Print >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSVCMsg_Print >(arena);
}
template<> PROTOBUF_NOINLINE ::CSVCMsg_Sounds_sounddata_t*
Arena::CreateMaybeMessage< ::CSVCMsg_Sounds_sounddata_t >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSVCMsg_Sounds_sounddata_t >(arena);
}
template<> PROTOBUF_NOINLINE ::CSVCMsg_Sounds*
Arena::CreateMaybeMessage< ::CSVCMsg_Sounds >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSVCMsg_Sounds >(arena);
}
template<> PROTOBUF_NOINLINE ::CSVCMsg_Prefetch*
Arena::CreateMaybeMessage< ::CSVCMsg_Prefetch >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSVCMsg_Prefetch >(arena);
}
template<> PROTOBUF_NOINLINE ::CSVCMsg_SetView*
Arena::CreateMaybeMessage< ::CSVCMsg_SetView >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSVCMsg_SetView >(arena);
}
template<> PROTOBUF_NOINLINE ::CSVCMsg_FixAngle*
Arena::CreateMaybeMessage< ::CSVCMsg_FixAngle >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSVCMsg_FixAngle >(arena);
}
template<> PROTOBUF_NOINLINE ::CSVCMsg_CrosshairAngle*
Arena::CreateMaybeMessage< ::CSVCMsg_CrosshairAngle >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSVCMsg_CrosshairAngle >(arena);
}
template<> PROTOBUF_NOINLINE ::CSVCMsg_BSPDecal*
Arena::CreateMaybeMessage< ::CSVCMsg_BSPDecal >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSVCMsg_BSPDecal >(arena);
}
template<> PROTOBUF_NOINLINE ::CSVCMsg_SplitScreen*
Arena::CreateMaybeMessage< ::CSVCMsg_SplitScreen >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSVCMsg_SplitScreen >(arena);
}
template<> PROTOBUF_NOINLINE ::CSVCMsg_GetCvarValue*
Arena::CreateMaybeMessage< ::CSVCMsg_GetCvarValue >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSVCMsg_GetCvarValue >(arena);
}
template<> PROTOBUF_NOINLINE ::CSVCMsg_Menu*
Arena::CreateMaybeMessage< ::CSVCMsg_Menu >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSVCMsg_Menu >(arena);
}
template<> PROTOBUF_NOINLINE ::CSVCMsg_UserMessage*
Arena::CreateMaybeMessage< ::CSVCMsg_UserMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSVCMsg_UserMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::CSVCMsg_SendTable_sendprop_t*
Arena::CreateMaybeMessage< ::CSVCMsg_SendTable_sendprop_t >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSVCMsg_SendTable_sendprop_t >(arena);
}
template<> PROTOBUF_NOINLINE ::CSVCMsg_SendTable*
Arena::CreateMaybeMessage< ::CSVCMsg_SendTable >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSVCMsg_SendTable >(arena);
}
template<> PROTOBUF_NOINLINE ::CSVCMsg_GameEventList_key_t*
Arena::CreateMaybeMessage< ::CSVCMsg_GameEventList_key_t >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSVCMsg_GameEventList_key_t >(arena);
}
template<> PROTOBUF_NOINLINE ::CSVCMsg_GameEventList_descriptor_t*
Arena::CreateMaybeMessage< ::CSVCMsg_GameEventList_descriptor_t >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSVCMsg_GameEventList_descriptor_t >(arena);
}
template<> PROTOBUF_NOINLINE ::CSVCMsg_GameEventList*
Arena::CreateMaybeMessage< ::CSVCMsg_GameEventList >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSVCMsg_GameEventList >(arena);
}
template<> PROTOBUF_NOINLINE ::CSVCMsg_PacketEntities_command_queue_info_t*
Arena::CreateMaybeMessage< ::CSVCMsg_PacketEntities_command_queue_info_t >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSVCMsg_PacketEntities_command_queue_info_t >(arena);
}
template<> PROTOBUF_NOINLINE ::CSVCMsg_PacketEntities_alternate_baseline_t*
Arena::CreateMaybeMessage< ::CSVCMsg_PacketEntities_alternate_baseline_t >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSVCMsg_PacketEntities_alternate_baseline_t >(arena);
}
template<> PROTOBUF_NOINLINE ::CSVCMsg_PacketEntities_non_transmitted_entities_t*
Arena::CreateMaybeMessage< ::CSVCMsg_PacketEntities_non_transmitted_entities_t >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSVCMsg_PacketEntities_non_transmitted_entities_t >(arena);
}
template<> PROTOBUF_NOINLINE ::CSVCMsg_PacketEntities*
Arena::CreateMaybeMessage< ::CSVCMsg_PacketEntities >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSVCMsg_PacketEntities >(arena);
}
template<> PROTOBUF_NOINLINE ::CSVCMsg_TempEntities*
Arena::CreateMaybeMessage< ::CSVCMsg_TempEntities >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSVCMsg_TempEntities >(arena);
}
template<> PROTOBUF_NOINLINE ::CSVCMsg_CreateStringTable*
Arena::CreateMaybeMessage< ::CSVCMsg_CreateStringTable >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSVCMsg_CreateStringTable >(arena);
}
template<> PROTOBUF_NOINLINE ::CSVCMsg_UpdateStringTable*
Arena::CreateMaybeMessage< ::CSVCMsg_UpdateStringTable >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSVCMsg_UpdateStringTable >(arena);
}
template<> PROTOBUF_NOINLINE ::CSVCMsg_VoiceData*
Arena::CreateMaybeMessage< ::CSVCMsg_VoiceData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSVCMsg_VoiceData >(arena);
}
template<> PROTOBUF_NOINLINE ::CSVCMsg_PacketReliable*
Arena::CreateMaybeMessage< ::CSVCMsg_PacketReliable >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSVCMsg_PacketReliable >(arena);
}
template<> PROTOBUF_NOINLINE ::CSVCMsg_FullFrameSplit*
Arena::CreateMaybeMessage< ::CSVCMsg_FullFrameSplit >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSVCMsg_FullFrameSplit >(arena);
}
template<> PROTOBUF_NOINLINE ::CSVCMsg_HLTVStatus*
Arena::CreateMaybeMessage< ::CSVCMsg_HLTVStatus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSVCMsg_HLTVStatus >(arena);
}
template<> PROTOBUF_NOINLINE ::CSVCMsg_ServerSteamID*
Arena::CreateMaybeMessage< ::CSVCMsg_ServerSteamID >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSVCMsg_ServerSteamID >(arena);
}
template<> PROTOBUF_NOINLINE ::CSVCMsg_CmdKeyValues*
Arena::CreateMaybeMessage< ::CSVCMsg_CmdKeyValues >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSVCMsg_CmdKeyValues >(arena);
}
template<> PROTOBUF_NOINLINE ::CSVCMsg_RconServerDetails*
Arena::CreateMaybeMessage< ::CSVCMsg_RconServerDetails >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSVCMsg_RconServerDetails >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgIPCAddress*
Arena::CreateMaybeMessage< ::CMsgIPCAddress >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgIPCAddress >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgServerPeer*
Arena::CreateMaybeMessage< ::CMsgServerPeer >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgServerPeer >(arena);
}
template<> PROTOBUF_NOINLINE ::CSVCMsg_PeerList*
Arena::CreateMaybeMessage< ::CSVCMsg_PeerList >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSVCMsg_PeerList >(arena);
}
template<> PROTOBUF_NOINLINE ::CSVCMsg_ClearAllStringTables*
Arena::CreateMaybeMessage< ::CSVCMsg_ClearAllStringTables >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSVCMsg_ClearAllStringTables >(arena);
}
template<> PROTOBUF_NOINLINE ::ProtoFlattenedSerializerField_t_polymorphic_field_t*
Arena::CreateMaybeMessage< ::ProtoFlattenedSerializerField_t_polymorphic_field_t >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ProtoFlattenedSerializerField_t_polymorphic_field_t >(arena);
}
template<> PROTOBUF_NOINLINE ::ProtoFlattenedSerializerField_t*
Arena::CreateMaybeMessage< ::ProtoFlattenedSerializerField_t >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ProtoFlattenedSerializerField_t >(arena);
}
template<> PROTOBUF_NOINLINE ::ProtoFlattenedSerializer_t*
Arena::CreateMaybeMessage< ::ProtoFlattenedSerializer_t >(Arena* arena) {
  return Arena::CreateMessageInternal< ::ProtoFlattenedSerializer_t >(arena);
}
template<> PROTOBUF_NOINLINE ::CSVCMsg_FlattenedSerializer*
Arena::CreateMaybeMessage< ::CSVCMsg_FlattenedSerializer >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSVCMsg_FlattenedSerializer >(arena);
}
template<> PROTOBUF_NOINLINE ::CSVCMsg_StopSound*
Arena::CreateMaybeMessage< ::CSVCMsg_StopSound >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSVCMsg_StopSound >(arena);
}
template<> PROTOBUF_NOINLINE ::CBidirMsg_RebroadcastGameEvent*
Arena::CreateMaybeMessage< ::CBidirMsg_RebroadcastGameEvent >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CBidirMsg_RebroadcastGameEvent >(arena);
}
template<> PROTOBUF_NOINLINE ::CBidirMsg_RebroadcastSource*
Arena::CreateMaybeMessage< ::CBidirMsg_RebroadcastSource >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CBidirMsg_RebroadcastSource >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgServerNetworkStats_Port*
Arena::CreateMaybeMessage< ::CMsgServerNetworkStats_Port >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgServerNetworkStats_Port >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgServerNetworkStats_Player*
Arena::CreateMaybeMessage< ::CMsgServerNetworkStats_Player >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgServerNetworkStats_Player >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgServerNetworkStats*
Arena::CreateMaybeMessage< ::CMsgServerNetworkStats >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgServerNetworkStats >(arena);
}
template<> PROTOBUF_NOINLINE ::CSVCMsg_HltvReplay*
Arena::CreateMaybeMessage< ::CSVCMsg_HltvReplay >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSVCMsg_HltvReplay >(arena);
}
template<> PROTOBUF_NOINLINE ::CCLCMsg_HltvReplay*
Arena::CreateMaybeMessage< ::CCLCMsg_HltvReplay >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CCLCMsg_HltvReplay >(arena);
}
template<> PROTOBUF_NOINLINE ::CSVCMsg_Broadcast_Command*
Arena::CreateMaybeMessage< ::CSVCMsg_Broadcast_Command >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSVCMsg_Broadcast_Command >(arena);
}
template<> PROTOBUF_NOINLINE ::CCLCMsg_HltvFixupOperatorTick*
Arena::CreateMaybeMessage< ::CCLCMsg_HltvFixupOperatorTick >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CCLCMsg_HltvFixupOperatorTick >(arena);
}
template<> PROTOBUF_NOINLINE ::CSVCMsg_HltvFixupOperatorStatus*
Arena::CreateMaybeMessage< ::CSVCMsg_HltvFixupOperatorStatus >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CSVCMsg_HltvFixupOperatorStatus >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
