// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: te.proto

#include "te.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

PROTOBUF_CONSTEXPR CMsgTEArmorRicochet::CMsgTEArmorRicochet(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.pos_)*/nullptr
  , /*decltype(_impl_.dir_)*/nullptr} {}
struct CMsgTEArmorRicochetDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgTEArmorRicochetDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgTEArmorRicochetDefaultTypeInternal() {}
  union {
    CMsgTEArmorRicochet _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgTEArmorRicochetDefaultTypeInternal _CMsgTEArmorRicochet_default_instance_;
PROTOBUF_CONSTEXPR CMsgTEBaseBeam::CMsgTEBaseBeam(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.modelindex_)*/uint64_t{0u}
  , /*decltype(_impl_.haloindex_)*/uint64_t{0u}
  , /*decltype(_impl_.startframe_)*/0u
  , /*decltype(_impl_.framerate_)*/0u
  , /*decltype(_impl_.life_)*/0
  , /*decltype(_impl_.width_)*/0
  , /*decltype(_impl_.endwidth_)*/0
  , /*decltype(_impl_.fadelength_)*/0u
  , /*decltype(_impl_.amplitude_)*/0
  , /*decltype(_impl_.color_)*/0u
  , /*decltype(_impl_.speed_)*/0u
  , /*decltype(_impl_.flags_)*/0u} {}
struct CMsgTEBaseBeamDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgTEBaseBeamDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgTEBaseBeamDefaultTypeInternal() {}
  union {
    CMsgTEBaseBeam _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgTEBaseBeamDefaultTypeInternal _CMsgTEBaseBeam_default_instance_;
PROTOBUF_CONSTEXPR CMsgTEBeamEntPoint::CMsgTEBeamEntPoint(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.base_)*/nullptr
  , /*decltype(_impl_.start_)*/nullptr
  , /*decltype(_impl_.end_)*/nullptr
  , /*decltype(_impl_.startentity_)*/0u
  , /*decltype(_impl_.endentity_)*/0u} {}
struct CMsgTEBeamEntPointDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgTEBeamEntPointDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgTEBeamEntPointDefaultTypeInternal() {}
  union {
    CMsgTEBeamEntPoint _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgTEBeamEntPointDefaultTypeInternal _CMsgTEBeamEntPoint_default_instance_;
PROTOBUF_CONSTEXPR CMsgTEBeamEnts::CMsgTEBeamEnts(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.base_)*/nullptr
  , /*decltype(_impl_.startentity_)*/0u
  , /*decltype(_impl_.endentity_)*/0u} {}
struct CMsgTEBeamEntsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgTEBeamEntsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgTEBeamEntsDefaultTypeInternal() {}
  union {
    CMsgTEBeamEnts _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgTEBeamEntsDefaultTypeInternal _CMsgTEBeamEnts_default_instance_;
PROTOBUF_CONSTEXPR CMsgTEBeamPoints::CMsgTEBeamPoints(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.base_)*/nullptr
  , /*decltype(_impl_.start_)*/nullptr
  , /*decltype(_impl_.end_)*/nullptr} {}
struct CMsgTEBeamPointsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgTEBeamPointsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgTEBeamPointsDefaultTypeInternal() {}
  union {
    CMsgTEBeamPoints _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgTEBeamPointsDefaultTypeInternal _CMsgTEBeamPoints_default_instance_;
PROTOBUF_CONSTEXPR CMsgTEBeamRing::CMsgTEBeamRing(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.base_)*/nullptr
  , /*decltype(_impl_.startentity_)*/0u
  , /*decltype(_impl_.endentity_)*/0u} {}
struct CMsgTEBeamRingDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgTEBeamRingDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgTEBeamRingDefaultTypeInternal() {}
  union {
    CMsgTEBeamRing _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgTEBeamRingDefaultTypeInternal _CMsgTEBeamRing_default_instance_;
PROTOBUF_CONSTEXPR CMsgTEBSPDecal::CMsgTEBSPDecal(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.origin_)*/nullptr
  , /*decltype(_impl_.normal_)*/nullptr
  , /*decltype(_impl_.saxis_)*/nullptr
  , /*decltype(_impl_.index_)*/0u
  , /*decltype(_impl_.entity_)*/-1} {}
struct CMsgTEBSPDecalDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgTEBSPDecalDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgTEBSPDecalDefaultTypeInternal() {}
  union {
    CMsgTEBSPDecal _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgTEBSPDecalDefaultTypeInternal _CMsgTEBSPDecal_default_instance_;
PROTOBUF_CONSTEXPR CMsgTEBubbles::CMsgTEBubbles(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.mins_)*/nullptr
  , /*decltype(_impl_.maxs_)*/nullptr
  , /*decltype(_impl_.height_)*/0
  , /*decltype(_impl_.count_)*/0u
  , /*decltype(_impl_.speed_)*/0} {}
struct CMsgTEBubblesDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgTEBubblesDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgTEBubblesDefaultTypeInternal() {}
  union {
    CMsgTEBubbles _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgTEBubblesDefaultTypeInternal _CMsgTEBubbles_default_instance_;
PROTOBUF_CONSTEXPR CMsgTEBubbleTrail::CMsgTEBubbleTrail(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.mins_)*/nullptr
  , /*decltype(_impl_.maxs_)*/nullptr
  , /*decltype(_impl_.waterz_)*/0
  , /*decltype(_impl_.count_)*/0u
  , /*decltype(_impl_.speed_)*/0} {}
struct CMsgTEBubbleTrailDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgTEBubbleTrailDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgTEBubbleTrailDefaultTypeInternal() {}
  union {
    CMsgTEBubbleTrail _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgTEBubbleTrailDefaultTypeInternal _CMsgTEBubbleTrail_default_instance_;
PROTOBUF_CONSTEXPR CMsgTEDecal::CMsgTEDecal(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.origin_)*/nullptr
  , /*decltype(_impl_.start_)*/nullptr
  , /*decltype(_impl_.hitbox_)*/0u
  , /*decltype(_impl_.index_)*/0u
  , /*decltype(_impl_.entity_)*/-1} {}
struct CMsgTEDecalDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgTEDecalDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgTEDecalDefaultTypeInternal() {}
  union {
    CMsgTEDecal _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgTEDecalDefaultTypeInternal _CMsgTEDecal_default_instance_;
PROTOBUF_CONSTEXPR CMsgEffectData::CMsgEffectData(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.origin_)*/nullptr
  , /*decltype(_impl_.start_)*/nullptr
  , /*decltype(_impl_.normal_)*/nullptr
  , /*decltype(_impl_.angles_)*/nullptr
  , /*decltype(_impl_.scale_)*/0
  , /*decltype(_impl_.magnitude_)*/0
  , /*decltype(_impl_.radius_)*/0
  , /*decltype(_impl_.surfaceprop_)*/0u
  , /*decltype(_impl_.effectindex_)*/uint64_t{0u}
  , /*decltype(_impl_.damagetype_)*/0u
  , /*decltype(_impl_.material_)*/0u
  , /*decltype(_impl_.hitbox_)*/0u
  , /*decltype(_impl_.color_)*/0u
  , /*decltype(_impl_.flags_)*/0u
  , /*decltype(_impl_.attachmentindex_)*/0
  , /*decltype(_impl_.effectname_)*/0u
  , /*decltype(_impl_.attachmentname_)*/0u
  , /*decltype(_impl_.entity_)*/16777215u
  , /*decltype(_impl_.otherentity_)*/16777215u} {}
struct CMsgEffectDataDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgEffectDataDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgEffectDataDefaultTypeInternal() {}
  union {
    CMsgEffectData _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgEffectDataDefaultTypeInternal _CMsgEffectData_default_instance_;
PROTOBUF_CONSTEXPR CMsgTEEffectDispatch::CMsgTEEffectDispatch(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.effectdata_)*/nullptr} {}
struct CMsgTEEffectDispatchDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgTEEffectDispatchDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgTEEffectDispatchDefaultTypeInternal() {}
  union {
    CMsgTEEffectDispatch _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgTEEffectDispatchDefaultTypeInternal _CMsgTEEffectDispatch_default_instance_;
PROTOBUF_CONSTEXPR CMsgTEEnergySplash::CMsgTEEnergySplash(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.pos_)*/nullptr
  , /*decltype(_impl_.dir_)*/nullptr
  , /*decltype(_impl_.explosive_)*/false} {}
struct CMsgTEEnergySplashDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgTEEnergySplashDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgTEEnergySplashDefaultTypeInternal() {}
  union {
    CMsgTEEnergySplash _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgTEEnergySplashDefaultTypeInternal _CMsgTEEnergySplash_default_instance_;
PROTOBUF_CONSTEXPR CMsgTEFizz::CMsgTEFizz(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.density_)*/0u
  , /*decltype(_impl_.current_)*/0
  , /*decltype(_impl_.entity_)*/-1} {}
struct CMsgTEFizzDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgTEFizzDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgTEFizzDefaultTypeInternal() {}
  union {
    CMsgTEFizz _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgTEFizzDefaultTypeInternal _CMsgTEFizz_default_instance_;
PROTOBUF_CONSTEXPR CMsgTEShatterSurface::CMsgTEShatterSurface(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.origin_)*/nullptr
  , /*decltype(_impl_.angles_)*/nullptr
  , /*decltype(_impl_.force_)*/nullptr
  , /*decltype(_impl_.forcepos_)*/nullptr
  , /*decltype(_impl_.width_)*/0
  , /*decltype(_impl_.height_)*/0
  , /*decltype(_impl_.shardsize_)*/0
  , /*decltype(_impl_.surfacetype_)*/0u
  , /*decltype(_impl_.frontcolor_)*/0u
  , /*decltype(_impl_.backcolor_)*/0u} {}
struct CMsgTEShatterSurfaceDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgTEShatterSurfaceDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgTEShatterSurfaceDefaultTypeInternal() {}
  union {
    CMsgTEShatterSurface _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgTEShatterSurfaceDefaultTypeInternal _CMsgTEShatterSurface_default_instance_;
PROTOBUF_CONSTEXPR CMsgTEGlowSprite::CMsgTEGlowSprite(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.origin_)*/nullptr
  , /*decltype(_impl_.scale_)*/0
  , /*decltype(_impl_.life_)*/0
  , /*decltype(_impl_.brightness_)*/0u} {}
struct CMsgTEGlowSpriteDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgTEGlowSpriteDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgTEGlowSpriteDefaultTypeInternal() {}
  union {
    CMsgTEGlowSprite _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgTEGlowSpriteDefaultTypeInternal _CMsgTEGlowSprite_default_instance_;
PROTOBUF_CONSTEXPR CMsgTEImpact::CMsgTEImpact(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.origin_)*/nullptr
  , /*decltype(_impl_.normal_)*/nullptr
  , /*decltype(_impl_.type_)*/0u} {}
struct CMsgTEImpactDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgTEImpactDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgTEImpactDefaultTypeInternal() {}
  union {
    CMsgTEImpact _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgTEImpactDefaultTypeInternal _CMsgTEImpact_default_instance_;
PROTOBUF_CONSTEXPR CMsgTEMuzzleFlash::CMsgTEMuzzleFlash(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.origin_)*/nullptr
  , /*decltype(_impl_.angles_)*/nullptr
  , /*decltype(_impl_.scale_)*/0
  , /*decltype(_impl_.type_)*/0u} {}
struct CMsgTEMuzzleFlashDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgTEMuzzleFlashDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgTEMuzzleFlashDefaultTypeInternal() {}
  union {
    CMsgTEMuzzleFlash _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgTEMuzzleFlashDefaultTypeInternal _CMsgTEMuzzleFlash_default_instance_;
PROTOBUF_CONSTEXPR CMsgTEBloodStream::CMsgTEBloodStream(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.origin_)*/nullptr
  , /*decltype(_impl_.direction_)*/nullptr
  , /*decltype(_impl_.color_)*/0u
  , /*decltype(_impl_.amount_)*/0u} {}
struct CMsgTEBloodStreamDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgTEBloodStreamDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgTEBloodStreamDefaultTypeInternal() {}
  union {
    CMsgTEBloodStream _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgTEBloodStreamDefaultTypeInternal _CMsgTEBloodStream_default_instance_;
PROTOBUF_CONSTEXPR CMsgTEExplosion::CMsgTEExplosion(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.effect_name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.origin_)*/nullptr
  , /*decltype(_impl_.normal_)*/nullptr
  , /*decltype(_impl_.framerate_)*/0u
  , /*decltype(_impl_.flags_)*/0u
  , /*decltype(_impl_.materialtype_)*/0u
  , /*decltype(_impl_.radius_)*/0u
  , /*decltype(_impl_.magnitude_)*/0u
  , /*decltype(_impl_.scale_)*/0
  , /*decltype(_impl_.affect_ragdolls_)*/false
  , /*decltype(_impl_.explosion_type_)*/0u} {}
struct CMsgTEExplosionDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgTEExplosionDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgTEExplosionDefaultTypeInternal() {}
  union {
    CMsgTEExplosion _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgTEExplosionDefaultTypeInternal _CMsgTEExplosion_default_instance_;
PROTOBUF_CONSTEXPR CMsgTEDust::CMsgTEDust(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.origin_)*/nullptr
  , /*decltype(_impl_.direction_)*/nullptr
  , /*decltype(_impl_.size_)*/0
  , /*decltype(_impl_.speed_)*/0} {}
struct CMsgTEDustDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgTEDustDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgTEDustDefaultTypeInternal() {}
  union {
    CMsgTEDust _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgTEDustDefaultTypeInternal _CMsgTEDust_default_instance_;
PROTOBUF_CONSTEXPR CMsgTELargeFunnel::CMsgTELargeFunnel(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.origin_)*/nullptr
  , /*decltype(_impl_.reversed_)*/0u} {}
struct CMsgTELargeFunnelDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgTELargeFunnelDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgTELargeFunnelDefaultTypeInternal() {}
  union {
    CMsgTELargeFunnel _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgTELargeFunnelDefaultTypeInternal _CMsgTELargeFunnel_default_instance_;
PROTOBUF_CONSTEXPR CMsgTESparks::CMsgTESparks(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.origin_)*/nullptr
  , /*decltype(_impl_.direction_)*/nullptr
  , /*decltype(_impl_.magnitude_)*/0u
  , /*decltype(_impl_.length_)*/0u} {}
struct CMsgTESparksDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgTESparksDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgTESparksDefaultTypeInternal() {}
  union {
    CMsgTESparks _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgTESparksDefaultTypeInternal _CMsgTESparks_default_instance_;
PROTOBUF_CONSTEXPR CMsgTEPhysicsProp::CMsgTEPhysicsProp(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.origin_)*/nullptr
  , /*decltype(_impl_.velocity_)*/nullptr
  , /*decltype(_impl_.angles_)*/nullptr
  , /*decltype(_impl_.dmgpos_)*/nullptr
  , /*decltype(_impl_.dmgdir_)*/nullptr
  , /*decltype(_impl_.skin_)*/0u
  , /*decltype(_impl_.flags_)*/0u
  , /*decltype(_impl_.effects_)*/0u
  , /*decltype(_impl_.color_)*/0u
  , /*decltype(_impl_.modelindex_)*/uint64_t{0u}
  , /*decltype(_impl_.unused_breakmodelsnottomake_)*/0u
  , /*decltype(_impl_.scale_)*/0
  , /*decltype(_impl_.dmgtype_)*/0} {}
struct CMsgTEPhysicsPropDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgTEPhysicsPropDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgTEPhysicsPropDefaultTypeInternal() {}
  union {
    CMsgTEPhysicsProp _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgTEPhysicsPropDefaultTypeInternal _CMsgTEPhysicsProp_default_instance_;
PROTOBUF_CONSTEXPR CMsgTEPlayerDecal::CMsgTEPlayerDecal(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.origin_)*/nullptr
  , /*decltype(_impl_.player_)*/-1
  , /*decltype(_impl_.entity_)*/-1} {}
struct CMsgTEPlayerDecalDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgTEPlayerDecalDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgTEPlayerDecalDefaultTypeInternal() {}
  union {
    CMsgTEPlayerDecal _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgTEPlayerDecalDefaultTypeInternal _CMsgTEPlayerDecal_default_instance_;
PROTOBUF_CONSTEXPR CMsgTEProjectedDecal::CMsgTEProjectedDecal(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.origin_)*/nullptr
  , /*decltype(_impl_.angles_)*/nullptr
  , /*decltype(_impl_.index_)*/0u
  , /*decltype(_impl_.distance_)*/0} {}
struct CMsgTEProjectedDecalDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgTEProjectedDecalDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgTEProjectedDecalDefaultTypeInternal() {}
  union {
    CMsgTEProjectedDecal _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgTEProjectedDecalDefaultTypeInternal _CMsgTEProjectedDecal_default_instance_;
PROTOBUF_CONSTEXPR CMsgTESmoke::CMsgTESmoke(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.origin_)*/nullptr
  , /*decltype(_impl_.scale_)*/0} {}
struct CMsgTESmokeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgTESmokeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgTESmokeDefaultTypeInternal() {}
  union {
    CMsgTESmoke _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgTESmokeDefaultTypeInternal _CMsgTESmoke_default_instance_;
PROTOBUF_CONSTEXPR CMsgTEWorldDecal::CMsgTEWorldDecal(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.origin_)*/nullptr
  , /*decltype(_impl_.normal_)*/nullptr
  , /*decltype(_impl_.index_)*/0u} {}
struct CMsgTEWorldDecalDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CMsgTEWorldDecalDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CMsgTEWorldDecalDefaultTypeInternal() {}
  union {
    CMsgTEWorldDecal _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CMsgTEWorldDecalDefaultTypeInternal _CMsgTEWorldDecal_default_instance_;
static ::_pb::Metadata file_level_metadata_te_2eproto[28];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_te_2eproto[1];
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_te_2eproto = nullptr;

const uint32_t TableStruct_te_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::CMsgTEArmorRicochet, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEArmorRicochet, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgTEArmorRicochet, _impl_.pos_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEArmorRicochet, _impl_.dir_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::CMsgTEBaseBeam, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEBaseBeam, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgTEBaseBeam, _impl_.modelindex_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEBaseBeam, _impl_.haloindex_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEBaseBeam, _impl_.startframe_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEBaseBeam, _impl_.framerate_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEBaseBeam, _impl_.life_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEBaseBeam, _impl_.width_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEBaseBeam, _impl_.endwidth_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEBaseBeam, _impl_.fadelength_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEBaseBeam, _impl_.amplitude_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEBaseBeam, _impl_.color_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEBaseBeam, _impl_.speed_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEBaseBeam, _impl_.flags_),
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  PROTOBUF_FIELD_OFFSET(::CMsgTEBeamEntPoint, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEBeamEntPoint, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgTEBeamEntPoint, _impl_.base_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEBeamEntPoint, _impl_.startentity_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEBeamEntPoint, _impl_.endentity_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEBeamEntPoint, _impl_.start_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEBeamEntPoint, _impl_.end_),
  0,
  3,
  4,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::CMsgTEBeamEnts, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEBeamEnts, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgTEBeamEnts, _impl_.base_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEBeamEnts, _impl_.startentity_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEBeamEnts, _impl_.endentity_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::CMsgTEBeamPoints, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEBeamPoints, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgTEBeamPoints, _impl_.base_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEBeamPoints, _impl_.start_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEBeamPoints, _impl_.end_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::CMsgTEBeamRing, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEBeamRing, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgTEBeamRing, _impl_.base_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEBeamRing, _impl_.startentity_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEBeamRing, _impl_.endentity_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::CMsgTEBSPDecal, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEBSPDecal, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgTEBSPDecal, _impl_.origin_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEBSPDecal, _impl_.normal_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEBSPDecal, _impl_.saxis_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEBSPDecal, _impl_.entity_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEBSPDecal, _impl_.index_),
  0,
  1,
  2,
  4,
  3,
  PROTOBUF_FIELD_OFFSET(::CMsgTEBubbles, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEBubbles, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgTEBubbles, _impl_.mins_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEBubbles, _impl_.maxs_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEBubbles, _impl_.height_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEBubbles, _impl_.count_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEBubbles, _impl_.speed_),
  0,
  1,
  2,
  3,
  4,
  PROTOBUF_FIELD_OFFSET(::CMsgTEBubbleTrail, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEBubbleTrail, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgTEBubbleTrail, _impl_.mins_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEBubbleTrail, _impl_.maxs_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEBubbleTrail, _impl_.waterz_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEBubbleTrail, _impl_.count_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEBubbleTrail, _impl_.speed_),
  0,
  1,
  2,
  3,
  4,
  PROTOBUF_FIELD_OFFSET(::CMsgTEDecal, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEDecal, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgTEDecal, _impl_.origin_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEDecal, _impl_.start_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEDecal, _impl_.entity_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEDecal, _impl_.hitbox_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEDecal, _impl_.index_),
  0,
  1,
  4,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::CMsgEffectData, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgEffectData, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgEffectData, _impl_.origin_),
  PROTOBUF_FIELD_OFFSET(::CMsgEffectData, _impl_.start_),
  PROTOBUF_FIELD_OFFSET(::CMsgEffectData, _impl_.normal_),
  PROTOBUF_FIELD_OFFSET(::CMsgEffectData, _impl_.angles_),
  PROTOBUF_FIELD_OFFSET(::CMsgEffectData, _impl_.entity_),
  PROTOBUF_FIELD_OFFSET(::CMsgEffectData, _impl_.otherentity_),
  PROTOBUF_FIELD_OFFSET(::CMsgEffectData, _impl_.scale_),
  PROTOBUF_FIELD_OFFSET(::CMsgEffectData, _impl_.magnitude_),
  PROTOBUF_FIELD_OFFSET(::CMsgEffectData, _impl_.radius_),
  PROTOBUF_FIELD_OFFSET(::CMsgEffectData, _impl_.surfaceprop_),
  PROTOBUF_FIELD_OFFSET(::CMsgEffectData, _impl_.effectindex_),
  PROTOBUF_FIELD_OFFSET(::CMsgEffectData, _impl_.damagetype_),
  PROTOBUF_FIELD_OFFSET(::CMsgEffectData, _impl_.material_),
  PROTOBUF_FIELD_OFFSET(::CMsgEffectData, _impl_.hitbox_),
  PROTOBUF_FIELD_OFFSET(::CMsgEffectData, _impl_.color_),
  PROTOBUF_FIELD_OFFSET(::CMsgEffectData, _impl_.flags_),
  PROTOBUF_FIELD_OFFSET(::CMsgEffectData, _impl_.attachmentindex_),
  PROTOBUF_FIELD_OFFSET(::CMsgEffectData, _impl_.effectname_),
  PROTOBUF_FIELD_OFFSET(::CMsgEffectData, _impl_.attachmentname_),
  0,
  1,
  2,
  3,
  17,
  18,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  16,
  PROTOBUF_FIELD_OFFSET(::CMsgTEEffectDispatch, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEEffectDispatch, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgTEEffectDispatch, _impl_.effectdata_),
  0,
  PROTOBUF_FIELD_OFFSET(::CMsgTEEnergySplash, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEEnergySplash, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgTEEnergySplash, _impl_.pos_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEEnergySplash, _impl_.dir_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEEnergySplash, _impl_.explosive_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::CMsgTEFizz, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEFizz, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgTEFizz, _impl_.entity_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEFizz, _impl_.density_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEFizz, _impl_.current_),
  2,
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::CMsgTEShatterSurface, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEShatterSurface, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgTEShatterSurface, _impl_.origin_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEShatterSurface, _impl_.angles_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEShatterSurface, _impl_.force_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEShatterSurface, _impl_.forcepos_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEShatterSurface, _impl_.width_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEShatterSurface, _impl_.height_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEShatterSurface, _impl_.shardsize_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEShatterSurface, _impl_.surfacetype_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEShatterSurface, _impl_.frontcolor_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEShatterSurface, _impl_.backcolor_),
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  PROTOBUF_FIELD_OFFSET(::CMsgTEGlowSprite, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEGlowSprite, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgTEGlowSprite, _impl_.origin_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEGlowSprite, _impl_.scale_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEGlowSprite, _impl_.life_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEGlowSprite, _impl_.brightness_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::CMsgTEImpact, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEImpact, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgTEImpact, _impl_.origin_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEImpact, _impl_.normal_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEImpact, _impl_.type_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::CMsgTEMuzzleFlash, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEMuzzleFlash, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgTEMuzzleFlash, _impl_.origin_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEMuzzleFlash, _impl_.angles_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEMuzzleFlash, _impl_.scale_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEMuzzleFlash, _impl_.type_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::CMsgTEBloodStream, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEBloodStream, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgTEBloodStream, _impl_.origin_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEBloodStream, _impl_.direction_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEBloodStream, _impl_.color_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEBloodStream, _impl_.amount_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::CMsgTEExplosion, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEExplosion, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgTEExplosion, _impl_.origin_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEExplosion, _impl_.framerate_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEExplosion, _impl_.flags_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEExplosion, _impl_.normal_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEExplosion, _impl_.materialtype_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEExplosion, _impl_.radius_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEExplosion, _impl_.magnitude_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEExplosion, _impl_.scale_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEExplosion, _impl_.affect_ragdolls_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEExplosion, _impl_.effect_name_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEExplosion, _impl_.explosion_type_),
  1,
  3,
  4,
  2,
  5,
  6,
  7,
  8,
  9,
  0,
  10,
  PROTOBUF_FIELD_OFFSET(::CMsgTEDust, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEDust, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgTEDust, _impl_.origin_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEDust, _impl_.size_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEDust, _impl_.speed_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEDust, _impl_.direction_),
  0,
  2,
  3,
  1,
  PROTOBUF_FIELD_OFFSET(::CMsgTELargeFunnel, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgTELargeFunnel, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgTELargeFunnel, _impl_.origin_),
  PROTOBUF_FIELD_OFFSET(::CMsgTELargeFunnel, _impl_.reversed_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::CMsgTESparks, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgTESparks, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgTESparks, _impl_.origin_),
  PROTOBUF_FIELD_OFFSET(::CMsgTESparks, _impl_.magnitude_),
  PROTOBUF_FIELD_OFFSET(::CMsgTESparks, _impl_.length_),
  PROTOBUF_FIELD_OFFSET(::CMsgTESparks, _impl_.direction_),
  0,
  2,
  3,
  1,
  PROTOBUF_FIELD_OFFSET(::CMsgTEPhysicsProp, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEPhysicsProp, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgTEPhysicsProp, _impl_.origin_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEPhysicsProp, _impl_.velocity_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEPhysicsProp, _impl_.angles_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEPhysicsProp, _impl_.skin_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEPhysicsProp, _impl_.flags_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEPhysicsProp, _impl_.effects_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEPhysicsProp, _impl_.color_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEPhysicsProp, _impl_.modelindex_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEPhysicsProp, _impl_.unused_breakmodelsnottomake_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEPhysicsProp, _impl_.scale_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEPhysicsProp, _impl_.dmgpos_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEPhysicsProp, _impl_.dmgdir_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEPhysicsProp, _impl_.dmgtype_),
  0,
  1,
  2,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  3,
  4,
  12,
  PROTOBUF_FIELD_OFFSET(::CMsgTEPlayerDecal, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEPlayerDecal, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgTEPlayerDecal, _impl_.origin_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEPlayerDecal, _impl_.player_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEPlayerDecal, _impl_.entity_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::CMsgTEProjectedDecal, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEProjectedDecal, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgTEProjectedDecal, _impl_.origin_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEProjectedDecal, _impl_.angles_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEProjectedDecal, _impl_.index_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEProjectedDecal, _impl_.distance_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::CMsgTESmoke, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgTESmoke, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgTESmoke, _impl_.origin_),
  PROTOBUF_FIELD_OFFSET(::CMsgTESmoke, _impl_.scale_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::CMsgTEWorldDecal, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEWorldDecal, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::CMsgTEWorldDecal, _impl_.origin_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEWorldDecal, _impl_.normal_),
  PROTOBUF_FIELD_OFFSET(::CMsgTEWorldDecal, _impl_.index_),
  0,
  1,
  2,
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 8, -1, sizeof(::CMsgTEArmorRicochet)},
  { 10, 28, -1, sizeof(::CMsgTEBaseBeam)},
  { 40, 51, -1, sizeof(::CMsgTEBeamEntPoint)},
  { 56, 65, -1, sizeof(::CMsgTEBeamEnts)},
  { 68, 77, -1, sizeof(::CMsgTEBeamPoints)},
  { 80, 89, -1, sizeof(::CMsgTEBeamRing)},
  { 92, 103, -1, sizeof(::CMsgTEBSPDecal)},
  { 108, 119, -1, sizeof(::CMsgTEBubbles)},
  { 124, 135, -1, sizeof(::CMsgTEBubbleTrail)},
  { 140, 151, -1, sizeof(::CMsgTEDecal)},
  { 156, 181, -1, sizeof(::CMsgEffectData)},
  { 200, 207, -1, sizeof(::CMsgTEEffectDispatch)},
  { 208, 217, -1, sizeof(::CMsgTEEnergySplash)},
  { 220, 229, -1, sizeof(::CMsgTEFizz)},
  { 232, 248, -1, sizeof(::CMsgTEShatterSurface)},
  { 258, 268, -1, sizeof(::CMsgTEGlowSprite)},
  { 272, 281, -1, sizeof(::CMsgTEImpact)},
  { 284, 294, -1, sizeof(::CMsgTEMuzzleFlash)},
  { 298, 308, -1, sizeof(::CMsgTEBloodStream)},
  { 312, 329, -1, sizeof(::CMsgTEExplosion)},
  { 340, 350, -1, sizeof(::CMsgTEDust)},
  { 354, 362, -1, sizeof(::CMsgTELargeFunnel)},
  { 364, 374, -1, sizeof(::CMsgTESparks)},
  { 378, 397, -1, sizeof(::CMsgTEPhysicsProp)},
  { 410, 419, -1, sizeof(::CMsgTEPlayerDecal)},
  { 422, 432, -1, sizeof(::CMsgTEProjectedDecal)},
  { 436, 444, -1, sizeof(::CMsgTESmoke)},
  { 446, 455, -1, sizeof(::CMsgTEWorldDecal)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::_CMsgTEArmorRicochet_default_instance_._instance,
  &::_CMsgTEBaseBeam_default_instance_._instance,
  &::_CMsgTEBeamEntPoint_default_instance_._instance,
  &::_CMsgTEBeamEnts_default_instance_._instance,
  &::_CMsgTEBeamPoints_default_instance_._instance,
  &::_CMsgTEBeamRing_default_instance_._instance,
  &::_CMsgTEBSPDecal_default_instance_._instance,
  &::_CMsgTEBubbles_default_instance_._instance,
  &::_CMsgTEBubbleTrail_default_instance_._instance,
  &::_CMsgTEDecal_default_instance_._instance,
  &::_CMsgEffectData_default_instance_._instance,
  &::_CMsgTEEffectDispatch_default_instance_._instance,
  &::_CMsgTEEnergySplash_default_instance_._instance,
  &::_CMsgTEFizz_default_instance_._instance,
  &::_CMsgTEShatterSurface_default_instance_._instance,
  &::_CMsgTEGlowSprite_default_instance_._instance,
  &::_CMsgTEImpact_default_instance_._instance,
  &::_CMsgTEMuzzleFlash_default_instance_._instance,
  &::_CMsgTEBloodStream_default_instance_._instance,
  &::_CMsgTEExplosion_default_instance_._instance,
  &::_CMsgTEDust_default_instance_._instance,
  &::_CMsgTELargeFunnel_default_instance_._instance,
  &::_CMsgTESparks_default_instance_._instance,
  &::_CMsgTEPhysicsProp_default_instance_._instance,
  &::_CMsgTEPlayerDecal_default_instance_._instance,
  &::_CMsgTEProjectedDecal_default_instance_._instance,
  &::_CMsgTESmoke_default_instance_._instance,
  &::_CMsgTEWorldDecal_default_instance_._instance,
};

const char descriptor_table_protodef_te_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\010te.proto\032\026networkbasetypes.proto\"I\n\023CM"
  "sgTEArmorRicochet\022\030\n\003pos\030\001 \001(\0132\013.CMsgVec"
  "tor\022\030\n\003dir\030\002 \001(\0132\013.CMsgVector\"\341\001\n\016CMsgTE"
  "BaseBeam\022\022\n\nmodelindex\030\001 \001(\006\022\021\n\thaloinde"
  "x\030\002 \001(\006\022\022\n\nstartframe\030\003 \001(\r\022\021\n\tframerate"
  "\030\004 \001(\r\022\014\n\004life\030\005 \001(\002\022\r\n\005width\030\006 \001(\002\022\020\n\010e"
  "ndwidth\030\007 \001(\002\022\022\n\nfadelength\030\010 \001(\r\022\021\n\tamp"
  "litude\030\t \001(\002\022\r\n\005color\030\n \001(\007\022\r\n\005speed\030\013 \001"
  "(\r\022\r\n\005flags\030\014 \001(\r\"\221\001\n\022CMsgTEBeamEntPoint"
  "\022\035\n\004base\030\001 \001(\0132\017.CMsgTEBaseBeam\022\023\n\013start"
  "entity\030\002 \001(\r\022\021\n\tendentity\030\003 \001(\r\022\032\n\005start"
  "\030\004 \001(\0132\013.CMsgVector\022\030\n\003end\030\005 \001(\0132\013.CMsgV"
  "ector\"W\n\016CMsgTEBeamEnts\022\035\n\004base\030\001 \001(\0132\017."
  "CMsgTEBaseBeam\022\023\n\013startentity\030\002 \001(\r\022\021\n\te"
  "ndentity\030\003 \001(\r\"g\n\020CMsgTEBeamPoints\022\035\n\004ba"
  "se\030\001 \001(\0132\017.CMsgTEBaseBeam\022\032\n\005start\030\002 \001(\013"
  "2\013.CMsgVector\022\030\n\003end\030\003 \001(\0132\013.CMsgVector\""
  "W\n\016CMsgTEBeamRing\022\035\n\004base\030\001 \001(\0132\017.CMsgTE"
  "BaseBeam\022\023\n\013startentity\030\002 \001(\r\022\021\n\tendenti"
  "ty\030\003 \001(\r\"\211\001\n\016CMsgTEBSPDecal\022\033\n\006origin\030\001 "
  "\001(\0132\013.CMsgVector\022\033\n\006normal\030\002 \001(\0132\013.CMsgV"
  "ector\022\032\n\005saxis\030\003 \001(\0132\013.CMsgVector\022\022\n\006ent"
  "ity\030\004 \001(\005:\002-1\022\r\n\005index\030\005 \001(\r\"s\n\rCMsgTEBu"
  "bbles\022\031\n\004mins\030\001 \001(\0132\013.CMsgVector\022\031\n\004maxs"
  "\030\002 \001(\0132\013.CMsgVector\022\016\n\006height\030\003 \001(\002\022\r\n\005c"
  "ount\030\004 \001(\r\022\r\n\005speed\030\005 \001(\002\"w\n\021CMsgTEBubbl"
  "eTrail\022\031\n\004mins\030\001 \001(\0132\013.CMsgVector\022\031\n\004max"
  "s\030\002 \001(\0132\013.CMsgVector\022\016\n\006waterz\030\003 \001(\002\022\r\n\005"
  "count\030\004 \001(\r\022\r\n\005speed\030\005 \001(\002\"y\n\013CMsgTEDeca"
  "l\022\033\n\006origin\030\001 \001(\0132\013.CMsgVector\022\032\n\005start\030"
  "\002 \001(\0132\013.CMsgVector\022\022\n\006entity\030\003 \001(\005:\002-1\022\016"
  "\n\006hitbox\030\004 \001(\r\022\r\n\005index\030\005 \001(\r\"\261\003\n\016CMsgEf"
  "fectData\022\033\n\006origin\030\001 \001(\0132\013.CMsgVector\022\032\n"
  "\005start\030\002 \001(\0132\013.CMsgVector\022\033\n\006normal\030\003 \001("
  "\0132\013.CMsgVector\022\033\n\006angles\030\004 \001(\0132\013.CMsgQAn"
  "gle\022\030\n\006entity\030\005 \001(\007:\01016777215\022\035\n\013otheren"
  "tity\030\006 \001(\007:\01016777215\022\r\n\005scale\030\007 \001(\002\022\021\n\tm"
  "agnitude\030\010 \001(\002\022\016\n\006radius\030\t \001(\002\022\023\n\013surfac"
  "eprop\030\n \001(\007\022\023\n\013effectindex\030\013 \001(\006\022\022\n\ndama"
  "getype\030\014 \001(\r\022\020\n\010material\030\r \001(\r\022\016\n\006hitbox"
  "\030\016 \001(\r\022\r\n\005color\030\017 \001(\r\022\r\n\005flags\030\020 \001(\r\022\027\n\017"
  "attachmentindex\030\021 \001(\005\022\022\n\neffectname\030\022 \001("
  "\r\022\026\n\016attachmentname\030\023 \001(\r\";\n\024CMsgTEEffec"
  "tDispatch\022#\n\neffectdata\030\001 \001(\0132\017.CMsgEffe"
  "ctData\"[\n\022CMsgTEEnergySplash\022\030\n\003pos\030\001 \001("
  "\0132\013.CMsgVector\022\030\n\003dir\030\002 \001(\0132\013.CMsgVector"
  "\022\021\n\texplosive\030\003 \001(\010\"B\n\nCMsgTEFizz\022\022\n\006ent"
  "ity\030\001 \001(\005:\002-1\022\017\n\007density\030\002 \001(\r\022\017\n\007curren"
  "t\030\003 \001(\005\"\371\001\n\024CMsgTEShatterSurface\022\033\n\006orig"
  "in\030\001 \001(\0132\013.CMsgVector\022\033\n\006angles\030\002 \001(\0132\013."
  "CMsgQAngle\022\032\n\005force\030\003 \001(\0132\013.CMsgVector\022\035"
  "\n\010forcepos\030\004 \001(\0132\013.CMsgVector\022\r\n\005width\030\005"
  " \001(\002\022\016\n\006height\030\006 \001(\002\022\021\n\tshardsize\030\007 \001(\002\022"
  "\023\n\013surfacetype\030\010 \001(\r\022\022\n\nfrontcolor\030\t \001(\007"
  "\022\021\n\tbackcolor\030\n \001(\007\"`\n\020CMsgTEGlowSprite\022"
  "\033\n\006origin\030\001 \001(\0132\013.CMsgVector\022\r\n\005scale\030\002 "
  "\001(\002\022\014\n\004life\030\003 \001(\002\022\022\n\nbrightness\030\004 \001(\r\"V\n"
  "\014CMsgTEImpact\022\033\n\006origin\030\001 \001(\0132\013.CMsgVect"
  "or\022\033\n\006normal\030\002 \001(\0132\013.CMsgVector\022\014\n\004type\030"
  "\003 \001(\r\"j\n\021CMsgTEMuzzleFlash\022\033\n\006origin\030\001 \001"
  "(\0132\013.CMsgVector\022\033\n\006angles\030\002 \001(\0132\013.CMsgQA"
  "ngle\022\r\n\005scale\030\003 \001(\002\022\014\n\004type\030\004 \001(\r\"o\n\021CMs"
  "gTEBloodStream\022\033\n\006origin\030\001 \001(\0132\013.CMsgVec"
  "tor\022\036\n\tdirection\030\002 \001(\0132\013.CMsgVector\022\r\n\005c"
  "olor\030\003 \001(\007\022\016\n\006amount\030\004 \001(\r\"\373\001\n\017CMsgTEExp"
  "losion\022\033\n\006origin\030\001 \001(\0132\013.CMsgVector\022\021\n\tf"
  "ramerate\030\002 \001(\r\022\r\n\005flags\030\003 \001(\r\022\033\n\006normal\030"
  "\004 \001(\0132\013.CMsgVector\022\024\n\014materialtype\030\005 \001(\r"
  "\022\016\n\006radius\030\006 \001(\r\022\021\n\tmagnitude\030\007 \001(\r\022\r\n\005s"
  "cale\030\010 \001(\002\022\027\n\017affect_ragdolls\030\t \001(\010\022\023\n\013e"
  "ffect_name\030\n \001(\t\022\026\n\016explosion_type\030\013 \001(\r"
  "\"f\n\nCMsgTEDust\022\033\n\006origin\030\001 \001(\0132\013.CMsgVec"
  "tor\022\014\n\004size\030\002 \001(\002\022\r\n\005speed\030\003 \001(\002\022\036\n\tdire"
  "ction\030\004 \001(\0132\013.CMsgVector\"B\n\021CMsgTELargeF"
  "unnel\022\033\n\006origin\030\001 \001(\0132\013.CMsgVector\022\020\n\010re"
  "versed\030\002 \001(\r\"n\n\014CMsgTESparks\022\033\n\006origin\030\001"
  " \001(\0132\013.CMsgVector\022\021\n\tmagnitude\030\002 \001(\r\022\016\n\006"
  "length\030\003 \001(\r\022\036\n\tdirection\030\004 \001(\0132\013.CMsgVe"
  "ctor\"\274\002\n\021CMsgTEPhysicsProp\022\033\n\006origin\030\001 \001"
  "(\0132\013.CMsgVector\022\035\n\010velocity\030\002 \001(\0132\013.CMsg"
  "Vector\022\033\n\006angles\030\003 \001(\0132\013.CMsgQAngle\022\014\n\004s"
  "kin\030\004 \001(\007\022\r\n\005flags\030\005 \001(\r\022\017\n\007effects\030\006 \001("
  "\r\022\r\n\005color\030\007 \001(\007\022\022\n\nmodelindex\030\010 \001(\006\022#\n\033"
  "unused_breakmodelsnottomake\030\t \001(\r\022\r\n\005sca"
  "le\030\n \001(\002\022\033\n\006dmgpos\030\013 \001(\0132\013.CMsgVector\022\033\n"
  "\006dmgdir\030\014 \001(\0132\013.CMsgVector\022\017\n\007dmgtype\030\r "
  "\001(\005\"X\n\021CMsgTEPlayerDecal\022\033\n\006origin\030\001 \001(\013"
  "2\013.CMsgVector\022\022\n\006player\030\002 \001(\005:\002-1\022\022\n\006ent"
  "ity\030\003 \001(\005:\002-1\"q\n\024CMsgTEProjectedDecal\022\033\n"
  "\006origin\030\001 \001(\0132\013.CMsgVector\022\033\n\006angles\030\002 \001"
  "(\0132\013.CMsgQAngle\022\r\n\005index\030\003 \001(\r\022\020\n\010distan"
  "ce\030\004 \001(\002\"9\n\013CMsgTESmoke\022\033\n\006origin\030\001 \001(\0132"
  "\013.CMsgVector\022\r\n\005scale\030\002 \001(\002\"[\n\020CMsgTEWor"
  "ldDecal\022\033\n\006origin\030\001 \001(\0132\013.CMsgVector\022\033\n\006"
  "normal\030\002 \001(\0132\013.CMsgVector\022\r\n\005index\030\003 \001(\r"
  "*\275\004\n\016ETEProtobufIds\022\030\n\023TE_EffectDispatch"
  "Id\020\220\003\022\027\n\022TE_ArmorRicochetId\020\221\003\022\026\n\021TE_Bea"
  "mEntPointId\020\222\003\022\022\n\rTE_BeamEntsId\020\223\003\022\024\n\017TE"
  "_BeamPointsId\020\224\003\022\022\n\rTE_BeamRingId\020\225\003\022\022\n\r"
  "TE_BSPDecalId\020\227\003\022\021\n\014TE_BubblesId\020\230\003\022\025\n\020T"
  "E_BubbleTrailId\020\231\003\022\017\n\nTE_DecalId\020\232\003\022\024\n\017T"
  "E_WorldDecalId\020\233\003\022\026\n\021TE_EnergySplashId\020\234"
  "\003\022\016\n\tTE_FizzId\020\235\003\022\030\n\023TE_ShatterSurfaceId"
  "\020\236\003\022\024\n\017TE_GlowSpriteId\020\237\003\022\020\n\013TE_ImpactId"
  "\020\240\003\022\025\n\020TE_MuzzleFlashId\020\241\003\022\025\n\020TE_BloodSt"
  "reamId\020\242\003\022\023\n\016TE_ExplosionId\020\243\003\022\016\n\tTE_Dus"
  "tId\020\244\003\022\025\n\020TE_LargeFunnelId\020\245\003\022\020\n\013TE_Spar"
  "ksId\020\246\003\022\025\n\020TE_PhysicsPropId\020\247\003\022\025\n\020TE_Pla"
  "yerDecalId\020\250\003\022\030\n\023TE_ProjectedDecalId\020\251\003\022"
  "\017\n\nTE_SmokeId\020\252\003"
  ;
static const ::_pbi::DescriptorTable* const descriptor_table_te_2eproto_deps[1] = {
  &::descriptor_table_networkbasetypes_2eproto,
};
static ::_pbi::once_flag descriptor_table_te_2eproto_once;
const ::_pbi::DescriptorTable descriptor_table_te_2eproto = {
    false, false, 4376, descriptor_table_protodef_te_2eproto,
    "te.proto",
    &descriptor_table_te_2eproto_once, descriptor_table_te_2eproto_deps, 1, 28,
    schemas, file_default_instances, TableStruct_te_2eproto::offsets,
    file_level_metadata_te_2eproto, file_level_enum_descriptors_te_2eproto,
    file_level_service_descriptors_te_2eproto,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_te_2eproto_getter() {
  return &descriptor_table_te_2eproto;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_te_2eproto(&descriptor_table_te_2eproto);
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ETEProtobufIds_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_te_2eproto);
  return file_level_enum_descriptors_te_2eproto[0];
}
bool ETEProtobufIds_IsValid(int value) {
  switch (value) {
    case 400:
    case 401:
    case 402:
    case 403:
    case 404:
    case 405:
    case 407:
    case 408:
    case 409:
    case 410:
    case 411:
    case 412:
    case 413:
    case 414:
    case 415:
    case 416:
    case 417:
    case 418:
    case 419:
    case 420:
    case 421:
    case 422:
    case 423:
    case 424:
    case 425:
    case 426:
      return true;
    default:
      return false;
  }
}


// ===================================================================

class CMsgTEArmorRicochet::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgTEArmorRicochet>()._impl_._has_bits_);
  static const ::CMsgVector& pos(const CMsgTEArmorRicochet* msg);
  static void set_has_pos(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::CMsgVector& dir(const CMsgTEArmorRicochet* msg);
  static void set_has_dir(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::CMsgVector&
CMsgTEArmorRicochet::_Internal::pos(const CMsgTEArmorRicochet* msg) {
  return *msg->_impl_.pos_;
}
const ::CMsgVector&
CMsgTEArmorRicochet::_Internal::dir(const CMsgTEArmorRicochet* msg) {
  return *msg->_impl_.dir_;
}
void CMsgTEArmorRicochet::clear_pos() {
  if (_impl_.pos_ != nullptr) _impl_.pos_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void CMsgTEArmorRicochet::clear_dir() {
  if (_impl_.dir_ != nullptr) _impl_.dir_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
CMsgTEArmorRicochet::CMsgTEArmorRicochet(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgTEArmorRicochet)
}
CMsgTEArmorRicochet::CMsgTEArmorRicochet(const CMsgTEArmorRicochet& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgTEArmorRicochet* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.pos_){nullptr}
    , decltype(_impl_.dir_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_pos()) {
    _this->_impl_.pos_ = new ::CMsgVector(*from._impl_.pos_);
  }
  if (from._internal_has_dir()) {
    _this->_impl_.dir_ = new ::CMsgVector(*from._impl_.dir_);
  }
  // @@protoc_insertion_point(copy_constructor:CMsgTEArmorRicochet)
}

inline void CMsgTEArmorRicochet::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.pos_){nullptr}
    , decltype(_impl_.dir_){nullptr}
  };
}

CMsgTEArmorRicochet::~CMsgTEArmorRicochet() {
  // @@protoc_insertion_point(destructor:CMsgTEArmorRicochet)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgTEArmorRicochet::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.pos_;
  if (this != internal_default_instance()) delete _impl_.dir_;
}

void CMsgTEArmorRicochet::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgTEArmorRicochet::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgTEArmorRicochet)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.pos_ != nullptr);
      _impl_.pos_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.dir_ != nullptr);
      _impl_.dir_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgTEArmorRicochet::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .CMsgVector pos = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_pos(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgVector dir = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_dir(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgTEArmorRicochet::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgTEArmorRicochet)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .CMsgVector pos = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::pos(this),
        _Internal::pos(this).GetCachedSize(), target, stream);
  }

  // optional .CMsgVector dir = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::dir(this),
        _Internal::dir(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgTEArmorRicochet)
  return target;
}

size_t CMsgTEArmorRicochet::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgTEArmorRicochet)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .CMsgVector pos = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.pos_);
    }

    // optional .CMsgVector dir = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.dir_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgTEArmorRicochet::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgTEArmorRicochet::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgTEArmorRicochet::GetClassData() const { return &_class_data_; }


void CMsgTEArmorRicochet::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgTEArmorRicochet*>(&to_msg);
  auto& from = static_cast<const CMsgTEArmorRicochet&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgTEArmorRicochet)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_pos()->::CMsgVector::MergeFrom(
          from._internal_pos());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_dir()->::CMsgVector::MergeFrom(
          from._internal_dir());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgTEArmorRicochet::CopyFrom(const CMsgTEArmorRicochet& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgTEArmorRicochet)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgTEArmorRicochet::IsInitialized() const {
  return true;
}

void CMsgTEArmorRicochet::InternalSwap(CMsgTEArmorRicochet* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgTEArmorRicochet, _impl_.dir_)
      + sizeof(CMsgTEArmorRicochet::_impl_.dir_)
      - PROTOBUF_FIELD_OFFSET(CMsgTEArmorRicochet, _impl_.pos_)>(
          reinterpret_cast<char*>(&_impl_.pos_),
          reinterpret_cast<char*>(&other->_impl_.pos_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgTEArmorRicochet::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_te_2eproto_getter, &descriptor_table_te_2eproto_once,
      file_level_metadata_te_2eproto[0]);
}

// ===================================================================

class CMsgTEBaseBeam::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgTEBaseBeam>()._impl_._has_bits_);
  static void set_has_modelindex(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_haloindex(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_startframe(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_framerate(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_life(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_width(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_endwidth(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_fadelength(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_amplitude(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_color(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_speed(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
};

CMsgTEBaseBeam::CMsgTEBaseBeam(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgTEBaseBeam)
}
CMsgTEBaseBeam::CMsgTEBaseBeam(const CMsgTEBaseBeam& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgTEBaseBeam* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.modelindex_){}
    , decltype(_impl_.haloindex_){}
    , decltype(_impl_.startframe_){}
    , decltype(_impl_.framerate_){}
    , decltype(_impl_.life_){}
    , decltype(_impl_.width_){}
    , decltype(_impl_.endwidth_){}
    , decltype(_impl_.fadelength_){}
    , decltype(_impl_.amplitude_){}
    , decltype(_impl_.color_){}
    , decltype(_impl_.speed_){}
    , decltype(_impl_.flags_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.modelindex_, &from._impl_.modelindex_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.flags_) -
    reinterpret_cast<char*>(&_impl_.modelindex_)) + sizeof(_impl_.flags_));
  // @@protoc_insertion_point(copy_constructor:CMsgTEBaseBeam)
}

inline void CMsgTEBaseBeam::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.modelindex_){uint64_t{0u}}
    , decltype(_impl_.haloindex_){uint64_t{0u}}
    , decltype(_impl_.startframe_){0u}
    , decltype(_impl_.framerate_){0u}
    , decltype(_impl_.life_){0}
    , decltype(_impl_.width_){0}
    , decltype(_impl_.endwidth_){0}
    , decltype(_impl_.fadelength_){0u}
    , decltype(_impl_.amplitude_){0}
    , decltype(_impl_.color_){0u}
    , decltype(_impl_.speed_){0u}
    , decltype(_impl_.flags_){0u}
  };
}

CMsgTEBaseBeam::~CMsgTEBaseBeam() {
  // @@protoc_insertion_point(destructor:CMsgTEBaseBeam)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgTEBaseBeam::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgTEBaseBeam::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgTEBaseBeam::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgTEBaseBeam)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    ::memset(&_impl_.modelindex_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.fadelength_) -
        reinterpret_cast<char*>(&_impl_.modelindex_)) + sizeof(_impl_.fadelength_));
  }
  if (cached_has_bits & 0x00000f00u) {
    ::memset(&_impl_.amplitude_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.flags_) -
        reinterpret_cast<char*>(&_impl_.amplitude_)) + sizeof(_impl_.flags_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgTEBaseBeam::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional fixed64 modelindex = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 9)) {
          _Internal::set_has_modelindex(&has_bits);
          _impl_.modelindex_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // optional fixed64 haloindex = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 17)) {
          _Internal::set_has_haloindex(&has_bits);
          _impl_.haloindex_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 startframe = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_startframe(&has_bits);
          _impl_.startframe_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 framerate = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_framerate(&has_bits);
          _impl_.framerate_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float life = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 45)) {
          _Internal::set_has_life(&has_bits);
          _impl_.life_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float width = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 53)) {
          _Internal::set_has_width(&has_bits);
          _impl_.width_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float endwidth = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 61)) {
          _Internal::set_has_endwidth(&has_bits);
          _impl_.endwidth_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 fadelength = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_fadelength(&has_bits);
          _impl_.fadelength_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float amplitude = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 77)) {
          _Internal::set_has_amplitude(&has_bits);
          _impl_.amplitude_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional fixed32 color = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 85)) {
          _Internal::set_has_color(&has_bits);
          _impl_.color_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 speed = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_speed(&has_bits);
          _impl_.speed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 flags = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_flags(&has_bits);
          _impl_.flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgTEBaseBeam::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgTEBaseBeam)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional fixed64 modelindex = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(1, this->_internal_modelindex(), target);
  }

  // optional fixed64 haloindex = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(2, this->_internal_haloindex(), target);
  }

  // optional uint32 startframe = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_startframe(), target);
  }

  // optional uint32 framerate = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_framerate(), target);
  }

  // optional float life = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(5, this->_internal_life(), target);
  }

  // optional float width = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(6, this->_internal_width(), target);
  }

  // optional float endwidth = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(7, this->_internal_endwidth(), target);
  }

  // optional uint32 fadelength = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(8, this->_internal_fadelength(), target);
  }

  // optional float amplitude = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(9, this->_internal_amplitude(), target);
  }

  // optional fixed32 color = 10;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(10, this->_internal_color(), target);
  }

  // optional uint32 speed = 11;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(11, this->_internal_speed(), target);
  }

  // optional uint32 flags = 12;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(12, this->_internal_flags(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgTEBaseBeam)
  return target;
}

size_t CMsgTEBaseBeam::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgTEBaseBeam)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional fixed64 modelindex = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 8;
    }

    // optional fixed64 haloindex = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 8;
    }

    // optional uint32 startframe = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_startframe());
    }

    // optional uint32 framerate = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_framerate());
    }

    // optional float life = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 4;
    }

    // optional float width = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 4;
    }

    // optional float endwidth = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 4;
    }

    // optional uint32 fadelength = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_fadelength());
    }

  }
  if (cached_has_bits & 0x00000f00u) {
    // optional float amplitude = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 4;
    }

    // optional fixed32 color = 10;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 4;
    }

    // optional uint32 speed = 11;
    if (cached_has_bits & 0x00000400u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_speed());
    }

    // optional uint32 flags = 12;
    if (cached_has_bits & 0x00000800u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_flags());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgTEBaseBeam::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgTEBaseBeam::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgTEBaseBeam::GetClassData() const { return &_class_data_; }


void CMsgTEBaseBeam::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgTEBaseBeam*>(&to_msg);
  auto& from = static_cast<const CMsgTEBaseBeam&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgTEBaseBeam)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.modelindex_ = from._impl_.modelindex_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.haloindex_ = from._impl_.haloindex_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.startframe_ = from._impl_.startframe_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.framerate_ = from._impl_.framerate_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.life_ = from._impl_.life_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.width_ = from._impl_.width_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.endwidth_ = from._impl_.endwidth_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.fadelength_ = from._impl_.fadelength_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000f00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.amplitude_ = from._impl_.amplitude_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.color_ = from._impl_.color_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.speed_ = from._impl_.speed_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.flags_ = from._impl_.flags_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgTEBaseBeam::CopyFrom(const CMsgTEBaseBeam& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgTEBaseBeam)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgTEBaseBeam::IsInitialized() const {
  return true;
}

void CMsgTEBaseBeam::InternalSwap(CMsgTEBaseBeam* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgTEBaseBeam, _impl_.flags_)
      + sizeof(CMsgTEBaseBeam::_impl_.flags_)
      - PROTOBUF_FIELD_OFFSET(CMsgTEBaseBeam, _impl_.modelindex_)>(
          reinterpret_cast<char*>(&_impl_.modelindex_),
          reinterpret_cast<char*>(&other->_impl_.modelindex_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgTEBaseBeam::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_te_2eproto_getter, &descriptor_table_te_2eproto_once,
      file_level_metadata_te_2eproto[1]);
}

// ===================================================================

class CMsgTEBeamEntPoint::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgTEBeamEntPoint>()._impl_._has_bits_);
  static const ::CMsgTEBaseBeam& base(const CMsgTEBeamEntPoint* msg);
  static void set_has_base(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_startentity(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_endentity(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::CMsgVector& start(const CMsgTEBeamEntPoint* msg);
  static void set_has_start(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::CMsgVector& end(const CMsgTEBeamEntPoint* msg);
  static void set_has_end(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::CMsgTEBaseBeam&
CMsgTEBeamEntPoint::_Internal::base(const CMsgTEBeamEntPoint* msg) {
  return *msg->_impl_.base_;
}
const ::CMsgVector&
CMsgTEBeamEntPoint::_Internal::start(const CMsgTEBeamEntPoint* msg) {
  return *msg->_impl_.start_;
}
const ::CMsgVector&
CMsgTEBeamEntPoint::_Internal::end(const CMsgTEBeamEntPoint* msg) {
  return *msg->_impl_.end_;
}
void CMsgTEBeamEntPoint::clear_start() {
  if (_impl_.start_ != nullptr) _impl_.start_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void CMsgTEBeamEntPoint::clear_end() {
  if (_impl_.end_ != nullptr) _impl_.end_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
CMsgTEBeamEntPoint::CMsgTEBeamEntPoint(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgTEBeamEntPoint)
}
CMsgTEBeamEntPoint::CMsgTEBeamEntPoint(const CMsgTEBeamEntPoint& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgTEBeamEntPoint* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.base_){nullptr}
    , decltype(_impl_.start_){nullptr}
    , decltype(_impl_.end_){nullptr}
    , decltype(_impl_.startentity_){}
    , decltype(_impl_.endentity_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_base()) {
    _this->_impl_.base_ = new ::CMsgTEBaseBeam(*from._impl_.base_);
  }
  if (from._internal_has_start()) {
    _this->_impl_.start_ = new ::CMsgVector(*from._impl_.start_);
  }
  if (from._internal_has_end()) {
    _this->_impl_.end_ = new ::CMsgVector(*from._impl_.end_);
  }
  ::memcpy(&_impl_.startentity_, &from._impl_.startentity_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.endentity_) -
    reinterpret_cast<char*>(&_impl_.startentity_)) + sizeof(_impl_.endentity_));
  // @@protoc_insertion_point(copy_constructor:CMsgTEBeamEntPoint)
}

inline void CMsgTEBeamEntPoint::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.base_){nullptr}
    , decltype(_impl_.start_){nullptr}
    , decltype(_impl_.end_){nullptr}
    , decltype(_impl_.startentity_){0u}
    , decltype(_impl_.endentity_){0u}
  };
}

CMsgTEBeamEntPoint::~CMsgTEBeamEntPoint() {
  // @@protoc_insertion_point(destructor:CMsgTEBeamEntPoint)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgTEBeamEntPoint::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.base_;
  if (this != internal_default_instance()) delete _impl_.start_;
  if (this != internal_default_instance()) delete _impl_.end_;
}

void CMsgTEBeamEntPoint::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgTEBeamEntPoint::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgTEBeamEntPoint)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.base_ != nullptr);
      _impl_.base_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.start_ != nullptr);
      _impl_.start_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.end_ != nullptr);
      _impl_.end_->Clear();
    }
  }
  if (cached_has_bits & 0x00000018u) {
    ::memset(&_impl_.startentity_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.endentity_) -
        reinterpret_cast<char*>(&_impl_.startentity_)) + sizeof(_impl_.endentity_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgTEBeamEntPoint::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .CMsgTEBaseBeam base = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_base(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 startentity = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_startentity(&has_bits);
          _impl_.startentity_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 endentity = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_endentity(&has_bits);
          _impl_.endentity_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgVector start = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_start(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgVector end = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_end(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgTEBeamEntPoint::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgTEBeamEntPoint)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .CMsgTEBaseBeam base = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::base(this),
        _Internal::base(this).GetCachedSize(), target, stream);
  }

  // optional uint32 startentity = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_startentity(), target);
  }

  // optional uint32 endentity = 3;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_endentity(), target);
  }

  // optional .CMsgVector start = 4;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::start(this),
        _Internal::start(this).GetCachedSize(), target, stream);
  }

  // optional .CMsgVector end = 5;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::end(this),
        _Internal::end(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgTEBeamEntPoint)
  return target;
}

size_t CMsgTEBeamEntPoint::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgTEBeamEntPoint)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional .CMsgTEBaseBeam base = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.base_);
    }

    // optional .CMsgVector start = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.start_);
    }

    // optional .CMsgVector end = 5;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.end_);
    }

    // optional uint32 startentity = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_startentity());
    }

    // optional uint32 endentity = 3;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_endentity());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgTEBeamEntPoint::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgTEBeamEntPoint::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgTEBeamEntPoint::GetClassData() const { return &_class_data_; }


void CMsgTEBeamEntPoint::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgTEBeamEntPoint*>(&to_msg);
  auto& from = static_cast<const CMsgTEBeamEntPoint&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgTEBeamEntPoint)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_base()->::CMsgTEBaseBeam::MergeFrom(
          from._internal_base());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_start()->::CMsgVector::MergeFrom(
          from._internal_start());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_end()->::CMsgVector::MergeFrom(
          from._internal_end());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.startentity_ = from._impl_.startentity_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.endentity_ = from._impl_.endentity_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgTEBeamEntPoint::CopyFrom(const CMsgTEBeamEntPoint& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgTEBeamEntPoint)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgTEBeamEntPoint::IsInitialized() const {
  return true;
}

void CMsgTEBeamEntPoint::InternalSwap(CMsgTEBeamEntPoint* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgTEBeamEntPoint, _impl_.endentity_)
      + sizeof(CMsgTEBeamEntPoint::_impl_.endentity_)
      - PROTOBUF_FIELD_OFFSET(CMsgTEBeamEntPoint, _impl_.base_)>(
          reinterpret_cast<char*>(&_impl_.base_),
          reinterpret_cast<char*>(&other->_impl_.base_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgTEBeamEntPoint::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_te_2eproto_getter, &descriptor_table_te_2eproto_once,
      file_level_metadata_te_2eproto[2]);
}

// ===================================================================

class CMsgTEBeamEnts::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgTEBeamEnts>()._impl_._has_bits_);
  static const ::CMsgTEBaseBeam& base(const CMsgTEBeamEnts* msg);
  static void set_has_base(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_startentity(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_endentity(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::CMsgTEBaseBeam&
CMsgTEBeamEnts::_Internal::base(const CMsgTEBeamEnts* msg) {
  return *msg->_impl_.base_;
}
CMsgTEBeamEnts::CMsgTEBeamEnts(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgTEBeamEnts)
}
CMsgTEBeamEnts::CMsgTEBeamEnts(const CMsgTEBeamEnts& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgTEBeamEnts* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.base_){nullptr}
    , decltype(_impl_.startentity_){}
    , decltype(_impl_.endentity_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_base()) {
    _this->_impl_.base_ = new ::CMsgTEBaseBeam(*from._impl_.base_);
  }
  ::memcpy(&_impl_.startentity_, &from._impl_.startentity_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.endentity_) -
    reinterpret_cast<char*>(&_impl_.startentity_)) + sizeof(_impl_.endentity_));
  // @@protoc_insertion_point(copy_constructor:CMsgTEBeamEnts)
}

inline void CMsgTEBeamEnts::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.base_){nullptr}
    , decltype(_impl_.startentity_){0u}
    , decltype(_impl_.endentity_){0u}
  };
}

CMsgTEBeamEnts::~CMsgTEBeamEnts() {
  // @@protoc_insertion_point(destructor:CMsgTEBeamEnts)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgTEBeamEnts::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.base_;
}

void CMsgTEBeamEnts::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgTEBeamEnts::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgTEBeamEnts)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.base_ != nullptr);
    _impl_.base_->Clear();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.startentity_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.endentity_) -
        reinterpret_cast<char*>(&_impl_.startentity_)) + sizeof(_impl_.endentity_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgTEBeamEnts::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .CMsgTEBaseBeam base = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_base(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 startentity = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_startentity(&has_bits);
          _impl_.startentity_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 endentity = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_endentity(&has_bits);
          _impl_.endentity_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgTEBeamEnts::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgTEBeamEnts)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .CMsgTEBaseBeam base = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::base(this),
        _Internal::base(this).GetCachedSize(), target, stream);
  }

  // optional uint32 startentity = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_startentity(), target);
  }

  // optional uint32 endentity = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_endentity(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgTEBeamEnts)
  return target;
}

size_t CMsgTEBeamEnts::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgTEBeamEnts)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .CMsgTEBaseBeam base = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.base_);
    }

    // optional uint32 startentity = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_startentity());
    }

    // optional uint32 endentity = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_endentity());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgTEBeamEnts::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgTEBeamEnts::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgTEBeamEnts::GetClassData() const { return &_class_data_; }


void CMsgTEBeamEnts::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgTEBeamEnts*>(&to_msg);
  auto& from = static_cast<const CMsgTEBeamEnts&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgTEBeamEnts)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_base()->::CMsgTEBaseBeam::MergeFrom(
          from._internal_base());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.startentity_ = from._impl_.startentity_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.endentity_ = from._impl_.endentity_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgTEBeamEnts::CopyFrom(const CMsgTEBeamEnts& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgTEBeamEnts)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgTEBeamEnts::IsInitialized() const {
  return true;
}

void CMsgTEBeamEnts::InternalSwap(CMsgTEBeamEnts* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgTEBeamEnts, _impl_.endentity_)
      + sizeof(CMsgTEBeamEnts::_impl_.endentity_)
      - PROTOBUF_FIELD_OFFSET(CMsgTEBeamEnts, _impl_.base_)>(
          reinterpret_cast<char*>(&_impl_.base_),
          reinterpret_cast<char*>(&other->_impl_.base_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgTEBeamEnts::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_te_2eproto_getter, &descriptor_table_te_2eproto_once,
      file_level_metadata_te_2eproto[3]);
}

// ===================================================================

class CMsgTEBeamPoints::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgTEBeamPoints>()._impl_._has_bits_);
  static const ::CMsgTEBaseBeam& base(const CMsgTEBeamPoints* msg);
  static void set_has_base(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::CMsgVector& start(const CMsgTEBeamPoints* msg);
  static void set_has_start(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::CMsgVector& end(const CMsgTEBeamPoints* msg);
  static void set_has_end(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::CMsgTEBaseBeam&
CMsgTEBeamPoints::_Internal::base(const CMsgTEBeamPoints* msg) {
  return *msg->_impl_.base_;
}
const ::CMsgVector&
CMsgTEBeamPoints::_Internal::start(const CMsgTEBeamPoints* msg) {
  return *msg->_impl_.start_;
}
const ::CMsgVector&
CMsgTEBeamPoints::_Internal::end(const CMsgTEBeamPoints* msg) {
  return *msg->_impl_.end_;
}
void CMsgTEBeamPoints::clear_start() {
  if (_impl_.start_ != nullptr) _impl_.start_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void CMsgTEBeamPoints::clear_end() {
  if (_impl_.end_ != nullptr) _impl_.end_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
CMsgTEBeamPoints::CMsgTEBeamPoints(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgTEBeamPoints)
}
CMsgTEBeamPoints::CMsgTEBeamPoints(const CMsgTEBeamPoints& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgTEBeamPoints* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.base_){nullptr}
    , decltype(_impl_.start_){nullptr}
    , decltype(_impl_.end_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_base()) {
    _this->_impl_.base_ = new ::CMsgTEBaseBeam(*from._impl_.base_);
  }
  if (from._internal_has_start()) {
    _this->_impl_.start_ = new ::CMsgVector(*from._impl_.start_);
  }
  if (from._internal_has_end()) {
    _this->_impl_.end_ = new ::CMsgVector(*from._impl_.end_);
  }
  // @@protoc_insertion_point(copy_constructor:CMsgTEBeamPoints)
}

inline void CMsgTEBeamPoints::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.base_){nullptr}
    , decltype(_impl_.start_){nullptr}
    , decltype(_impl_.end_){nullptr}
  };
}

CMsgTEBeamPoints::~CMsgTEBeamPoints() {
  // @@protoc_insertion_point(destructor:CMsgTEBeamPoints)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgTEBeamPoints::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.base_;
  if (this != internal_default_instance()) delete _impl_.start_;
  if (this != internal_default_instance()) delete _impl_.end_;
}

void CMsgTEBeamPoints::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgTEBeamPoints::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgTEBeamPoints)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.base_ != nullptr);
      _impl_.base_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.start_ != nullptr);
      _impl_.start_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.end_ != nullptr);
      _impl_.end_->Clear();
    }
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgTEBeamPoints::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .CMsgTEBaseBeam base = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_base(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgVector start = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_start(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgVector end = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_end(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgTEBeamPoints::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgTEBeamPoints)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .CMsgTEBaseBeam base = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::base(this),
        _Internal::base(this).GetCachedSize(), target, stream);
  }

  // optional .CMsgVector start = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::start(this),
        _Internal::start(this).GetCachedSize(), target, stream);
  }

  // optional .CMsgVector end = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::end(this),
        _Internal::end(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgTEBeamPoints)
  return target;
}

size_t CMsgTEBeamPoints::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgTEBeamPoints)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .CMsgTEBaseBeam base = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.base_);
    }

    // optional .CMsgVector start = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.start_);
    }

    // optional .CMsgVector end = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.end_);
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgTEBeamPoints::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgTEBeamPoints::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgTEBeamPoints::GetClassData() const { return &_class_data_; }


void CMsgTEBeamPoints::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgTEBeamPoints*>(&to_msg);
  auto& from = static_cast<const CMsgTEBeamPoints&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgTEBeamPoints)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_base()->::CMsgTEBaseBeam::MergeFrom(
          from._internal_base());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_start()->::CMsgVector::MergeFrom(
          from._internal_start());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_end()->::CMsgVector::MergeFrom(
          from._internal_end());
    }
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgTEBeamPoints::CopyFrom(const CMsgTEBeamPoints& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgTEBeamPoints)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgTEBeamPoints::IsInitialized() const {
  return true;
}

void CMsgTEBeamPoints::InternalSwap(CMsgTEBeamPoints* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgTEBeamPoints, _impl_.end_)
      + sizeof(CMsgTEBeamPoints::_impl_.end_)
      - PROTOBUF_FIELD_OFFSET(CMsgTEBeamPoints, _impl_.base_)>(
          reinterpret_cast<char*>(&_impl_.base_),
          reinterpret_cast<char*>(&other->_impl_.base_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgTEBeamPoints::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_te_2eproto_getter, &descriptor_table_te_2eproto_once,
      file_level_metadata_te_2eproto[4]);
}

// ===================================================================

class CMsgTEBeamRing::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgTEBeamRing>()._impl_._has_bits_);
  static const ::CMsgTEBaseBeam& base(const CMsgTEBeamRing* msg);
  static void set_has_base(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_startentity(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_endentity(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::CMsgTEBaseBeam&
CMsgTEBeamRing::_Internal::base(const CMsgTEBeamRing* msg) {
  return *msg->_impl_.base_;
}
CMsgTEBeamRing::CMsgTEBeamRing(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgTEBeamRing)
}
CMsgTEBeamRing::CMsgTEBeamRing(const CMsgTEBeamRing& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgTEBeamRing* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.base_){nullptr}
    , decltype(_impl_.startentity_){}
    , decltype(_impl_.endentity_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_base()) {
    _this->_impl_.base_ = new ::CMsgTEBaseBeam(*from._impl_.base_);
  }
  ::memcpy(&_impl_.startentity_, &from._impl_.startentity_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.endentity_) -
    reinterpret_cast<char*>(&_impl_.startentity_)) + sizeof(_impl_.endentity_));
  // @@protoc_insertion_point(copy_constructor:CMsgTEBeamRing)
}

inline void CMsgTEBeamRing::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.base_){nullptr}
    , decltype(_impl_.startentity_){0u}
    , decltype(_impl_.endentity_){0u}
  };
}

CMsgTEBeamRing::~CMsgTEBeamRing() {
  // @@protoc_insertion_point(destructor:CMsgTEBeamRing)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgTEBeamRing::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.base_;
}

void CMsgTEBeamRing::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgTEBeamRing::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgTEBeamRing)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.base_ != nullptr);
    _impl_.base_->Clear();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&_impl_.startentity_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.endentity_) -
        reinterpret_cast<char*>(&_impl_.startentity_)) + sizeof(_impl_.endentity_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgTEBeamRing::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .CMsgTEBaseBeam base = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_base(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 startentity = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_startentity(&has_bits);
          _impl_.startentity_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 endentity = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_endentity(&has_bits);
          _impl_.endentity_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgTEBeamRing::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgTEBeamRing)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .CMsgTEBaseBeam base = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::base(this),
        _Internal::base(this).GetCachedSize(), target, stream);
  }

  // optional uint32 startentity = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_startentity(), target);
  }

  // optional uint32 endentity = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_endentity(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgTEBeamRing)
  return target;
}

size_t CMsgTEBeamRing::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgTEBeamRing)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .CMsgTEBaseBeam base = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.base_);
    }

    // optional uint32 startentity = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_startentity());
    }

    // optional uint32 endentity = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_endentity());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgTEBeamRing::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgTEBeamRing::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgTEBeamRing::GetClassData() const { return &_class_data_; }


void CMsgTEBeamRing::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgTEBeamRing*>(&to_msg);
  auto& from = static_cast<const CMsgTEBeamRing&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgTEBeamRing)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_base()->::CMsgTEBaseBeam::MergeFrom(
          from._internal_base());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.startentity_ = from._impl_.startentity_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.endentity_ = from._impl_.endentity_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgTEBeamRing::CopyFrom(const CMsgTEBeamRing& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgTEBeamRing)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgTEBeamRing::IsInitialized() const {
  return true;
}

void CMsgTEBeamRing::InternalSwap(CMsgTEBeamRing* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgTEBeamRing, _impl_.endentity_)
      + sizeof(CMsgTEBeamRing::_impl_.endentity_)
      - PROTOBUF_FIELD_OFFSET(CMsgTEBeamRing, _impl_.base_)>(
          reinterpret_cast<char*>(&_impl_.base_),
          reinterpret_cast<char*>(&other->_impl_.base_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgTEBeamRing::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_te_2eproto_getter, &descriptor_table_te_2eproto_once,
      file_level_metadata_te_2eproto[5]);
}

// ===================================================================

class CMsgTEBSPDecal::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgTEBSPDecal>()._impl_._has_bits_);
  static const ::CMsgVector& origin(const CMsgTEBSPDecal* msg);
  static void set_has_origin(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::CMsgVector& normal(const CMsgTEBSPDecal* msg);
  static void set_has_normal(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::CMsgVector& saxis(const CMsgTEBSPDecal* msg);
  static void set_has_saxis(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_entity(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_index(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::CMsgVector&
CMsgTEBSPDecal::_Internal::origin(const CMsgTEBSPDecal* msg) {
  return *msg->_impl_.origin_;
}
const ::CMsgVector&
CMsgTEBSPDecal::_Internal::normal(const CMsgTEBSPDecal* msg) {
  return *msg->_impl_.normal_;
}
const ::CMsgVector&
CMsgTEBSPDecal::_Internal::saxis(const CMsgTEBSPDecal* msg) {
  return *msg->_impl_.saxis_;
}
void CMsgTEBSPDecal::clear_origin() {
  if (_impl_.origin_ != nullptr) _impl_.origin_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void CMsgTEBSPDecal::clear_normal() {
  if (_impl_.normal_ != nullptr) _impl_.normal_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void CMsgTEBSPDecal::clear_saxis() {
  if (_impl_.saxis_ != nullptr) _impl_.saxis_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
CMsgTEBSPDecal::CMsgTEBSPDecal(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgTEBSPDecal)
}
CMsgTEBSPDecal::CMsgTEBSPDecal(const CMsgTEBSPDecal& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgTEBSPDecal* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.origin_){nullptr}
    , decltype(_impl_.normal_){nullptr}
    , decltype(_impl_.saxis_){nullptr}
    , decltype(_impl_.index_){}
    , decltype(_impl_.entity_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_origin()) {
    _this->_impl_.origin_ = new ::CMsgVector(*from._impl_.origin_);
  }
  if (from._internal_has_normal()) {
    _this->_impl_.normal_ = new ::CMsgVector(*from._impl_.normal_);
  }
  if (from._internal_has_saxis()) {
    _this->_impl_.saxis_ = new ::CMsgVector(*from._impl_.saxis_);
  }
  ::memcpy(&_impl_.index_, &from._impl_.index_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.entity_) -
    reinterpret_cast<char*>(&_impl_.index_)) + sizeof(_impl_.entity_));
  // @@protoc_insertion_point(copy_constructor:CMsgTEBSPDecal)
}

inline void CMsgTEBSPDecal::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.origin_){nullptr}
    , decltype(_impl_.normal_){nullptr}
    , decltype(_impl_.saxis_){nullptr}
    , decltype(_impl_.index_){0u}
    , decltype(_impl_.entity_){-1}
  };
}

CMsgTEBSPDecal::~CMsgTEBSPDecal() {
  // @@protoc_insertion_point(destructor:CMsgTEBSPDecal)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgTEBSPDecal::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.origin_;
  if (this != internal_default_instance()) delete _impl_.normal_;
  if (this != internal_default_instance()) delete _impl_.saxis_;
}

void CMsgTEBSPDecal::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgTEBSPDecal::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgTEBSPDecal)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.origin_ != nullptr);
      _impl_.origin_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.normal_ != nullptr);
      _impl_.normal_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.saxis_ != nullptr);
      _impl_.saxis_->Clear();
    }
  }
  if (cached_has_bits & 0x00000018u) {
    _impl_.index_ = 0u;
    _impl_.entity_ = -1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgTEBSPDecal::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .CMsgVector origin = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_origin(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgVector normal = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_normal(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgVector saxis = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_saxis(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 entity = 4 [default = -1];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_entity(&has_bits);
          _impl_.entity_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 index = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_index(&has_bits);
          _impl_.index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgTEBSPDecal::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgTEBSPDecal)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .CMsgVector origin = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::origin(this),
        _Internal::origin(this).GetCachedSize(), target, stream);
  }

  // optional .CMsgVector normal = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::normal(this),
        _Internal::normal(this).GetCachedSize(), target, stream);
  }

  // optional .CMsgVector saxis = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::saxis(this),
        _Internal::saxis(this).GetCachedSize(), target, stream);
  }

  // optional int32 entity = 4 [default = -1];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_entity(), target);
  }

  // optional uint32 index = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_index(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgTEBSPDecal)
  return target;
}

size_t CMsgTEBSPDecal::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgTEBSPDecal)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional .CMsgVector origin = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.origin_);
    }

    // optional .CMsgVector normal = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.normal_);
    }

    // optional .CMsgVector saxis = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.saxis_);
    }

    // optional uint32 index = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_index());
    }

    // optional int32 entity = 4 [default = -1];
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_entity());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgTEBSPDecal::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgTEBSPDecal::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgTEBSPDecal::GetClassData() const { return &_class_data_; }


void CMsgTEBSPDecal::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgTEBSPDecal*>(&to_msg);
  auto& from = static_cast<const CMsgTEBSPDecal&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgTEBSPDecal)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_origin()->::CMsgVector::MergeFrom(
          from._internal_origin());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_normal()->::CMsgVector::MergeFrom(
          from._internal_normal());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_saxis()->::CMsgVector::MergeFrom(
          from._internal_saxis());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.index_ = from._impl_.index_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.entity_ = from._impl_.entity_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgTEBSPDecal::CopyFrom(const CMsgTEBSPDecal& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgTEBSPDecal)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgTEBSPDecal::IsInitialized() const {
  return true;
}

void CMsgTEBSPDecal::InternalSwap(CMsgTEBSPDecal* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgTEBSPDecal, _impl_.index_)
      + sizeof(CMsgTEBSPDecal::_impl_.index_)
      - PROTOBUF_FIELD_OFFSET(CMsgTEBSPDecal, _impl_.origin_)>(
          reinterpret_cast<char*>(&_impl_.origin_),
          reinterpret_cast<char*>(&other->_impl_.origin_));
  swap(_impl_.entity_, other->_impl_.entity_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgTEBSPDecal::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_te_2eproto_getter, &descriptor_table_te_2eproto_once,
      file_level_metadata_te_2eproto[6]);
}

// ===================================================================

class CMsgTEBubbles::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgTEBubbles>()._impl_._has_bits_);
  static const ::CMsgVector& mins(const CMsgTEBubbles* msg);
  static void set_has_mins(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::CMsgVector& maxs(const CMsgTEBubbles* msg);
  static void set_has_maxs(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_height(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_count(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_speed(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

const ::CMsgVector&
CMsgTEBubbles::_Internal::mins(const CMsgTEBubbles* msg) {
  return *msg->_impl_.mins_;
}
const ::CMsgVector&
CMsgTEBubbles::_Internal::maxs(const CMsgTEBubbles* msg) {
  return *msg->_impl_.maxs_;
}
void CMsgTEBubbles::clear_mins() {
  if (_impl_.mins_ != nullptr) _impl_.mins_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void CMsgTEBubbles::clear_maxs() {
  if (_impl_.maxs_ != nullptr) _impl_.maxs_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
CMsgTEBubbles::CMsgTEBubbles(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgTEBubbles)
}
CMsgTEBubbles::CMsgTEBubbles(const CMsgTEBubbles& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgTEBubbles* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.mins_){nullptr}
    , decltype(_impl_.maxs_){nullptr}
    , decltype(_impl_.height_){}
    , decltype(_impl_.count_){}
    , decltype(_impl_.speed_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_mins()) {
    _this->_impl_.mins_ = new ::CMsgVector(*from._impl_.mins_);
  }
  if (from._internal_has_maxs()) {
    _this->_impl_.maxs_ = new ::CMsgVector(*from._impl_.maxs_);
  }
  ::memcpy(&_impl_.height_, &from._impl_.height_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.speed_) -
    reinterpret_cast<char*>(&_impl_.height_)) + sizeof(_impl_.speed_));
  // @@protoc_insertion_point(copy_constructor:CMsgTEBubbles)
}

inline void CMsgTEBubbles::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.mins_){nullptr}
    , decltype(_impl_.maxs_){nullptr}
    , decltype(_impl_.height_){0}
    , decltype(_impl_.count_){0u}
    , decltype(_impl_.speed_){0}
  };
}

CMsgTEBubbles::~CMsgTEBubbles() {
  // @@protoc_insertion_point(destructor:CMsgTEBubbles)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgTEBubbles::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.mins_;
  if (this != internal_default_instance()) delete _impl_.maxs_;
}

void CMsgTEBubbles::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgTEBubbles::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgTEBubbles)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.mins_ != nullptr);
      _impl_.mins_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.maxs_ != nullptr);
      _impl_.maxs_->Clear();
    }
  }
  if (cached_has_bits & 0x0000001cu) {
    ::memset(&_impl_.height_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.speed_) -
        reinterpret_cast<char*>(&_impl_.height_)) + sizeof(_impl_.speed_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgTEBubbles::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .CMsgVector mins = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_mins(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgVector maxs = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_maxs(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float height = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _Internal::set_has_height(&has_bits);
          _impl_.height_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 count = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_count(&has_bits);
          _impl_.count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float speed = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 45)) {
          _Internal::set_has_speed(&has_bits);
          _impl_.speed_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgTEBubbles::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgTEBubbles)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .CMsgVector mins = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::mins(this),
        _Internal::mins(this).GetCachedSize(), target, stream);
  }

  // optional .CMsgVector maxs = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::maxs(this),
        _Internal::maxs(this).GetCachedSize(), target, stream);
  }

  // optional float height = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_height(), target);
  }

  // optional uint32 count = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_count(), target);
  }

  // optional float speed = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(5, this->_internal_speed(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgTEBubbles)
  return target;
}

size_t CMsgTEBubbles::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgTEBubbles)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional .CMsgVector mins = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.mins_);
    }

    // optional .CMsgVector maxs = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.maxs_);
    }

    // optional float height = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

    // optional uint32 count = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_count());
    }

    // optional float speed = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 4;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgTEBubbles::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgTEBubbles::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgTEBubbles::GetClassData() const { return &_class_data_; }


void CMsgTEBubbles::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgTEBubbles*>(&to_msg);
  auto& from = static_cast<const CMsgTEBubbles&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgTEBubbles)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_mins()->::CMsgVector::MergeFrom(
          from._internal_mins());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_maxs()->::CMsgVector::MergeFrom(
          from._internal_maxs());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.height_ = from._impl_.height_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.count_ = from._impl_.count_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.speed_ = from._impl_.speed_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgTEBubbles::CopyFrom(const CMsgTEBubbles& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgTEBubbles)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgTEBubbles::IsInitialized() const {
  return true;
}

void CMsgTEBubbles::InternalSwap(CMsgTEBubbles* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgTEBubbles, _impl_.speed_)
      + sizeof(CMsgTEBubbles::_impl_.speed_)
      - PROTOBUF_FIELD_OFFSET(CMsgTEBubbles, _impl_.mins_)>(
          reinterpret_cast<char*>(&_impl_.mins_),
          reinterpret_cast<char*>(&other->_impl_.mins_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgTEBubbles::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_te_2eproto_getter, &descriptor_table_te_2eproto_once,
      file_level_metadata_te_2eproto[7]);
}

// ===================================================================

class CMsgTEBubbleTrail::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgTEBubbleTrail>()._impl_._has_bits_);
  static const ::CMsgVector& mins(const CMsgTEBubbleTrail* msg);
  static void set_has_mins(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::CMsgVector& maxs(const CMsgTEBubbleTrail* msg);
  static void set_has_maxs(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_waterz(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_count(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_speed(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

const ::CMsgVector&
CMsgTEBubbleTrail::_Internal::mins(const CMsgTEBubbleTrail* msg) {
  return *msg->_impl_.mins_;
}
const ::CMsgVector&
CMsgTEBubbleTrail::_Internal::maxs(const CMsgTEBubbleTrail* msg) {
  return *msg->_impl_.maxs_;
}
void CMsgTEBubbleTrail::clear_mins() {
  if (_impl_.mins_ != nullptr) _impl_.mins_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void CMsgTEBubbleTrail::clear_maxs() {
  if (_impl_.maxs_ != nullptr) _impl_.maxs_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
CMsgTEBubbleTrail::CMsgTEBubbleTrail(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgTEBubbleTrail)
}
CMsgTEBubbleTrail::CMsgTEBubbleTrail(const CMsgTEBubbleTrail& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgTEBubbleTrail* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.mins_){nullptr}
    , decltype(_impl_.maxs_){nullptr}
    , decltype(_impl_.waterz_){}
    , decltype(_impl_.count_){}
    , decltype(_impl_.speed_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_mins()) {
    _this->_impl_.mins_ = new ::CMsgVector(*from._impl_.mins_);
  }
  if (from._internal_has_maxs()) {
    _this->_impl_.maxs_ = new ::CMsgVector(*from._impl_.maxs_);
  }
  ::memcpy(&_impl_.waterz_, &from._impl_.waterz_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.speed_) -
    reinterpret_cast<char*>(&_impl_.waterz_)) + sizeof(_impl_.speed_));
  // @@protoc_insertion_point(copy_constructor:CMsgTEBubbleTrail)
}

inline void CMsgTEBubbleTrail::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.mins_){nullptr}
    , decltype(_impl_.maxs_){nullptr}
    , decltype(_impl_.waterz_){0}
    , decltype(_impl_.count_){0u}
    , decltype(_impl_.speed_){0}
  };
}

CMsgTEBubbleTrail::~CMsgTEBubbleTrail() {
  // @@protoc_insertion_point(destructor:CMsgTEBubbleTrail)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgTEBubbleTrail::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.mins_;
  if (this != internal_default_instance()) delete _impl_.maxs_;
}

void CMsgTEBubbleTrail::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgTEBubbleTrail::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgTEBubbleTrail)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.mins_ != nullptr);
      _impl_.mins_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.maxs_ != nullptr);
      _impl_.maxs_->Clear();
    }
  }
  if (cached_has_bits & 0x0000001cu) {
    ::memset(&_impl_.waterz_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.speed_) -
        reinterpret_cast<char*>(&_impl_.waterz_)) + sizeof(_impl_.speed_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgTEBubbleTrail::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .CMsgVector mins = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_mins(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgVector maxs = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_maxs(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float waterz = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _Internal::set_has_waterz(&has_bits);
          _impl_.waterz_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 count = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_count(&has_bits);
          _impl_.count_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float speed = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 45)) {
          _Internal::set_has_speed(&has_bits);
          _impl_.speed_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgTEBubbleTrail::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgTEBubbleTrail)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .CMsgVector mins = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::mins(this),
        _Internal::mins(this).GetCachedSize(), target, stream);
  }

  // optional .CMsgVector maxs = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::maxs(this),
        _Internal::maxs(this).GetCachedSize(), target, stream);
  }

  // optional float waterz = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_waterz(), target);
  }

  // optional uint32 count = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_count(), target);
  }

  // optional float speed = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(5, this->_internal_speed(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgTEBubbleTrail)
  return target;
}

size_t CMsgTEBubbleTrail::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgTEBubbleTrail)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional .CMsgVector mins = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.mins_);
    }

    // optional .CMsgVector maxs = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.maxs_);
    }

    // optional float waterz = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

    // optional uint32 count = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_count());
    }

    // optional float speed = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 4;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgTEBubbleTrail::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgTEBubbleTrail::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgTEBubbleTrail::GetClassData() const { return &_class_data_; }


void CMsgTEBubbleTrail::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgTEBubbleTrail*>(&to_msg);
  auto& from = static_cast<const CMsgTEBubbleTrail&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgTEBubbleTrail)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_mins()->::CMsgVector::MergeFrom(
          from._internal_mins());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_maxs()->::CMsgVector::MergeFrom(
          from._internal_maxs());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.waterz_ = from._impl_.waterz_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.count_ = from._impl_.count_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.speed_ = from._impl_.speed_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgTEBubbleTrail::CopyFrom(const CMsgTEBubbleTrail& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgTEBubbleTrail)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgTEBubbleTrail::IsInitialized() const {
  return true;
}

void CMsgTEBubbleTrail::InternalSwap(CMsgTEBubbleTrail* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgTEBubbleTrail, _impl_.speed_)
      + sizeof(CMsgTEBubbleTrail::_impl_.speed_)
      - PROTOBUF_FIELD_OFFSET(CMsgTEBubbleTrail, _impl_.mins_)>(
          reinterpret_cast<char*>(&_impl_.mins_),
          reinterpret_cast<char*>(&other->_impl_.mins_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgTEBubbleTrail::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_te_2eproto_getter, &descriptor_table_te_2eproto_once,
      file_level_metadata_te_2eproto[8]);
}

// ===================================================================

class CMsgTEDecal::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgTEDecal>()._impl_._has_bits_);
  static const ::CMsgVector& origin(const CMsgTEDecal* msg);
  static void set_has_origin(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::CMsgVector& start(const CMsgTEDecal* msg);
  static void set_has_start(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_entity(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_hitbox(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_index(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::CMsgVector&
CMsgTEDecal::_Internal::origin(const CMsgTEDecal* msg) {
  return *msg->_impl_.origin_;
}
const ::CMsgVector&
CMsgTEDecal::_Internal::start(const CMsgTEDecal* msg) {
  return *msg->_impl_.start_;
}
void CMsgTEDecal::clear_origin() {
  if (_impl_.origin_ != nullptr) _impl_.origin_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void CMsgTEDecal::clear_start() {
  if (_impl_.start_ != nullptr) _impl_.start_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
CMsgTEDecal::CMsgTEDecal(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgTEDecal)
}
CMsgTEDecal::CMsgTEDecal(const CMsgTEDecal& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgTEDecal* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.origin_){nullptr}
    , decltype(_impl_.start_){nullptr}
    , decltype(_impl_.hitbox_){}
    , decltype(_impl_.index_){}
    , decltype(_impl_.entity_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_origin()) {
    _this->_impl_.origin_ = new ::CMsgVector(*from._impl_.origin_);
  }
  if (from._internal_has_start()) {
    _this->_impl_.start_ = new ::CMsgVector(*from._impl_.start_);
  }
  ::memcpy(&_impl_.hitbox_, &from._impl_.hitbox_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.entity_) -
    reinterpret_cast<char*>(&_impl_.hitbox_)) + sizeof(_impl_.entity_));
  // @@protoc_insertion_point(copy_constructor:CMsgTEDecal)
}

inline void CMsgTEDecal::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.origin_){nullptr}
    , decltype(_impl_.start_){nullptr}
    , decltype(_impl_.hitbox_){0u}
    , decltype(_impl_.index_){0u}
    , decltype(_impl_.entity_){-1}
  };
}

CMsgTEDecal::~CMsgTEDecal() {
  // @@protoc_insertion_point(destructor:CMsgTEDecal)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgTEDecal::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.origin_;
  if (this != internal_default_instance()) delete _impl_.start_;
}

void CMsgTEDecal::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgTEDecal::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgTEDecal)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.origin_ != nullptr);
      _impl_.origin_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.start_ != nullptr);
      _impl_.start_->Clear();
    }
  }
  if (cached_has_bits & 0x0000001cu) {
    ::memset(&_impl_.hitbox_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.index_) -
        reinterpret_cast<char*>(&_impl_.hitbox_)) + sizeof(_impl_.index_));
    _impl_.entity_ = -1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgTEDecal::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .CMsgVector origin = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_origin(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgVector start = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_start(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 entity = 3 [default = -1];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_entity(&has_bits);
          _impl_.entity_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 hitbox = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_hitbox(&has_bits);
          _impl_.hitbox_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 index = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_index(&has_bits);
          _impl_.index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgTEDecal::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgTEDecal)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .CMsgVector origin = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::origin(this),
        _Internal::origin(this).GetCachedSize(), target, stream);
  }

  // optional .CMsgVector start = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::start(this),
        _Internal::start(this).GetCachedSize(), target, stream);
  }

  // optional int32 entity = 3 [default = -1];
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_entity(), target);
  }

  // optional uint32 hitbox = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_hitbox(), target);
  }

  // optional uint32 index = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_index(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgTEDecal)
  return target;
}

size_t CMsgTEDecal::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgTEDecal)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional .CMsgVector origin = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.origin_);
    }

    // optional .CMsgVector start = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.start_);
    }

    // optional uint32 hitbox = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_hitbox());
    }

    // optional uint32 index = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_index());
    }

    // optional int32 entity = 3 [default = -1];
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_entity());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgTEDecal::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgTEDecal::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgTEDecal::GetClassData() const { return &_class_data_; }


void CMsgTEDecal::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgTEDecal*>(&to_msg);
  auto& from = static_cast<const CMsgTEDecal&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgTEDecal)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_origin()->::CMsgVector::MergeFrom(
          from._internal_origin());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_start()->::CMsgVector::MergeFrom(
          from._internal_start());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.hitbox_ = from._impl_.hitbox_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.index_ = from._impl_.index_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.entity_ = from._impl_.entity_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgTEDecal::CopyFrom(const CMsgTEDecal& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgTEDecal)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgTEDecal::IsInitialized() const {
  return true;
}

void CMsgTEDecal::InternalSwap(CMsgTEDecal* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgTEDecal, _impl_.index_)
      + sizeof(CMsgTEDecal::_impl_.index_)
      - PROTOBUF_FIELD_OFFSET(CMsgTEDecal, _impl_.origin_)>(
          reinterpret_cast<char*>(&_impl_.origin_),
          reinterpret_cast<char*>(&other->_impl_.origin_));
  swap(_impl_.entity_, other->_impl_.entity_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgTEDecal::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_te_2eproto_getter, &descriptor_table_te_2eproto_once,
      file_level_metadata_te_2eproto[9]);
}

// ===================================================================

class CMsgEffectData::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgEffectData>()._impl_._has_bits_);
  static const ::CMsgVector& origin(const CMsgEffectData* msg);
  static void set_has_origin(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::CMsgVector& start(const CMsgEffectData* msg);
  static void set_has_start(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::CMsgVector& normal(const CMsgEffectData* msg);
  static void set_has_normal(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::CMsgQAngle& angles(const CMsgEffectData* msg);
  static void set_has_angles(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_entity(HasBits* has_bits) {
    (*has_bits)[0] |= 131072u;
  }
  static void set_has_otherentity(HasBits* has_bits) {
    (*has_bits)[0] |= 262144u;
  }
  static void set_has_scale(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_magnitude(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_radius(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_surfaceprop(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_effectindex(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_damagetype(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_material(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_hitbox(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_color(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static void set_has_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_attachmentindex(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static void set_has_effectname(HasBits* has_bits) {
    (*has_bits)[0] |= 32768u;
  }
  static void set_has_attachmentname(HasBits* has_bits) {
    (*has_bits)[0] |= 65536u;
  }
};

const ::CMsgVector&
CMsgEffectData::_Internal::origin(const CMsgEffectData* msg) {
  return *msg->_impl_.origin_;
}
const ::CMsgVector&
CMsgEffectData::_Internal::start(const CMsgEffectData* msg) {
  return *msg->_impl_.start_;
}
const ::CMsgVector&
CMsgEffectData::_Internal::normal(const CMsgEffectData* msg) {
  return *msg->_impl_.normal_;
}
const ::CMsgQAngle&
CMsgEffectData::_Internal::angles(const CMsgEffectData* msg) {
  return *msg->_impl_.angles_;
}
void CMsgEffectData::clear_origin() {
  if (_impl_.origin_ != nullptr) _impl_.origin_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void CMsgEffectData::clear_start() {
  if (_impl_.start_ != nullptr) _impl_.start_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void CMsgEffectData::clear_normal() {
  if (_impl_.normal_ != nullptr) _impl_.normal_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
void CMsgEffectData::clear_angles() {
  if (_impl_.angles_ != nullptr) _impl_.angles_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
CMsgEffectData::CMsgEffectData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgEffectData)
}
CMsgEffectData::CMsgEffectData(const CMsgEffectData& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgEffectData* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.origin_){nullptr}
    , decltype(_impl_.start_){nullptr}
    , decltype(_impl_.normal_){nullptr}
    , decltype(_impl_.angles_){nullptr}
    , decltype(_impl_.scale_){}
    , decltype(_impl_.magnitude_){}
    , decltype(_impl_.radius_){}
    , decltype(_impl_.surfaceprop_){}
    , decltype(_impl_.effectindex_){}
    , decltype(_impl_.damagetype_){}
    , decltype(_impl_.material_){}
    , decltype(_impl_.hitbox_){}
    , decltype(_impl_.color_){}
    , decltype(_impl_.flags_){}
    , decltype(_impl_.attachmentindex_){}
    , decltype(_impl_.effectname_){}
    , decltype(_impl_.attachmentname_){}
    , decltype(_impl_.entity_){}
    , decltype(_impl_.otherentity_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_origin()) {
    _this->_impl_.origin_ = new ::CMsgVector(*from._impl_.origin_);
  }
  if (from._internal_has_start()) {
    _this->_impl_.start_ = new ::CMsgVector(*from._impl_.start_);
  }
  if (from._internal_has_normal()) {
    _this->_impl_.normal_ = new ::CMsgVector(*from._impl_.normal_);
  }
  if (from._internal_has_angles()) {
    _this->_impl_.angles_ = new ::CMsgQAngle(*from._impl_.angles_);
  }
  ::memcpy(&_impl_.scale_, &from._impl_.scale_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.otherentity_) -
    reinterpret_cast<char*>(&_impl_.scale_)) + sizeof(_impl_.otherentity_));
  // @@protoc_insertion_point(copy_constructor:CMsgEffectData)
}

inline void CMsgEffectData::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.origin_){nullptr}
    , decltype(_impl_.start_){nullptr}
    , decltype(_impl_.normal_){nullptr}
    , decltype(_impl_.angles_){nullptr}
    , decltype(_impl_.scale_){0}
    , decltype(_impl_.magnitude_){0}
    , decltype(_impl_.radius_){0}
    , decltype(_impl_.surfaceprop_){0u}
    , decltype(_impl_.effectindex_){uint64_t{0u}}
    , decltype(_impl_.damagetype_){0u}
    , decltype(_impl_.material_){0u}
    , decltype(_impl_.hitbox_){0u}
    , decltype(_impl_.color_){0u}
    , decltype(_impl_.flags_){0u}
    , decltype(_impl_.attachmentindex_){0}
    , decltype(_impl_.effectname_){0u}
    , decltype(_impl_.attachmentname_){0u}
    , decltype(_impl_.entity_){16777215u}
    , decltype(_impl_.otherentity_){16777215u}
  };
}

CMsgEffectData::~CMsgEffectData() {
  // @@protoc_insertion_point(destructor:CMsgEffectData)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgEffectData::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.origin_;
  if (this != internal_default_instance()) delete _impl_.start_;
  if (this != internal_default_instance()) delete _impl_.normal_;
  if (this != internal_default_instance()) delete _impl_.angles_;
}

void CMsgEffectData::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgEffectData::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgEffectData)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.origin_ != nullptr);
      _impl_.origin_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.start_ != nullptr);
      _impl_.start_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.normal_ != nullptr);
      _impl_.normal_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.angles_ != nullptr);
      _impl_.angles_->Clear();
    }
  }
  if (cached_has_bits & 0x000000f0u) {
    ::memset(&_impl_.scale_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.surfaceprop_) -
        reinterpret_cast<char*>(&_impl_.scale_)) + sizeof(_impl_.surfaceprop_));
  }
  if (cached_has_bits & 0x0000ff00u) {
    ::memset(&_impl_.effectindex_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.effectname_) -
        reinterpret_cast<char*>(&_impl_.effectindex_)) + sizeof(_impl_.effectname_));
  }
  if (cached_has_bits & 0x00070000u) {
    _impl_.attachmentname_ = 0u;
    _impl_.entity_ = 16777215u;
    _impl_.otherentity_ = 16777215u;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgEffectData::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .CMsgVector origin = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_origin(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgVector start = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_start(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgVector normal = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_normal(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgQAngle angles = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_angles(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional fixed32 entity = 5 [default = 16777215];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 45)) {
          _Internal::set_has_entity(&has_bits);
          _impl_.entity_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // optional fixed32 otherentity = 6 [default = 16777215];
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 53)) {
          _Internal::set_has_otherentity(&has_bits);
          _impl_.otherentity_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // optional float scale = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 61)) {
          _Internal::set_has_scale(&has_bits);
          _impl_.scale_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float magnitude = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 69)) {
          _Internal::set_has_magnitude(&has_bits);
          _impl_.magnitude_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float radius = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 77)) {
          _Internal::set_has_radius(&has_bits);
          _impl_.radius_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional fixed32 surfaceprop = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 85)) {
          _Internal::set_has_surfaceprop(&has_bits);
          _impl_.surfaceprop_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // optional fixed64 effectindex = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 89)) {
          _Internal::set_has_effectindex(&has_bits);
          _impl_.effectindex_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 damagetype = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 96)) {
          _Internal::set_has_damagetype(&has_bits);
          _impl_.damagetype_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 material = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _Internal::set_has_material(&has_bits);
          _impl_.material_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 hitbox = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 112)) {
          _Internal::set_has_hitbox(&has_bits);
          _impl_.hitbox_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 color = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 120)) {
          _Internal::set_has_color(&has_bits);
          _impl_.color_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 flags = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 128)) {
          _Internal::set_has_flags(&has_bits);
          _impl_.flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 attachmentindex = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 136)) {
          _Internal::set_has_attachmentindex(&has_bits);
          _impl_.attachmentindex_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 effectname = 18;
      case 18:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 144)) {
          _Internal::set_has_effectname(&has_bits);
          _impl_.effectname_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 attachmentname = 19;
      case 19:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 152)) {
          _Internal::set_has_attachmentname(&has_bits);
          _impl_.attachmentname_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgEffectData::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgEffectData)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .CMsgVector origin = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::origin(this),
        _Internal::origin(this).GetCachedSize(), target, stream);
  }

  // optional .CMsgVector start = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::start(this),
        _Internal::start(this).GetCachedSize(), target, stream);
  }

  // optional .CMsgVector normal = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::normal(this),
        _Internal::normal(this).GetCachedSize(), target, stream);
  }

  // optional .CMsgQAngle angles = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::angles(this),
        _Internal::angles(this).GetCachedSize(), target, stream);
  }

  // optional fixed32 entity = 5 [default = 16777215];
  if (cached_has_bits & 0x00020000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(5, this->_internal_entity(), target);
  }

  // optional fixed32 otherentity = 6 [default = 16777215];
  if (cached_has_bits & 0x00040000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(6, this->_internal_otherentity(), target);
  }

  // optional float scale = 7;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(7, this->_internal_scale(), target);
  }

  // optional float magnitude = 8;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(8, this->_internal_magnitude(), target);
  }

  // optional float radius = 9;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(9, this->_internal_radius(), target);
  }

  // optional fixed32 surfaceprop = 10;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(10, this->_internal_surfaceprop(), target);
  }

  // optional fixed64 effectindex = 11;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(11, this->_internal_effectindex(), target);
  }

  // optional uint32 damagetype = 12;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(12, this->_internal_damagetype(), target);
  }

  // optional uint32 material = 13;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(13, this->_internal_material(), target);
  }

  // optional uint32 hitbox = 14;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(14, this->_internal_hitbox(), target);
  }

  // optional uint32 color = 15;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(15, this->_internal_color(), target);
  }

  // optional uint32 flags = 16;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(16, this->_internal_flags(), target);
  }

  // optional int32 attachmentindex = 17;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(17, this->_internal_attachmentindex(), target);
  }

  // optional uint32 effectname = 18;
  if (cached_has_bits & 0x00008000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(18, this->_internal_effectname(), target);
  }

  // optional uint32 attachmentname = 19;
  if (cached_has_bits & 0x00010000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(19, this->_internal_attachmentname(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgEffectData)
  return target;
}

size_t CMsgEffectData::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgEffectData)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional .CMsgVector origin = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.origin_);
    }

    // optional .CMsgVector start = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.start_);
    }

    // optional .CMsgVector normal = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.normal_);
    }

    // optional .CMsgQAngle angles = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.angles_);
    }

    // optional float scale = 7;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 4;
    }

    // optional float magnitude = 8;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 4;
    }

    // optional float radius = 9;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 4;
    }

    // optional fixed32 surfaceprop = 10;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 + 4;
    }

  }
  if (cached_has_bits & 0x0000ff00u) {
    // optional fixed64 effectindex = 11;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 8;
    }

    // optional uint32 damagetype = 12;
    if (cached_has_bits & 0x00000200u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_damagetype());
    }

    // optional uint32 material = 13;
    if (cached_has_bits & 0x00000400u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_material());
    }

    // optional uint32 hitbox = 14;
    if (cached_has_bits & 0x00000800u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_hitbox());
    }

    // optional uint32 color = 15;
    if (cached_has_bits & 0x00001000u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_color());
    }

    // optional uint32 flags = 16;
    if (cached_has_bits & 0x00002000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_flags());
    }

    // optional int32 attachmentindex = 17;
    if (cached_has_bits & 0x00004000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::Int32Size(
          this->_internal_attachmentindex());
    }

    // optional uint32 effectname = 18;
    if (cached_has_bits & 0x00008000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_effectname());
    }

  }
  if (cached_has_bits & 0x00070000u) {
    // optional uint32 attachmentname = 19;
    if (cached_has_bits & 0x00010000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::UInt32Size(
          this->_internal_attachmentname());
    }

    // optional fixed32 entity = 5 [default = 16777215];
    if (cached_has_bits & 0x00020000u) {
      total_size += 1 + 4;
    }

    // optional fixed32 otherentity = 6 [default = 16777215];
    if (cached_has_bits & 0x00040000u) {
      total_size += 1 + 4;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgEffectData::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgEffectData::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgEffectData::GetClassData() const { return &_class_data_; }


void CMsgEffectData::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgEffectData*>(&to_msg);
  auto& from = static_cast<const CMsgEffectData&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgEffectData)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_origin()->::CMsgVector::MergeFrom(
          from._internal_origin());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_start()->::CMsgVector::MergeFrom(
          from._internal_start());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_normal()->::CMsgVector::MergeFrom(
          from._internal_normal());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_angles()->::CMsgQAngle::MergeFrom(
          from._internal_angles());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.scale_ = from._impl_.scale_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.magnitude_ = from._impl_.magnitude_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.radius_ = from._impl_.radius_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.surfaceprop_ = from._impl_.surfaceprop_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x0000ff00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.effectindex_ = from._impl_.effectindex_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.damagetype_ = from._impl_.damagetype_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.material_ = from._impl_.material_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.hitbox_ = from._impl_.hitbox_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.color_ = from._impl_.color_;
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.flags_ = from._impl_.flags_;
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_impl_.attachmentindex_ = from._impl_.attachmentindex_;
    }
    if (cached_has_bits & 0x00008000u) {
      _this->_impl_.effectname_ = from._impl_.effectname_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00070000u) {
    if (cached_has_bits & 0x00010000u) {
      _this->_impl_.attachmentname_ = from._impl_.attachmentname_;
    }
    if (cached_has_bits & 0x00020000u) {
      _this->_impl_.entity_ = from._impl_.entity_;
    }
    if (cached_has_bits & 0x00040000u) {
      _this->_impl_.otherentity_ = from._impl_.otherentity_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgEffectData::CopyFrom(const CMsgEffectData& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgEffectData)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgEffectData::IsInitialized() const {
  return true;
}

void CMsgEffectData::InternalSwap(CMsgEffectData* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgEffectData, _impl_.attachmentname_)
      + sizeof(CMsgEffectData::_impl_.attachmentname_)
      - PROTOBUF_FIELD_OFFSET(CMsgEffectData, _impl_.origin_)>(
          reinterpret_cast<char*>(&_impl_.origin_),
          reinterpret_cast<char*>(&other->_impl_.origin_));
  swap(_impl_.entity_, other->_impl_.entity_);
  swap(_impl_.otherentity_, other->_impl_.otherentity_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgEffectData::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_te_2eproto_getter, &descriptor_table_te_2eproto_once,
      file_level_metadata_te_2eproto[10]);
}

// ===================================================================

class CMsgTEEffectDispatch::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgTEEffectDispatch>()._impl_._has_bits_);
  static const ::CMsgEffectData& effectdata(const CMsgTEEffectDispatch* msg);
  static void set_has_effectdata(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::CMsgEffectData&
CMsgTEEffectDispatch::_Internal::effectdata(const CMsgTEEffectDispatch* msg) {
  return *msg->_impl_.effectdata_;
}
CMsgTEEffectDispatch::CMsgTEEffectDispatch(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgTEEffectDispatch)
}
CMsgTEEffectDispatch::CMsgTEEffectDispatch(const CMsgTEEffectDispatch& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgTEEffectDispatch* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.effectdata_){nullptr}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_effectdata()) {
    _this->_impl_.effectdata_ = new ::CMsgEffectData(*from._impl_.effectdata_);
  }
  // @@protoc_insertion_point(copy_constructor:CMsgTEEffectDispatch)
}

inline void CMsgTEEffectDispatch::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.effectdata_){nullptr}
  };
}

CMsgTEEffectDispatch::~CMsgTEEffectDispatch() {
  // @@protoc_insertion_point(destructor:CMsgTEEffectDispatch)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgTEEffectDispatch::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.effectdata_;
}

void CMsgTEEffectDispatch::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgTEEffectDispatch::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgTEEffectDispatch)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.effectdata_ != nullptr);
    _impl_.effectdata_->Clear();
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgTEEffectDispatch::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .CMsgEffectData effectdata = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_effectdata(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgTEEffectDispatch::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgTEEffectDispatch)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .CMsgEffectData effectdata = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::effectdata(this),
        _Internal::effectdata(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgTEEffectDispatch)
  return target;
}

size_t CMsgTEEffectDispatch::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgTEEffectDispatch)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .CMsgEffectData effectdata = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *_impl_.effectdata_);
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgTEEffectDispatch::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgTEEffectDispatch::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgTEEffectDispatch::GetClassData() const { return &_class_data_; }


void CMsgTEEffectDispatch::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgTEEffectDispatch*>(&to_msg);
  auto& from = static_cast<const CMsgTEEffectDispatch&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgTEEffectDispatch)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_effectdata()) {
    _this->_internal_mutable_effectdata()->::CMsgEffectData::MergeFrom(
        from._internal_effectdata());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgTEEffectDispatch::CopyFrom(const CMsgTEEffectDispatch& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgTEEffectDispatch)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgTEEffectDispatch::IsInitialized() const {
  return true;
}

void CMsgTEEffectDispatch::InternalSwap(CMsgTEEffectDispatch* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.effectdata_, other->_impl_.effectdata_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgTEEffectDispatch::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_te_2eproto_getter, &descriptor_table_te_2eproto_once,
      file_level_metadata_te_2eproto[11]);
}

// ===================================================================

class CMsgTEEnergySplash::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgTEEnergySplash>()._impl_._has_bits_);
  static const ::CMsgVector& pos(const CMsgTEEnergySplash* msg);
  static void set_has_pos(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::CMsgVector& dir(const CMsgTEEnergySplash* msg);
  static void set_has_dir(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_explosive(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::CMsgVector&
CMsgTEEnergySplash::_Internal::pos(const CMsgTEEnergySplash* msg) {
  return *msg->_impl_.pos_;
}
const ::CMsgVector&
CMsgTEEnergySplash::_Internal::dir(const CMsgTEEnergySplash* msg) {
  return *msg->_impl_.dir_;
}
void CMsgTEEnergySplash::clear_pos() {
  if (_impl_.pos_ != nullptr) _impl_.pos_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void CMsgTEEnergySplash::clear_dir() {
  if (_impl_.dir_ != nullptr) _impl_.dir_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
CMsgTEEnergySplash::CMsgTEEnergySplash(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgTEEnergySplash)
}
CMsgTEEnergySplash::CMsgTEEnergySplash(const CMsgTEEnergySplash& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgTEEnergySplash* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.pos_){nullptr}
    , decltype(_impl_.dir_){nullptr}
    , decltype(_impl_.explosive_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_pos()) {
    _this->_impl_.pos_ = new ::CMsgVector(*from._impl_.pos_);
  }
  if (from._internal_has_dir()) {
    _this->_impl_.dir_ = new ::CMsgVector(*from._impl_.dir_);
  }
  _this->_impl_.explosive_ = from._impl_.explosive_;
  // @@protoc_insertion_point(copy_constructor:CMsgTEEnergySplash)
}

inline void CMsgTEEnergySplash::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.pos_){nullptr}
    , decltype(_impl_.dir_){nullptr}
    , decltype(_impl_.explosive_){false}
  };
}

CMsgTEEnergySplash::~CMsgTEEnergySplash() {
  // @@protoc_insertion_point(destructor:CMsgTEEnergySplash)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgTEEnergySplash::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.pos_;
  if (this != internal_default_instance()) delete _impl_.dir_;
}

void CMsgTEEnergySplash::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgTEEnergySplash::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgTEEnergySplash)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.pos_ != nullptr);
      _impl_.pos_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.dir_ != nullptr);
      _impl_.dir_->Clear();
    }
  }
  _impl_.explosive_ = false;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgTEEnergySplash::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .CMsgVector pos = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_pos(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgVector dir = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_dir(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool explosive = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_explosive(&has_bits);
          _impl_.explosive_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgTEEnergySplash::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgTEEnergySplash)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .CMsgVector pos = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::pos(this),
        _Internal::pos(this).GetCachedSize(), target, stream);
  }

  // optional .CMsgVector dir = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::dir(this),
        _Internal::dir(this).GetCachedSize(), target, stream);
  }

  // optional bool explosive = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(3, this->_internal_explosive(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgTEEnergySplash)
  return target;
}

size_t CMsgTEEnergySplash::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgTEEnergySplash)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .CMsgVector pos = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.pos_);
    }

    // optional .CMsgVector dir = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.dir_);
    }

    // optional bool explosive = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 1;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgTEEnergySplash::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgTEEnergySplash::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgTEEnergySplash::GetClassData() const { return &_class_data_; }


void CMsgTEEnergySplash::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgTEEnergySplash*>(&to_msg);
  auto& from = static_cast<const CMsgTEEnergySplash&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgTEEnergySplash)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_pos()->::CMsgVector::MergeFrom(
          from._internal_pos());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_dir()->::CMsgVector::MergeFrom(
          from._internal_dir());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.explosive_ = from._impl_.explosive_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgTEEnergySplash::CopyFrom(const CMsgTEEnergySplash& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgTEEnergySplash)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgTEEnergySplash::IsInitialized() const {
  return true;
}

void CMsgTEEnergySplash::InternalSwap(CMsgTEEnergySplash* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgTEEnergySplash, _impl_.explosive_)
      + sizeof(CMsgTEEnergySplash::_impl_.explosive_)
      - PROTOBUF_FIELD_OFFSET(CMsgTEEnergySplash, _impl_.pos_)>(
          reinterpret_cast<char*>(&_impl_.pos_),
          reinterpret_cast<char*>(&other->_impl_.pos_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgTEEnergySplash::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_te_2eproto_getter, &descriptor_table_te_2eproto_once,
      file_level_metadata_te_2eproto[12]);
}

// ===================================================================

class CMsgTEFizz::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgTEFizz>()._impl_._has_bits_);
  static void set_has_entity(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_density(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_current(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

CMsgTEFizz::CMsgTEFizz(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgTEFizz)
}
CMsgTEFizz::CMsgTEFizz(const CMsgTEFizz& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgTEFizz* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.density_){}
    , decltype(_impl_.current_){}
    , decltype(_impl_.entity_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.density_, &from._impl_.density_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.entity_) -
    reinterpret_cast<char*>(&_impl_.density_)) + sizeof(_impl_.entity_));
  // @@protoc_insertion_point(copy_constructor:CMsgTEFizz)
}

inline void CMsgTEFizz::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.density_){0u}
    , decltype(_impl_.current_){0}
    , decltype(_impl_.entity_){-1}
  };
}

CMsgTEFizz::~CMsgTEFizz() {
  // @@protoc_insertion_point(destructor:CMsgTEFizz)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgTEFizz::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void CMsgTEFizz::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgTEFizz::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgTEFizz)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&_impl_.density_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.current_) -
        reinterpret_cast<char*>(&_impl_.density_)) + sizeof(_impl_.current_));
    _impl_.entity_ = -1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgTEFizz::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional int32 entity = 1 [default = -1];
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_entity(&has_bits);
          _impl_.entity_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 density = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_density(&has_bits);
          _impl_.density_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 current = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_current(&has_bits);
          _impl_.current_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgTEFizz::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgTEFizz)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional int32 entity = 1 [default = -1];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_entity(), target);
  }

  // optional uint32 density = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_density(), target);
  }

  // optional int32 current = 3;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_current(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgTEFizz)
  return target;
}

size_t CMsgTEFizz::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgTEFizz)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional uint32 density = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_density());
    }

    // optional int32 current = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_current());
    }

    // optional int32 entity = 1 [default = -1];
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_entity());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgTEFizz::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgTEFizz::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgTEFizz::GetClassData() const { return &_class_data_; }


void CMsgTEFizz::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgTEFizz*>(&to_msg);
  auto& from = static_cast<const CMsgTEFizz&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgTEFizz)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.density_ = from._impl_.density_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.current_ = from._impl_.current_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.entity_ = from._impl_.entity_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgTEFizz::CopyFrom(const CMsgTEFizz& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgTEFizz)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgTEFizz::IsInitialized() const {
  return true;
}

void CMsgTEFizz::InternalSwap(CMsgTEFizz* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgTEFizz, _impl_.current_)
      + sizeof(CMsgTEFizz::_impl_.current_)
      - PROTOBUF_FIELD_OFFSET(CMsgTEFizz, _impl_.density_)>(
          reinterpret_cast<char*>(&_impl_.density_),
          reinterpret_cast<char*>(&other->_impl_.density_));
  swap(_impl_.entity_, other->_impl_.entity_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgTEFizz::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_te_2eproto_getter, &descriptor_table_te_2eproto_once,
      file_level_metadata_te_2eproto[13]);
}

// ===================================================================

class CMsgTEShatterSurface::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgTEShatterSurface>()._impl_._has_bits_);
  static const ::CMsgVector& origin(const CMsgTEShatterSurface* msg);
  static void set_has_origin(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::CMsgQAngle& angles(const CMsgTEShatterSurface* msg);
  static void set_has_angles(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::CMsgVector& force(const CMsgTEShatterSurface* msg);
  static void set_has_force(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::CMsgVector& forcepos(const CMsgTEShatterSurface* msg);
  static void set_has_forcepos(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_width(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_height(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_shardsize(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_surfacetype(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_frontcolor(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_backcolor(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
};

const ::CMsgVector&
CMsgTEShatterSurface::_Internal::origin(const CMsgTEShatterSurface* msg) {
  return *msg->_impl_.origin_;
}
const ::CMsgQAngle&
CMsgTEShatterSurface::_Internal::angles(const CMsgTEShatterSurface* msg) {
  return *msg->_impl_.angles_;
}
const ::CMsgVector&
CMsgTEShatterSurface::_Internal::force(const CMsgTEShatterSurface* msg) {
  return *msg->_impl_.force_;
}
const ::CMsgVector&
CMsgTEShatterSurface::_Internal::forcepos(const CMsgTEShatterSurface* msg) {
  return *msg->_impl_.forcepos_;
}
void CMsgTEShatterSurface::clear_origin() {
  if (_impl_.origin_ != nullptr) _impl_.origin_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void CMsgTEShatterSurface::clear_angles() {
  if (_impl_.angles_ != nullptr) _impl_.angles_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void CMsgTEShatterSurface::clear_force() {
  if (_impl_.force_ != nullptr) _impl_.force_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
void CMsgTEShatterSurface::clear_forcepos() {
  if (_impl_.forcepos_ != nullptr) _impl_.forcepos_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
CMsgTEShatterSurface::CMsgTEShatterSurface(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgTEShatterSurface)
}
CMsgTEShatterSurface::CMsgTEShatterSurface(const CMsgTEShatterSurface& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgTEShatterSurface* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.origin_){nullptr}
    , decltype(_impl_.angles_){nullptr}
    , decltype(_impl_.force_){nullptr}
    , decltype(_impl_.forcepos_){nullptr}
    , decltype(_impl_.width_){}
    , decltype(_impl_.height_){}
    , decltype(_impl_.shardsize_){}
    , decltype(_impl_.surfacetype_){}
    , decltype(_impl_.frontcolor_){}
    , decltype(_impl_.backcolor_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_origin()) {
    _this->_impl_.origin_ = new ::CMsgVector(*from._impl_.origin_);
  }
  if (from._internal_has_angles()) {
    _this->_impl_.angles_ = new ::CMsgQAngle(*from._impl_.angles_);
  }
  if (from._internal_has_force()) {
    _this->_impl_.force_ = new ::CMsgVector(*from._impl_.force_);
  }
  if (from._internal_has_forcepos()) {
    _this->_impl_.forcepos_ = new ::CMsgVector(*from._impl_.forcepos_);
  }
  ::memcpy(&_impl_.width_, &from._impl_.width_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.backcolor_) -
    reinterpret_cast<char*>(&_impl_.width_)) + sizeof(_impl_.backcolor_));
  // @@protoc_insertion_point(copy_constructor:CMsgTEShatterSurface)
}

inline void CMsgTEShatterSurface::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.origin_){nullptr}
    , decltype(_impl_.angles_){nullptr}
    , decltype(_impl_.force_){nullptr}
    , decltype(_impl_.forcepos_){nullptr}
    , decltype(_impl_.width_){0}
    , decltype(_impl_.height_){0}
    , decltype(_impl_.shardsize_){0}
    , decltype(_impl_.surfacetype_){0u}
    , decltype(_impl_.frontcolor_){0u}
    , decltype(_impl_.backcolor_){0u}
  };
}

CMsgTEShatterSurface::~CMsgTEShatterSurface() {
  // @@protoc_insertion_point(destructor:CMsgTEShatterSurface)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgTEShatterSurface::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.origin_;
  if (this != internal_default_instance()) delete _impl_.angles_;
  if (this != internal_default_instance()) delete _impl_.force_;
  if (this != internal_default_instance()) delete _impl_.forcepos_;
}

void CMsgTEShatterSurface::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgTEShatterSurface::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgTEShatterSurface)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.origin_ != nullptr);
      _impl_.origin_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.angles_ != nullptr);
      _impl_.angles_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.force_ != nullptr);
      _impl_.force_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.forcepos_ != nullptr);
      _impl_.forcepos_->Clear();
    }
  }
  if (cached_has_bits & 0x000000f0u) {
    ::memset(&_impl_.width_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.surfacetype_) -
        reinterpret_cast<char*>(&_impl_.width_)) + sizeof(_impl_.surfacetype_));
  }
  if (cached_has_bits & 0x00000300u) {
    ::memset(&_impl_.frontcolor_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.backcolor_) -
        reinterpret_cast<char*>(&_impl_.frontcolor_)) + sizeof(_impl_.backcolor_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgTEShatterSurface::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .CMsgVector origin = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_origin(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgQAngle angles = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_angles(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgVector force = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_force(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgVector forcepos = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_forcepos(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float width = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 45)) {
          _Internal::set_has_width(&has_bits);
          _impl_.width_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float height = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 53)) {
          _Internal::set_has_height(&has_bits);
          _impl_.height_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float shardsize = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 61)) {
          _Internal::set_has_shardsize(&has_bits);
          _impl_.shardsize_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 surfacetype = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          _Internal::set_has_surfacetype(&has_bits);
          _impl_.surfacetype_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional fixed32 frontcolor = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 77)) {
          _Internal::set_has_frontcolor(&has_bits);
          _impl_.frontcolor_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // optional fixed32 backcolor = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 85)) {
          _Internal::set_has_backcolor(&has_bits);
          _impl_.backcolor_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgTEShatterSurface::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgTEShatterSurface)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .CMsgVector origin = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::origin(this),
        _Internal::origin(this).GetCachedSize(), target, stream);
  }

  // optional .CMsgQAngle angles = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::angles(this),
        _Internal::angles(this).GetCachedSize(), target, stream);
  }

  // optional .CMsgVector force = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::force(this),
        _Internal::force(this).GetCachedSize(), target, stream);
  }

  // optional .CMsgVector forcepos = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::forcepos(this),
        _Internal::forcepos(this).GetCachedSize(), target, stream);
  }

  // optional float width = 5;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(5, this->_internal_width(), target);
  }

  // optional float height = 6;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(6, this->_internal_height(), target);
  }

  // optional float shardsize = 7;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(7, this->_internal_shardsize(), target);
  }

  // optional uint32 surfacetype = 8;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(8, this->_internal_surfacetype(), target);
  }

  // optional fixed32 frontcolor = 9;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(9, this->_internal_frontcolor(), target);
  }

  // optional fixed32 backcolor = 10;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(10, this->_internal_backcolor(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgTEShatterSurface)
  return target;
}

size_t CMsgTEShatterSurface::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgTEShatterSurface)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional .CMsgVector origin = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.origin_);
    }

    // optional .CMsgQAngle angles = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.angles_);
    }

    // optional .CMsgVector force = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.force_);
    }

    // optional .CMsgVector forcepos = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.forcepos_);
    }

    // optional float width = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 + 4;
    }

    // optional float height = 6;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 4;
    }

    // optional float shardsize = 7;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 + 4;
    }

    // optional uint32 surfacetype = 8;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_surfacetype());
    }

  }
  if (cached_has_bits & 0x00000300u) {
    // optional fixed32 frontcolor = 9;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 4;
    }

    // optional fixed32 backcolor = 10;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 4;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgTEShatterSurface::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgTEShatterSurface::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgTEShatterSurface::GetClassData() const { return &_class_data_; }


void CMsgTEShatterSurface::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgTEShatterSurface*>(&to_msg);
  auto& from = static_cast<const CMsgTEShatterSurface&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgTEShatterSurface)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_origin()->::CMsgVector::MergeFrom(
          from._internal_origin());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_angles()->::CMsgQAngle::MergeFrom(
          from._internal_angles());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_force()->::CMsgVector::MergeFrom(
          from._internal_force());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_forcepos()->::CMsgVector::MergeFrom(
          from._internal_forcepos());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.width_ = from._impl_.width_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.height_ = from._impl_.height_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.shardsize_ = from._impl_.shardsize_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.surfacetype_ = from._impl_.surfacetype_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000300u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.frontcolor_ = from._impl_.frontcolor_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.backcolor_ = from._impl_.backcolor_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgTEShatterSurface::CopyFrom(const CMsgTEShatterSurface& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgTEShatterSurface)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgTEShatterSurface::IsInitialized() const {
  return true;
}

void CMsgTEShatterSurface::InternalSwap(CMsgTEShatterSurface* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgTEShatterSurface, _impl_.backcolor_)
      + sizeof(CMsgTEShatterSurface::_impl_.backcolor_)
      - PROTOBUF_FIELD_OFFSET(CMsgTEShatterSurface, _impl_.origin_)>(
          reinterpret_cast<char*>(&_impl_.origin_),
          reinterpret_cast<char*>(&other->_impl_.origin_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgTEShatterSurface::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_te_2eproto_getter, &descriptor_table_te_2eproto_once,
      file_level_metadata_te_2eproto[14]);
}

// ===================================================================

class CMsgTEGlowSprite::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgTEGlowSprite>()._impl_._has_bits_);
  static const ::CMsgVector& origin(const CMsgTEGlowSprite* msg);
  static void set_has_origin(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_scale(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_life(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_brightness(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::CMsgVector&
CMsgTEGlowSprite::_Internal::origin(const CMsgTEGlowSprite* msg) {
  return *msg->_impl_.origin_;
}
void CMsgTEGlowSprite::clear_origin() {
  if (_impl_.origin_ != nullptr) _impl_.origin_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
CMsgTEGlowSprite::CMsgTEGlowSprite(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgTEGlowSprite)
}
CMsgTEGlowSprite::CMsgTEGlowSprite(const CMsgTEGlowSprite& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgTEGlowSprite* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.origin_){nullptr}
    , decltype(_impl_.scale_){}
    , decltype(_impl_.life_){}
    , decltype(_impl_.brightness_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_origin()) {
    _this->_impl_.origin_ = new ::CMsgVector(*from._impl_.origin_);
  }
  ::memcpy(&_impl_.scale_, &from._impl_.scale_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.brightness_) -
    reinterpret_cast<char*>(&_impl_.scale_)) + sizeof(_impl_.brightness_));
  // @@protoc_insertion_point(copy_constructor:CMsgTEGlowSprite)
}

inline void CMsgTEGlowSprite::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.origin_){nullptr}
    , decltype(_impl_.scale_){0}
    , decltype(_impl_.life_){0}
    , decltype(_impl_.brightness_){0u}
  };
}

CMsgTEGlowSprite::~CMsgTEGlowSprite() {
  // @@protoc_insertion_point(destructor:CMsgTEGlowSprite)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgTEGlowSprite::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.origin_;
}

void CMsgTEGlowSprite::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgTEGlowSprite::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgTEGlowSprite)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.origin_ != nullptr);
    _impl_.origin_->Clear();
  }
  if (cached_has_bits & 0x0000000eu) {
    ::memset(&_impl_.scale_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.brightness_) -
        reinterpret_cast<char*>(&_impl_.scale_)) + sizeof(_impl_.brightness_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgTEGlowSprite::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .CMsgVector origin = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_origin(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float scale = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _Internal::set_has_scale(&has_bits);
          _impl_.scale_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float life = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _Internal::set_has_life(&has_bits);
          _impl_.life_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 brightness = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_brightness(&has_bits);
          _impl_.brightness_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgTEGlowSprite::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgTEGlowSprite)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .CMsgVector origin = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::origin(this),
        _Internal::origin(this).GetCachedSize(), target, stream);
  }

  // optional float scale = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_scale(), target);
  }

  // optional float life = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_life(), target);
  }

  // optional uint32 brightness = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_brightness(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgTEGlowSprite)
  return target;
}

size_t CMsgTEGlowSprite::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgTEGlowSprite)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional .CMsgVector origin = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.origin_);
    }

    // optional float scale = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

    // optional float life = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

    // optional uint32 brightness = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_brightness());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgTEGlowSprite::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgTEGlowSprite::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgTEGlowSprite::GetClassData() const { return &_class_data_; }


void CMsgTEGlowSprite::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgTEGlowSprite*>(&to_msg);
  auto& from = static_cast<const CMsgTEGlowSprite&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgTEGlowSprite)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_origin()->::CMsgVector::MergeFrom(
          from._internal_origin());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.scale_ = from._impl_.scale_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.life_ = from._impl_.life_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.brightness_ = from._impl_.brightness_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgTEGlowSprite::CopyFrom(const CMsgTEGlowSprite& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgTEGlowSprite)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgTEGlowSprite::IsInitialized() const {
  return true;
}

void CMsgTEGlowSprite::InternalSwap(CMsgTEGlowSprite* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgTEGlowSprite, _impl_.brightness_)
      + sizeof(CMsgTEGlowSprite::_impl_.brightness_)
      - PROTOBUF_FIELD_OFFSET(CMsgTEGlowSprite, _impl_.origin_)>(
          reinterpret_cast<char*>(&_impl_.origin_),
          reinterpret_cast<char*>(&other->_impl_.origin_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgTEGlowSprite::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_te_2eproto_getter, &descriptor_table_te_2eproto_once,
      file_level_metadata_te_2eproto[15]);
}

// ===================================================================

class CMsgTEImpact::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgTEImpact>()._impl_._has_bits_);
  static const ::CMsgVector& origin(const CMsgTEImpact* msg);
  static void set_has_origin(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::CMsgVector& normal(const CMsgTEImpact* msg);
  static void set_has_normal(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::CMsgVector&
CMsgTEImpact::_Internal::origin(const CMsgTEImpact* msg) {
  return *msg->_impl_.origin_;
}
const ::CMsgVector&
CMsgTEImpact::_Internal::normal(const CMsgTEImpact* msg) {
  return *msg->_impl_.normal_;
}
void CMsgTEImpact::clear_origin() {
  if (_impl_.origin_ != nullptr) _impl_.origin_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void CMsgTEImpact::clear_normal() {
  if (_impl_.normal_ != nullptr) _impl_.normal_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
CMsgTEImpact::CMsgTEImpact(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgTEImpact)
}
CMsgTEImpact::CMsgTEImpact(const CMsgTEImpact& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgTEImpact* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.origin_){nullptr}
    , decltype(_impl_.normal_){nullptr}
    , decltype(_impl_.type_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_origin()) {
    _this->_impl_.origin_ = new ::CMsgVector(*from._impl_.origin_);
  }
  if (from._internal_has_normal()) {
    _this->_impl_.normal_ = new ::CMsgVector(*from._impl_.normal_);
  }
  _this->_impl_.type_ = from._impl_.type_;
  // @@protoc_insertion_point(copy_constructor:CMsgTEImpact)
}

inline void CMsgTEImpact::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.origin_){nullptr}
    , decltype(_impl_.normal_){nullptr}
    , decltype(_impl_.type_){0u}
  };
}

CMsgTEImpact::~CMsgTEImpact() {
  // @@protoc_insertion_point(destructor:CMsgTEImpact)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgTEImpact::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.origin_;
  if (this != internal_default_instance()) delete _impl_.normal_;
}

void CMsgTEImpact::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgTEImpact::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgTEImpact)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.origin_ != nullptr);
      _impl_.origin_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.normal_ != nullptr);
      _impl_.normal_->Clear();
    }
  }
  _impl_.type_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgTEImpact::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .CMsgVector origin = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_origin(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgVector normal = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_normal(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 type = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_type(&has_bits);
          _impl_.type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgTEImpact::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgTEImpact)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .CMsgVector origin = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::origin(this),
        _Internal::origin(this).GetCachedSize(), target, stream);
  }

  // optional .CMsgVector normal = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::normal(this),
        _Internal::normal(this).GetCachedSize(), target, stream);
  }

  // optional uint32 type = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgTEImpact)
  return target;
}

size_t CMsgTEImpact::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgTEImpact)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .CMsgVector origin = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.origin_);
    }

    // optional .CMsgVector normal = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.normal_);
    }

    // optional uint32 type = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_type());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgTEImpact::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgTEImpact::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgTEImpact::GetClassData() const { return &_class_data_; }


void CMsgTEImpact::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgTEImpact*>(&to_msg);
  auto& from = static_cast<const CMsgTEImpact&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgTEImpact)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_origin()->::CMsgVector::MergeFrom(
          from._internal_origin());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_normal()->::CMsgVector::MergeFrom(
          from._internal_normal());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgTEImpact::CopyFrom(const CMsgTEImpact& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgTEImpact)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgTEImpact::IsInitialized() const {
  return true;
}

void CMsgTEImpact::InternalSwap(CMsgTEImpact* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgTEImpact, _impl_.type_)
      + sizeof(CMsgTEImpact::_impl_.type_)
      - PROTOBUF_FIELD_OFFSET(CMsgTEImpact, _impl_.origin_)>(
          reinterpret_cast<char*>(&_impl_.origin_),
          reinterpret_cast<char*>(&other->_impl_.origin_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgTEImpact::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_te_2eproto_getter, &descriptor_table_te_2eproto_once,
      file_level_metadata_te_2eproto[16]);
}

// ===================================================================

class CMsgTEMuzzleFlash::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgTEMuzzleFlash>()._impl_._has_bits_);
  static const ::CMsgVector& origin(const CMsgTEMuzzleFlash* msg);
  static void set_has_origin(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::CMsgQAngle& angles(const CMsgTEMuzzleFlash* msg);
  static void set_has_angles(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_scale(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::CMsgVector&
CMsgTEMuzzleFlash::_Internal::origin(const CMsgTEMuzzleFlash* msg) {
  return *msg->_impl_.origin_;
}
const ::CMsgQAngle&
CMsgTEMuzzleFlash::_Internal::angles(const CMsgTEMuzzleFlash* msg) {
  return *msg->_impl_.angles_;
}
void CMsgTEMuzzleFlash::clear_origin() {
  if (_impl_.origin_ != nullptr) _impl_.origin_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void CMsgTEMuzzleFlash::clear_angles() {
  if (_impl_.angles_ != nullptr) _impl_.angles_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
CMsgTEMuzzleFlash::CMsgTEMuzzleFlash(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgTEMuzzleFlash)
}
CMsgTEMuzzleFlash::CMsgTEMuzzleFlash(const CMsgTEMuzzleFlash& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgTEMuzzleFlash* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.origin_){nullptr}
    , decltype(_impl_.angles_){nullptr}
    , decltype(_impl_.scale_){}
    , decltype(_impl_.type_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_origin()) {
    _this->_impl_.origin_ = new ::CMsgVector(*from._impl_.origin_);
  }
  if (from._internal_has_angles()) {
    _this->_impl_.angles_ = new ::CMsgQAngle(*from._impl_.angles_);
  }
  ::memcpy(&_impl_.scale_, &from._impl_.scale_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.type_) -
    reinterpret_cast<char*>(&_impl_.scale_)) + sizeof(_impl_.type_));
  // @@protoc_insertion_point(copy_constructor:CMsgTEMuzzleFlash)
}

inline void CMsgTEMuzzleFlash::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.origin_){nullptr}
    , decltype(_impl_.angles_){nullptr}
    , decltype(_impl_.scale_){0}
    , decltype(_impl_.type_){0u}
  };
}

CMsgTEMuzzleFlash::~CMsgTEMuzzleFlash() {
  // @@protoc_insertion_point(destructor:CMsgTEMuzzleFlash)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgTEMuzzleFlash::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.origin_;
  if (this != internal_default_instance()) delete _impl_.angles_;
}

void CMsgTEMuzzleFlash::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgTEMuzzleFlash::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgTEMuzzleFlash)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.origin_ != nullptr);
      _impl_.origin_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.angles_ != nullptr);
      _impl_.angles_->Clear();
    }
  }
  if (cached_has_bits & 0x0000000cu) {
    ::memset(&_impl_.scale_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.type_) -
        reinterpret_cast<char*>(&_impl_.scale_)) + sizeof(_impl_.type_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgTEMuzzleFlash::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .CMsgVector origin = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_origin(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgQAngle angles = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_angles(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float scale = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _Internal::set_has_scale(&has_bits);
          _impl_.scale_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 type = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_type(&has_bits);
          _impl_.type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgTEMuzzleFlash::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgTEMuzzleFlash)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .CMsgVector origin = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::origin(this),
        _Internal::origin(this).GetCachedSize(), target, stream);
  }

  // optional .CMsgQAngle angles = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::angles(this),
        _Internal::angles(this).GetCachedSize(), target, stream);
  }

  // optional float scale = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_scale(), target);
  }

  // optional uint32 type = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgTEMuzzleFlash)
  return target;
}

size_t CMsgTEMuzzleFlash::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgTEMuzzleFlash)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional .CMsgVector origin = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.origin_);
    }

    // optional .CMsgQAngle angles = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.angles_);
    }

    // optional float scale = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

    // optional uint32 type = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_type());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgTEMuzzleFlash::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgTEMuzzleFlash::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgTEMuzzleFlash::GetClassData() const { return &_class_data_; }


void CMsgTEMuzzleFlash::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgTEMuzzleFlash*>(&to_msg);
  auto& from = static_cast<const CMsgTEMuzzleFlash&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgTEMuzzleFlash)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_origin()->::CMsgVector::MergeFrom(
          from._internal_origin());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_angles()->::CMsgQAngle::MergeFrom(
          from._internal_angles());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.scale_ = from._impl_.scale_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgTEMuzzleFlash::CopyFrom(const CMsgTEMuzzleFlash& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgTEMuzzleFlash)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgTEMuzzleFlash::IsInitialized() const {
  return true;
}

void CMsgTEMuzzleFlash::InternalSwap(CMsgTEMuzzleFlash* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgTEMuzzleFlash, _impl_.type_)
      + sizeof(CMsgTEMuzzleFlash::_impl_.type_)
      - PROTOBUF_FIELD_OFFSET(CMsgTEMuzzleFlash, _impl_.origin_)>(
          reinterpret_cast<char*>(&_impl_.origin_),
          reinterpret_cast<char*>(&other->_impl_.origin_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgTEMuzzleFlash::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_te_2eproto_getter, &descriptor_table_te_2eproto_once,
      file_level_metadata_te_2eproto[17]);
}

// ===================================================================

class CMsgTEBloodStream::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgTEBloodStream>()._impl_._has_bits_);
  static const ::CMsgVector& origin(const CMsgTEBloodStream* msg);
  static void set_has_origin(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::CMsgVector& direction(const CMsgTEBloodStream* msg);
  static void set_has_direction(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_color(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_amount(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::CMsgVector&
CMsgTEBloodStream::_Internal::origin(const CMsgTEBloodStream* msg) {
  return *msg->_impl_.origin_;
}
const ::CMsgVector&
CMsgTEBloodStream::_Internal::direction(const CMsgTEBloodStream* msg) {
  return *msg->_impl_.direction_;
}
void CMsgTEBloodStream::clear_origin() {
  if (_impl_.origin_ != nullptr) _impl_.origin_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void CMsgTEBloodStream::clear_direction() {
  if (_impl_.direction_ != nullptr) _impl_.direction_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
CMsgTEBloodStream::CMsgTEBloodStream(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgTEBloodStream)
}
CMsgTEBloodStream::CMsgTEBloodStream(const CMsgTEBloodStream& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgTEBloodStream* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.origin_){nullptr}
    , decltype(_impl_.direction_){nullptr}
    , decltype(_impl_.color_){}
    , decltype(_impl_.amount_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_origin()) {
    _this->_impl_.origin_ = new ::CMsgVector(*from._impl_.origin_);
  }
  if (from._internal_has_direction()) {
    _this->_impl_.direction_ = new ::CMsgVector(*from._impl_.direction_);
  }
  ::memcpy(&_impl_.color_, &from._impl_.color_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.amount_) -
    reinterpret_cast<char*>(&_impl_.color_)) + sizeof(_impl_.amount_));
  // @@protoc_insertion_point(copy_constructor:CMsgTEBloodStream)
}

inline void CMsgTEBloodStream::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.origin_){nullptr}
    , decltype(_impl_.direction_){nullptr}
    , decltype(_impl_.color_){0u}
    , decltype(_impl_.amount_){0u}
  };
}

CMsgTEBloodStream::~CMsgTEBloodStream() {
  // @@protoc_insertion_point(destructor:CMsgTEBloodStream)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgTEBloodStream::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.origin_;
  if (this != internal_default_instance()) delete _impl_.direction_;
}

void CMsgTEBloodStream::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgTEBloodStream::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgTEBloodStream)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.origin_ != nullptr);
      _impl_.origin_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.direction_ != nullptr);
      _impl_.direction_->Clear();
    }
  }
  if (cached_has_bits & 0x0000000cu) {
    ::memset(&_impl_.color_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.amount_) -
        reinterpret_cast<char*>(&_impl_.color_)) + sizeof(_impl_.amount_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgTEBloodStream::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .CMsgVector origin = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_origin(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgVector direction = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_direction(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional fixed32 color = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _Internal::set_has_color(&has_bits);
          _impl_.color_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 amount = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_amount(&has_bits);
          _impl_.amount_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgTEBloodStream::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgTEBloodStream)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .CMsgVector origin = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::origin(this),
        _Internal::origin(this).GetCachedSize(), target, stream);
  }

  // optional .CMsgVector direction = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::direction(this),
        _Internal::direction(this).GetCachedSize(), target, stream);
  }

  // optional fixed32 color = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(3, this->_internal_color(), target);
  }

  // optional uint32 amount = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(4, this->_internal_amount(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgTEBloodStream)
  return target;
}

size_t CMsgTEBloodStream::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgTEBloodStream)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional .CMsgVector origin = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.origin_);
    }

    // optional .CMsgVector direction = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.direction_);
    }

    // optional fixed32 color = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

    // optional uint32 amount = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_amount());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgTEBloodStream::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgTEBloodStream::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgTEBloodStream::GetClassData() const { return &_class_data_; }


void CMsgTEBloodStream::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgTEBloodStream*>(&to_msg);
  auto& from = static_cast<const CMsgTEBloodStream&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgTEBloodStream)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_origin()->::CMsgVector::MergeFrom(
          from._internal_origin());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_direction()->::CMsgVector::MergeFrom(
          from._internal_direction());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.color_ = from._impl_.color_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.amount_ = from._impl_.amount_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgTEBloodStream::CopyFrom(const CMsgTEBloodStream& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgTEBloodStream)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgTEBloodStream::IsInitialized() const {
  return true;
}

void CMsgTEBloodStream::InternalSwap(CMsgTEBloodStream* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgTEBloodStream, _impl_.amount_)
      + sizeof(CMsgTEBloodStream::_impl_.amount_)
      - PROTOBUF_FIELD_OFFSET(CMsgTEBloodStream, _impl_.origin_)>(
          reinterpret_cast<char*>(&_impl_.origin_),
          reinterpret_cast<char*>(&other->_impl_.origin_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgTEBloodStream::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_te_2eproto_getter, &descriptor_table_te_2eproto_once,
      file_level_metadata_te_2eproto[18]);
}

// ===================================================================

class CMsgTEExplosion::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgTEExplosion>()._impl_._has_bits_);
  static const ::CMsgVector& origin(const CMsgTEExplosion* msg);
  static void set_has_origin(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_framerate(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::CMsgVector& normal(const CMsgTEExplosion* msg);
  static void set_has_normal(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_materialtype(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_radius(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_magnitude(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_scale(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_affect_ragdolls(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_effect_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_explosion_type(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
};

const ::CMsgVector&
CMsgTEExplosion::_Internal::origin(const CMsgTEExplosion* msg) {
  return *msg->_impl_.origin_;
}
const ::CMsgVector&
CMsgTEExplosion::_Internal::normal(const CMsgTEExplosion* msg) {
  return *msg->_impl_.normal_;
}
void CMsgTEExplosion::clear_origin() {
  if (_impl_.origin_ != nullptr) _impl_.origin_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void CMsgTEExplosion::clear_normal() {
  if (_impl_.normal_ != nullptr) _impl_.normal_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
CMsgTEExplosion::CMsgTEExplosion(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgTEExplosion)
}
CMsgTEExplosion::CMsgTEExplosion(const CMsgTEExplosion& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgTEExplosion* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.effect_name_){}
    , decltype(_impl_.origin_){nullptr}
    , decltype(_impl_.normal_){nullptr}
    , decltype(_impl_.framerate_){}
    , decltype(_impl_.flags_){}
    , decltype(_impl_.materialtype_){}
    , decltype(_impl_.radius_){}
    , decltype(_impl_.magnitude_){}
    , decltype(_impl_.scale_){}
    , decltype(_impl_.affect_ragdolls_){}
    , decltype(_impl_.explosion_type_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.effect_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.effect_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_effect_name()) {
    _this->_impl_.effect_name_.Set(from._internal_effect_name(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_origin()) {
    _this->_impl_.origin_ = new ::CMsgVector(*from._impl_.origin_);
  }
  if (from._internal_has_normal()) {
    _this->_impl_.normal_ = new ::CMsgVector(*from._impl_.normal_);
  }
  ::memcpy(&_impl_.framerate_, &from._impl_.framerate_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.explosion_type_) -
    reinterpret_cast<char*>(&_impl_.framerate_)) + sizeof(_impl_.explosion_type_));
  // @@protoc_insertion_point(copy_constructor:CMsgTEExplosion)
}

inline void CMsgTEExplosion::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.effect_name_){}
    , decltype(_impl_.origin_){nullptr}
    , decltype(_impl_.normal_){nullptr}
    , decltype(_impl_.framerate_){0u}
    , decltype(_impl_.flags_){0u}
    , decltype(_impl_.materialtype_){0u}
    , decltype(_impl_.radius_){0u}
    , decltype(_impl_.magnitude_){0u}
    , decltype(_impl_.scale_){0}
    , decltype(_impl_.affect_ragdolls_){false}
    , decltype(_impl_.explosion_type_){0u}
  };
  _impl_.effect_name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.effect_name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

CMsgTEExplosion::~CMsgTEExplosion() {
  // @@protoc_insertion_point(destructor:CMsgTEExplosion)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgTEExplosion::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.effect_name_.Destroy();
  if (this != internal_default_instance()) delete _impl_.origin_;
  if (this != internal_default_instance()) delete _impl_.normal_;
}

void CMsgTEExplosion::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgTEExplosion::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgTEExplosion)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.effect_name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.origin_ != nullptr);
      _impl_.origin_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.normal_ != nullptr);
      _impl_.normal_->Clear();
    }
  }
  if (cached_has_bits & 0x000000f8u) {
    ::memset(&_impl_.framerate_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.magnitude_) -
        reinterpret_cast<char*>(&_impl_.framerate_)) + sizeof(_impl_.magnitude_));
  }
  if (cached_has_bits & 0x00000700u) {
    ::memset(&_impl_.scale_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.explosion_type_) -
        reinterpret_cast<char*>(&_impl_.scale_)) + sizeof(_impl_.explosion_type_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgTEExplosion::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .CMsgVector origin = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_origin(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 framerate = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_framerate(&has_bits);
          _impl_.framerate_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 flags = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_flags(&has_bits);
          _impl_.flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgVector normal = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_normal(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 materialtype = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_materialtype(&has_bits);
          _impl_.materialtype_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 radius = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_radius(&has_bits);
          _impl_.radius_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 magnitude = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_magnitude(&has_bits);
          _impl_.magnitude_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float scale = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 69)) {
          _Internal::set_has_scale(&has_bits);
          _impl_.scale_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional bool affect_ragdolls = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_affect_ragdolls(&has_bits);
          _impl_.affect_ragdolls_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string effect_name = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          auto str = _internal_mutable_effect_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "CMsgTEExplosion.effect_name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // optional uint32 explosion_type = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 88)) {
          _Internal::set_has_explosion_type(&has_bits);
          _impl_.explosion_type_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgTEExplosion::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgTEExplosion)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .CMsgVector origin = 1;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::origin(this),
        _Internal::origin(this).GetCachedSize(), target, stream);
  }

  // optional uint32 framerate = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_framerate(), target);
  }

  // optional uint32 flags = 3;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_flags(), target);
  }

  // optional .CMsgVector normal = 4;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::normal(this),
        _Internal::normal(this).GetCachedSize(), target, stream);
  }

  // optional uint32 materialtype = 5;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_materialtype(), target);
  }

  // optional uint32 radius = 6;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_radius(), target);
  }

  // optional uint32 magnitude = 7;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(7, this->_internal_magnitude(), target);
  }

  // optional float scale = 8;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(8, this->_internal_scale(), target);
  }

  // optional bool affect_ragdolls = 9;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(9, this->_internal_affect_ragdolls(), target);
  }

  // optional string effect_name = 10;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_effect_name().data(), static_cast<int>(this->_internal_effect_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "CMsgTEExplosion.effect_name");
    target = stream->WriteStringMaybeAliased(
        10, this->_internal_effect_name(), target);
  }

  // optional uint32 explosion_type = 11;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(11, this->_internal_explosion_type(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgTEExplosion)
  return target;
}

size_t CMsgTEExplosion::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgTEExplosion)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string effect_name = 10;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_effect_name());
    }

    // optional .CMsgVector origin = 1;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.origin_);
    }

    // optional .CMsgVector normal = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.normal_);
    }

    // optional uint32 framerate = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_framerate());
    }

    // optional uint32 flags = 3;
    if (cached_has_bits & 0x00000010u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_flags());
    }

    // optional uint32 materialtype = 5;
    if (cached_has_bits & 0x00000020u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_materialtype());
    }

    // optional uint32 radius = 6;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_radius());
    }

    // optional uint32 magnitude = 7;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_magnitude());
    }

  }
  if (cached_has_bits & 0x00000700u) {
    // optional float scale = 8;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 4;
    }

    // optional bool affect_ragdolls = 9;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 1;
    }

    // optional uint32 explosion_type = 11;
    if (cached_has_bits & 0x00000400u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_explosion_type());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgTEExplosion::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgTEExplosion::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgTEExplosion::GetClassData() const { return &_class_data_; }


void CMsgTEExplosion::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgTEExplosion*>(&to_msg);
  auto& from = static_cast<const CMsgTEExplosion&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgTEExplosion)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_effect_name(from._internal_effect_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_origin()->::CMsgVector::MergeFrom(
          from._internal_origin());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_normal()->::CMsgVector::MergeFrom(
          from._internal_normal());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.framerate_ = from._impl_.framerate_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.flags_ = from._impl_.flags_;
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.materialtype_ = from._impl_.materialtype_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.radius_ = from._impl_.radius_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.magnitude_ = from._impl_.magnitude_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000700u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.scale_ = from._impl_.scale_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.affect_ragdolls_ = from._impl_.affect_ragdolls_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.explosion_type_ = from._impl_.explosion_type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgTEExplosion::CopyFrom(const CMsgTEExplosion& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgTEExplosion)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgTEExplosion::IsInitialized() const {
  return true;
}

void CMsgTEExplosion::InternalSwap(CMsgTEExplosion* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.effect_name_, lhs_arena,
      &other->_impl_.effect_name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgTEExplosion, _impl_.explosion_type_)
      + sizeof(CMsgTEExplosion::_impl_.explosion_type_)
      - PROTOBUF_FIELD_OFFSET(CMsgTEExplosion, _impl_.origin_)>(
          reinterpret_cast<char*>(&_impl_.origin_),
          reinterpret_cast<char*>(&other->_impl_.origin_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgTEExplosion::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_te_2eproto_getter, &descriptor_table_te_2eproto_once,
      file_level_metadata_te_2eproto[19]);
}

// ===================================================================

class CMsgTEDust::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgTEDust>()._impl_._has_bits_);
  static const ::CMsgVector& origin(const CMsgTEDust* msg);
  static void set_has_origin(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_size(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_speed(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::CMsgVector& direction(const CMsgTEDust* msg);
  static void set_has_direction(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::CMsgVector&
CMsgTEDust::_Internal::origin(const CMsgTEDust* msg) {
  return *msg->_impl_.origin_;
}
const ::CMsgVector&
CMsgTEDust::_Internal::direction(const CMsgTEDust* msg) {
  return *msg->_impl_.direction_;
}
void CMsgTEDust::clear_origin() {
  if (_impl_.origin_ != nullptr) _impl_.origin_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void CMsgTEDust::clear_direction() {
  if (_impl_.direction_ != nullptr) _impl_.direction_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
CMsgTEDust::CMsgTEDust(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgTEDust)
}
CMsgTEDust::CMsgTEDust(const CMsgTEDust& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgTEDust* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.origin_){nullptr}
    , decltype(_impl_.direction_){nullptr}
    , decltype(_impl_.size_){}
    , decltype(_impl_.speed_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_origin()) {
    _this->_impl_.origin_ = new ::CMsgVector(*from._impl_.origin_);
  }
  if (from._internal_has_direction()) {
    _this->_impl_.direction_ = new ::CMsgVector(*from._impl_.direction_);
  }
  ::memcpy(&_impl_.size_, &from._impl_.size_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.speed_) -
    reinterpret_cast<char*>(&_impl_.size_)) + sizeof(_impl_.speed_));
  // @@protoc_insertion_point(copy_constructor:CMsgTEDust)
}

inline void CMsgTEDust::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.origin_){nullptr}
    , decltype(_impl_.direction_){nullptr}
    , decltype(_impl_.size_){0}
    , decltype(_impl_.speed_){0}
  };
}

CMsgTEDust::~CMsgTEDust() {
  // @@protoc_insertion_point(destructor:CMsgTEDust)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgTEDust::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.origin_;
  if (this != internal_default_instance()) delete _impl_.direction_;
}

void CMsgTEDust::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgTEDust::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgTEDust)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.origin_ != nullptr);
      _impl_.origin_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.direction_ != nullptr);
      _impl_.direction_->Clear();
    }
  }
  if (cached_has_bits & 0x0000000cu) {
    ::memset(&_impl_.size_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.speed_) -
        reinterpret_cast<char*>(&_impl_.size_)) + sizeof(_impl_.speed_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgTEDust::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .CMsgVector origin = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_origin(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float size = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _Internal::set_has_size(&has_bits);
          _impl_.size_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional float speed = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 29)) {
          _Internal::set_has_speed(&has_bits);
          _impl_.speed_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgVector direction = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_direction(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgTEDust::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgTEDust)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .CMsgVector origin = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::origin(this),
        _Internal::origin(this).GetCachedSize(), target, stream);
  }

  // optional float size = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_size(), target);
  }

  // optional float speed = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(3, this->_internal_speed(), target);
  }

  // optional .CMsgVector direction = 4;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::direction(this),
        _Internal::direction(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgTEDust)
  return target;
}

size_t CMsgTEDust::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgTEDust)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional .CMsgVector origin = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.origin_);
    }

    // optional .CMsgVector direction = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.direction_);
    }

    // optional float size = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 + 4;
    }

    // optional float speed = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 4;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgTEDust::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgTEDust::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgTEDust::GetClassData() const { return &_class_data_; }


void CMsgTEDust::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgTEDust*>(&to_msg);
  auto& from = static_cast<const CMsgTEDust&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgTEDust)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_origin()->::CMsgVector::MergeFrom(
          from._internal_origin());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_direction()->::CMsgVector::MergeFrom(
          from._internal_direction());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.size_ = from._impl_.size_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.speed_ = from._impl_.speed_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgTEDust::CopyFrom(const CMsgTEDust& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgTEDust)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgTEDust::IsInitialized() const {
  return true;
}

void CMsgTEDust::InternalSwap(CMsgTEDust* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgTEDust, _impl_.speed_)
      + sizeof(CMsgTEDust::_impl_.speed_)
      - PROTOBUF_FIELD_OFFSET(CMsgTEDust, _impl_.origin_)>(
          reinterpret_cast<char*>(&_impl_.origin_),
          reinterpret_cast<char*>(&other->_impl_.origin_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgTEDust::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_te_2eproto_getter, &descriptor_table_te_2eproto_once,
      file_level_metadata_te_2eproto[20]);
}

// ===================================================================

class CMsgTELargeFunnel::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgTELargeFunnel>()._impl_._has_bits_);
  static const ::CMsgVector& origin(const CMsgTELargeFunnel* msg);
  static void set_has_origin(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_reversed(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::CMsgVector&
CMsgTELargeFunnel::_Internal::origin(const CMsgTELargeFunnel* msg) {
  return *msg->_impl_.origin_;
}
void CMsgTELargeFunnel::clear_origin() {
  if (_impl_.origin_ != nullptr) _impl_.origin_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
CMsgTELargeFunnel::CMsgTELargeFunnel(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgTELargeFunnel)
}
CMsgTELargeFunnel::CMsgTELargeFunnel(const CMsgTELargeFunnel& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgTELargeFunnel* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.origin_){nullptr}
    , decltype(_impl_.reversed_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_origin()) {
    _this->_impl_.origin_ = new ::CMsgVector(*from._impl_.origin_);
  }
  _this->_impl_.reversed_ = from._impl_.reversed_;
  // @@protoc_insertion_point(copy_constructor:CMsgTELargeFunnel)
}

inline void CMsgTELargeFunnel::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.origin_){nullptr}
    , decltype(_impl_.reversed_){0u}
  };
}

CMsgTELargeFunnel::~CMsgTELargeFunnel() {
  // @@protoc_insertion_point(destructor:CMsgTELargeFunnel)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgTELargeFunnel::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.origin_;
}

void CMsgTELargeFunnel::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgTELargeFunnel::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgTELargeFunnel)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.origin_ != nullptr);
    _impl_.origin_->Clear();
  }
  _impl_.reversed_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgTELargeFunnel::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .CMsgVector origin = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_origin(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 reversed = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_reversed(&has_bits);
          _impl_.reversed_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgTELargeFunnel::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgTELargeFunnel)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .CMsgVector origin = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::origin(this),
        _Internal::origin(this).GetCachedSize(), target, stream);
  }

  // optional uint32 reversed = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_reversed(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgTELargeFunnel)
  return target;
}

size_t CMsgTELargeFunnel::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgTELargeFunnel)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .CMsgVector origin = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.origin_);
    }

    // optional uint32 reversed = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_reversed());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgTELargeFunnel::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgTELargeFunnel::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgTELargeFunnel::GetClassData() const { return &_class_data_; }


void CMsgTELargeFunnel::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgTELargeFunnel*>(&to_msg);
  auto& from = static_cast<const CMsgTELargeFunnel&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgTELargeFunnel)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_origin()->::CMsgVector::MergeFrom(
          from._internal_origin());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.reversed_ = from._impl_.reversed_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgTELargeFunnel::CopyFrom(const CMsgTELargeFunnel& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgTELargeFunnel)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgTELargeFunnel::IsInitialized() const {
  return true;
}

void CMsgTELargeFunnel::InternalSwap(CMsgTELargeFunnel* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgTELargeFunnel, _impl_.reversed_)
      + sizeof(CMsgTELargeFunnel::_impl_.reversed_)
      - PROTOBUF_FIELD_OFFSET(CMsgTELargeFunnel, _impl_.origin_)>(
          reinterpret_cast<char*>(&_impl_.origin_),
          reinterpret_cast<char*>(&other->_impl_.origin_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgTELargeFunnel::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_te_2eproto_getter, &descriptor_table_te_2eproto_once,
      file_level_metadata_te_2eproto[21]);
}

// ===================================================================

class CMsgTESparks::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgTESparks>()._impl_._has_bits_);
  static const ::CMsgVector& origin(const CMsgTESparks* msg);
  static void set_has_origin(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_magnitude(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_length(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::CMsgVector& direction(const CMsgTESparks* msg);
  static void set_has_direction(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::CMsgVector&
CMsgTESparks::_Internal::origin(const CMsgTESparks* msg) {
  return *msg->_impl_.origin_;
}
const ::CMsgVector&
CMsgTESparks::_Internal::direction(const CMsgTESparks* msg) {
  return *msg->_impl_.direction_;
}
void CMsgTESparks::clear_origin() {
  if (_impl_.origin_ != nullptr) _impl_.origin_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void CMsgTESparks::clear_direction() {
  if (_impl_.direction_ != nullptr) _impl_.direction_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
CMsgTESparks::CMsgTESparks(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgTESparks)
}
CMsgTESparks::CMsgTESparks(const CMsgTESparks& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgTESparks* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.origin_){nullptr}
    , decltype(_impl_.direction_){nullptr}
    , decltype(_impl_.magnitude_){}
    , decltype(_impl_.length_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_origin()) {
    _this->_impl_.origin_ = new ::CMsgVector(*from._impl_.origin_);
  }
  if (from._internal_has_direction()) {
    _this->_impl_.direction_ = new ::CMsgVector(*from._impl_.direction_);
  }
  ::memcpy(&_impl_.magnitude_, &from._impl_.magnitude_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.length_) -
    reinterpret_cast<char*>(&_impl_.magnitude_)) + sizeof(_impl_.length_));
  // @@protoc_insertion_point(copy_constructor:CMsgTESparks)
}

inline void CMsgTESparks::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.origin_){nullptr}
    , decltype(_impl_.direction_){nullptr}
    , decltype(_impl_.magnitude_){0u}
    , decltype(_impl_.length_){0u}
  };
}

CMsgTESparks::~CMsgTESparks() {
  // @@protoc_insertion_point(destructor:CMsgTESparks)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgTESparks::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.origin_;
  if (this != internal_default_instance()) delete _impl_.direction_;
}

void CMsgTESparks::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgTESparks::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgTESparks)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.origin_ != nullptr);
      _impl_.origin_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.direction_ != nullptr);
      _impl_.direction_->Clear();
    }
  }
  if (cached_has_bits & 0x0000000cu) {
    ::memset(&_impl_.magnitude_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.length_) -
        reinterpret_cast<char*>(&_impl_.magnitude_)) + sizeof(_impl_.length_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgTESparks::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .CMsgVector origin = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_origin(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 magnitude = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_magnitude(&has_bits);
          _impl_.magnitude_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 length = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_length(&has_bits);
          _impl_.length_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgVector direction = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_direction(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgTESparks::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgTESparks)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .CMsgVector origin = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::origin(this),
        _Internal::origin(this).GetCachedSize(), target, stream);
  }

  // optional uint32 magnitude = 2;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(2, this->_internal_magnitude(), target);
  }

  // optional uint32 length = 3;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_length(), target);
  }

  // optional .CMsgVector direction = 4;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(4, _Internal::direction(this),
        _Internal::direction(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgTESparks)
  return target;
}

size_t CMsgTESparks::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgTESparks)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional .CMsgVector origin = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.origin_);
    }

    // optional .CMsgVector direction = 4;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.direction_);
    }

    // optional uint32 magnitude = 2;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_magnitude());
    }

    // optional uint32 length = 3;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_length());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgTESparks::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgTESparks::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgTESparks::GetClassData() const { return &_class_data_; }


void CMsgTESparks::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgTESparks*>(&to_msg);
  auto& from = static_cast<const CMsgTESparks&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgTESparks)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_origin()->::CMsgVector::MergeFrom(
          from._internal_origin());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_direction()->::CMsgVector::MergeFrom(
          from._internal_direction());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.magnitude_ = from._impl_.magnitude_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.length_ = from._impl_.length_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgTESparks::CopyFrom(const CMsgTESparks& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgTESparks)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgTESparks::IsInitialized() const {
  return true;
}

void CMsgTESparks::InternalSwap(CMsgTESparks* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgTESparks, _impl_.length_)
      + sizeof(CMsgTESparks::_impl_.length_)
      - PROTOBUF_FIELD_OFFSET(CMsgTESparks, _impl_.origin_)>(
          reinterpret_cast<char*>(&_impl_.origin_),
          reinterpret_cast<char*>(&other->_impl_.origin_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgTESparks::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_te_2eproto_getter, &descriptor_table_te_2eproto_once,
      file_level_metadata_te_2eproto[22]);
}

// ===================================================================

class CMsgTEPhysicsProp::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgTEPhysicsProp>()._impl_._has_bits_);
  static const ::CMsgVector& origin(const CMsgTEPhysicsProp* msg);
  static void set_has_origin(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::CMsgVector& velocity(const CMsgTEPhysicsProp* msg);
  static void set_has_velocity(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::CMsgQAngle& angles(const CMsgTEPhysicsProp* msg);
  static void set_has_angles(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_skin(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_effects(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static void set_has_color(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_modelindex(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static void set_has_unused_breakmodelsnottomake(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_scale(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static const ::CMsgVector& dmgpos(const CMsgTEPhysicsProp* msg);
  static void set_has_dmgpos(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::CMsgVector& dmgdir(const CMsgTEPhysicsProp* msg);
  static void set_has_dmgdir(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_dmgtype(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
};

const ::CMsgVector&
CMsgTEPhysicsProp::_Internal::origin(const CMsgTEPhysicsProp* msg) {
  return *msg->_impl_.origin_;
}
const ::CMsgVector&
CMsgTEPhysicsProp::_Internal::velocity(const CMsgTEPhysicsProp* msg) {
  return *msg->_impl_.velocity_;
}
const ::CMsgQAngle&
CMsgTEPhysicsProp::_Internal::angles(const CMsgTEPhysicsProp* msg) {
  return *msg->_impl_.angles_;
}
const ::CMsgVector&
CMsgTEPhysicsProp::_Internal::dmgpos(const CMsgTEPhysicsProp* msg) {
  return *msg->_impl_.dmgpos_;
}
const ::CMsgVector&
CMsgTEPhysicsProp::_Internal::dmgdir(const CMsgTEPhysicsProp* msg) {
  return *msg->_impl_.dmgdir_;
}
void CMsgTEPhysicsProp::clear_origin() {
  if (_impl_.origin_ != nullptr) _impl_.origin_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void CMsgTEPhysicsProp::clear_velocity() {
  if (_impl_.velocity_ != nullptr) _impl_.velocity_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
void CMsgTEPhysicsProp::clear_angles() {
  if (_impl_.angles_ != nullptr) _impl_.angles_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
void CMsgTEPhysicsProp::clear_dmgpos() {
  if (_impl_.dmgpos_ != nullptr) _impl_.dmgpos_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
void CMsgTEPhysicsProp::clear_dmgdir() {
  if (_impl_.dmgdir_ != nullptr) _impl_.dmgdir_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
CMsgTEPhysicsProp::CMsgTEPhysicsProp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgTEPhysicsProp)
}
CMsgTEPhysicsProp::CMsgTEPhysicsProp(const CMsgTEPhysicsProp& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgTEPhysicsProp* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.origin_){nullptr}
    , decltype(_impl_.velocity_){nullptr}
    , decltype(_impl_.angles_){nullptr}
    , decltype(_impl_.dmgpos_){nullptr}
    , decltype(_impl_.dmgdir_){nullptr}
    , decltype(_impl_.skin_){}
    , decltype(_impl_.flags_){}
    , decltype(_impl_.effects_){}
    , decltype(_impl_.color_){}
    , decltype(_impl_.modelindex_){}
    , decltype(_impl_.unused_breakmodelsnottomake_){}
    , decltype(_impl_.scale_){}
    , decltype(_impl_.dmgtype_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_origin()) {
    _this->_impl_.origin_ = new ::CMsgVector(*from._impl_.origin_);
  }
  if (from._internal_has_velocity()) {
    _this->_impl_.velocity_ = new ::CMsgVector(*from._impl_.velocity_);
  }
  if (from._internal_has_angles()) {
    _this->_impl_.angles_ = new ::CMsgQAngle(*from._impl_.angles_);
  }
  if (from._internal_has_dmgpos()) {
    _this->_impl_.dmgpos_ = new ::CMsgVector(*from._impl_.dmgpos_);
  }
  if (from._internal_has_dmgdir()) {
    _this->_impl_.dmgdir_ = new ::CMsgVector(*from._impl_.dmgdir_);
  }
  ::memcpy(&_impl_.skin_, &from._impl_.skin_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.dmgtype_) -
    reinterpret_cast<char*>(&_impl_.skin_)) + sizeof(_impl_.dmgtype_));
  // @@protoc_insertion_point(copy_constructor:CMsgTEPhysicsProp)
}

inline void CMsgTEPhysicsProp::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.origin_){nullptr}
    , decltype(_impl_.velocity_){nullptr}
    , decltype(_impl_.angles_){nullptr}
    , decltype(_impl_.dmgpos_){nullptr}
    , decltype(_impl_.dmgdir_){nullptr}
    , decltype(_impl_.skin_){0u}
    , decltype(_impl_.flags_){0u}
    , decltype(_impl_.effects_){0u}
    , decltype(_impl_.color_){0u}
    , decltype(_impl_.modelindex_){uint64_t{0u}}
    , decltype(_impl_.unused_breakmodelsnottomake_){0u}
    , decltype(_impl_.scale_){0}
    , decltype(_impl_.dmgtype_){0}
  };
}

CMsgTEPhysicsProp::~CMsgTEPhysicsProp() {
  // @@protoc_insertion_point(destructor:CMsgTEPhysicsProp)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgTEPhysicsProp::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.origin_;
  if (this != internal_default_instance()) delete _impl_.velocity_;
  if (this != internal_default_instance()) delete _impl_.angles_;
  if (this != internal_default_instance()) delete _impl_.dmgpos_;
  if (this != internal_default_instance()) delete _impl_.dmgdir_;
}

void CMsgTEPhysicsProp::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgTEPhysicsProp::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgTEPhysicsProp)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.origin_ != nullptr);
      _impl_.origin_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.velocity_ != nullptr);
      _impl_.velocity_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.angles_ != nullptr);
      _impl_.angles_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.dmgpos_ != nullptr);
      _impl_.dmgpos_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.dmgdir_ != nullptr);
      _impl_.dmgdir_->Clear();
    }
  }
  if (cached_has_bits & 0x000000e0u) {
    ::memset(&_impl_.skin_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.effects_) -
        reinterpret_cast<char*>(&_impl_.skin_)) + sizeof(_impl_.effects_));
  }
  if (cached_has_bits & 0x00001f00u) {
    ::memset(&_impl_.color_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.dmgtype_) -
        reinterpret_cast<char*>(&_impl_.color_)) + sizeof(_impl_.dmgtype_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgTEPhysicsProp::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .CMsgVector origin = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_origin(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgVector velocity = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_velocity(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgQAngle angles = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_angles(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional fixed32 skin = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          _Internal::set_has_skin(&has_bits);
          _impl_.skin_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 flags = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_flags(&has_bits);
          _impl_.flags_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 effects = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_effects(&has_bits);
          _impl_.effects_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional fixed32 color = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 61)) {
          _Internal::set_has_color(&has_bits);
          _impl_.color_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint32_t>(ptr);
          ptr += sizeof(uint32_t);
        } else
          goto handle_unusual;
        continue;
      // optional fixed64 modelindex = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 65)) {
          _Internal::set_has_modelindex(&has_bits);
          _impl_.modelindex_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<uint64_t>(ptr);
          ptr += sizeof(uint64_t);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 unused_breakmodelsnottomake = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 72)) {
          _Internal::set_has_unused_breakmodelsnottomake(&has_bits);
          _impl_.unused_breakmodelsnottomake_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float scale = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 85)) {
          _Internal::set_has_scale(&has_bits);
          _impl_.scale_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgVector dmgpos = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_dmgpos(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgVector dmgdir = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_dmgdir(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 dmgtype = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 104)) {
          _Internal::set_has_dmgtype(&has_bits);
          _impl_.dmgtype_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgTEPhysicsProp::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgTEPhysicsProp)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .CMsgVector origin = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::origin(this),
        _Internal::origin(this).GetCachedSize(), target, stream);
  }

  // optional .CMsgVector velocity = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::velocity(this),
        _Internal::velocity(this).GetCachedSize(), target, stream);
  }

  // optional .CMsgQAngle angles = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::angles(this),
        _Internal::angles(this).GetCachedSize(), target, stream);
  }

  // optional fixed32 skin = 4;
  if (cached_has_bits & 0x00000020u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(4, this->_internal_skin(), target);
  }

  // optional uint32 flags = 5;
  if (cached_has_bits & 0x00000040u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(5, this->_internal_flags(), target);
  }

  // optional uint32 effects = 6;
  if (cached_has_bits & 0x00000080u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(6, this->_internal_effects(), target);
  }

  // optional fixed32 color = 7;
  if (cached_has_bits & 0x00000100u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed32ToArray(7, this->_internal_color(), target);
  }

  // optional fixed64 modelindex = 8;
  if (cached_has_bits & 0x00000200u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFixed64ToArray(8, this->_internal_modelindex(), target);
  }

  // optional uint32 unused_breakmodelsnottomake = 9;
  if (cached_has_bits & 0x00000400u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(9, this->_internal_unused_breakmodelsnottomake(), target);
  }

  // optional float scale = 10;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(10, this->_internal_scale(), target);
  }

  // optional .CMsgVector dmgpos = 11;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(11, _Internal::dmgpos(this),
        _Internal::dmgpos(this).GetCachedSize(), target, stream);
  }

  // optional .CMsgVector dmgdir = 12;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(12, _Internal::dmgdir(this),
        _Internal::dmgdir(this).GetCachedSize(), target, stream);
  }

  // optional int32 dmgtype = 13;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(13, this->_internal_dmgtype(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgTEPhysicsProp)
  return target;
}

size_t CMsgTEPhysicsProp::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgTEPhysicsProp)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional .CMsgVector origin = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.origin_);
    }

    // optional .CMsgVector velocity = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.velocity_);
    }

    // optional .CMsgQAngle angles = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.angles_);
    }

    // optional .CMsgVector dmgpos = 11;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.dmgpos_);
    }

    // optional .CMsgVector dmgdir = 12;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.dmgdir_);
    }

    // optional fixed32 skin = 4;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 + 4;
    }

    // optional uint32 flags = 5;
    if (cached_has_bits & 0x00000040u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_flags());
    }

    // optional uint32 effects = 6;
    if (cached_has_bits & 0x00000080u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_effects());
    }

  }
  if (cached_has_bits & 0x00001f00u) {
    // optional fixed32 color = 7;
    if (cached_has_bits & 0x00000100u) {
      total_size += 1 + 4;
    }

    // optional fixed64 modelindex = 8;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 + 8;
    }

    // optional uint32 unused_breakmodelsnottomake = 9;
    if (cached_has_bits & 0x00000400u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_unused_breakmodelsnottomake());
    }

    // optional float scale = 10;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 + 4;
    }

    // optional int32 dmgtype = 13;
    if (cached_has_bits & 0x00001000u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_dmgtype());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgTEPhysicsProp::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgTEPhysicsProp::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgTEPhysicsProp::GetClassData() const { return &_class_data_; }


void CMsgTEPhysicsProp::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgTEPhysicsProp*>(&to_msg);
  auto& from = static_cast<const CMsgTEPhysicsProp&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgTEPhysicsProp)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_origin()->::CMsgVector::MergeFrom(
          from._internal_origin());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_velocity()->::CMsgVector::MergeFrom(
          from._internal_velocity());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_angles()->::CMsgQAngle::MergeFrom(
          from._internal_angles());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_dmgpos()->::CMsgVector::MergeFrom(
          from._internal_dmgpos());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_dmgdir()->::CMsgVector::MergeFrom(
          from._internal_dmgdir());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_impl_.skin_ = from._impl_.skin_;
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_impl_.flags_ = from._impl_.flags_;
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_impl_.effects_ = from._impl_.effects_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00001f00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_impl_.color_ = from._impl_.color_;
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_impl_.modelindex_ = from._impl_.modelindex_;
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_impl_.unused_breakmodelsnottomake_ = from._impl_.unused_breakmodelsnottomake_;
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.scale_ = from._impl_.scale_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.dmgtype_ = from._impl_.dmgtype_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgTEPhysicsProp::CopyFrom(const CMsgTEPhysicsProp& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgTEPhysicsProp)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgTEPhysicsProp::IsInitialized() const {
  return true;
}

void CMsgTEPhysicsProp::InternalSwap(CMsgTEPhysicsProp* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgTEPhysicsProp, _impl_.dmgtype_)
      + sizeof(CMsgTEPhysicsProp::_impl_.dmgtype_)
      - PROTOBUF_FIELD_OFFSET(CMsgTEPhysicsProp, _impl_.origin_)>(
          reinterpret_cast<char*>(&_impl_.origin_),
          reinterpret_cast<char*>(&other->_impl_.origin_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgTEPhysicsProp::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_te_2eproto_getter, &descriptor_table_te_2eproto_once,
      file_level_metadata_te_2eproto[23]);
}

// ===================================================================

class CMsgTEPlayerDecal::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgTEPlayerDecal>()._impl_._has_bits_);
  static const ::CMsgVector& origin(const CMsgTEPlayerDecal* msg);
  static void set_has_origin(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_player(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_entity(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::CMsgVector&
CMsgTEPlayerDecal::_Internal::origin(const CMsgTEPlayerDecal* msg) {
  return *msg->_impl_.origin_;
}
void CMsgTEPlayerDecal::clear_origin() {
  if (_impl_.origin_ != nullptr) _impl_.origin_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
CMsgTEPlayerDecal::CMsgTEPlayerDecal(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgTEPlayerDecal)
}
CMsgTEPlayerDecal::CMsgTEPlayerDecal(const CMsgTEPlayerDecal& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgTEPlayerDecal* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.origin_){nullptr}
    , decltype(_impl_.player_){}
    , decltype(_impl_.entity_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_origin()) {
    _this->_impl_.origin_ = new ::CMsgVector(*from._impl_.origin_);
  }
  ::memcpy(&_impl_.player_, &from._impl_.player_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.entity_) -
    reinterpret_cast<char*>(&_impl_.player_)) + sizeof(_impl_.entity_));
  // @@protoc_insertion_point(copy_constructor:CMsgTEPlayerDecal)
}

inline void CMsgTEPlayerDecal::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.origin_){nullptr}
    , decltype(_impl_.player_){-1}
    , decltype(_impl_.entity_){-1}
  };
}

CMsgTEPlayerDecal::~CMsgTEPlayerDecal() {
  // @@protoc_insertion_point(destructor:CMsgTEPlayerDecal)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgTEPlayerDecal::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.origin_;
}

void CMsgTEPlayerDecal::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgTEPlayerDecal::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgTEPlayerDecal)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.origin_ != nullptr);
      _impl_.origin_->Clear();
    }
    _impl_.player_ = -1;
    _impl_.entity_ = -1;
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgTEPlayerDecal::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .CMsgVector origin = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_origin(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 player = 2 [default = -1];
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          _Internal::set_has_player(&has_bits);
          _impl_.player_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 entity = 3 [default = -1];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_entity(&has_bits);
          _impl_.entity_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgTEPlayerDecal::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgTEPlayerDecal)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .CMsgVector origin = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::origin(this),
        _Internal::origin(this).GetCachedSize(), target, stream);
  }

  // optional int32 player = 2 [default = -1];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_player(), target);
  }

  // optional int32 entity = 3 [default = -1];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_entity(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgTEPlayerDecal)
  return target;
}

size_t CMsgTEPlayerDecal::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgTEPlayerDecal)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .CMsgVector origin = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.origin_);
    }

    // optional int32 player = 2 [default = -1];
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_player());
    }

    // optional int32 entity = 3 [default = -1];
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_entity());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgTEPlayerDecal::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgTEPlayerDecal::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgTEPlayerDecal::GetClassData() const { return &_class_data_; }


void CMsgTEPlayerDecal::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgTEPlayerDecal*>(&to_msg);
  auto& from = static_cast<const CMsgTEPlayerDecal&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgTEPlayerDecal)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_origin()->::CMsgVector::MergeFrom(
          from._internal_origin());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.player_ = from._impl_.player_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.entity_ = from._impl_.entity_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgTEPlayerDecal::CopyFrom(const CMsgTEPlayerDecal& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgTEPlayerDecal)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgTEPlayerDecal::IsInitialized() const {
  return true;
}

void CMsgTEPlayerDecal::InternalSwap(CMsgTEPlayerDecal* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  swap(_impl_.origin_, other->_impl_.origin_);
  swap(_impl_.player_, other->_impl_.player_);
  swap(_impl_.entity_, other->_impl_.entity_);
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgTEPlayerDecal::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_te_2eproto_getter, &descriptor_table_te_2eproto_once,
      file_level_metadata_te_2eproto[24]);
}

// ===================================================================

class CMsgTEProjectedDecal::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgTEProjectedDecal>()._impl_._has_bits_);
  static const ::CMsgVector& origin(const CMsgTEProjectedDecal* msg);
  static void set_has_origin(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::CMsgQAngle& angles(const CMsgTEProjectedDecal* msg);
  static void set_has_angles(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_index(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_distance(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
};

const ::CMsgVector&
CMsgTEProjectedDecal::_Internal::origin(const CMsgTEProjectedDecal* msg) {
  return *msg->_impl_.origin_;
}
const ::CMsgQAngle&
CMsgTEProjectedDecal::_Internal::angles(const CMsgTEProjectedDecal* msg) {
  return *msg->_impl_.angles_;
}
void CMsgTEProjectedDecal::clear_origin() {
  if (_impl_.origin_ != nullptr) _impl_.origin_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void CMsgTEProjectedDecal::clear_angles() {
  if (_impl_.angles_ != nullptr) _impl_.angles_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
CMsgTEProjectedDecal::CMsgTEProjectedDecal(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgTEProjectedDecal)
}
CMsgTEProjectedDecal::CMsgTEProjectedDecal(const CMsgTEProjectedDecal& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgTEProjectedDecal* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.origin_){nullptr}
    , decltype(_impl_.angles_){nullptr}
    , decltype(_impl_.index_){}
    , decltype(_impl_.distance_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_origin()) {
    _this->_impl_.origin_ = new ::CMsgVector(*from._impl_.origin_);
  }
  if (from._internal_has_angles()) {
    _this->_impl_.angles_ = new ::CMsgQAngle(*from._impl_.angles_);
  }
  ::memcpy(&_impl_.index_, &from._impl_.index_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.distance_) -
    reinterpret_cast<char*>(&_impl_.index_)) + sizeof(_impl_.distance_));
  // @@protoc_insertion_point(copy_constructor:CMsgTEProjectedDecal)
}

inline void CMsgTEProjectedDecal::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.origin_){nullptr}
    , decltype(_impl_.angles_){nullptr}
    , decltype(_impl_.index_){0u}
    , decltype(_impl_.distance_){0}
  };
}

CMsgTEProjectedDecal::~CMsgTEProjectedDecal() {
  // @@protoc_insertion_point(destructor:CMsgTEProjectedDecal)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgTEProjectedDecal::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.origin_;
  if (this != internal_default_instance()) delete _impl_.angles_;
}

void CMsgTEProjectedDecal::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgTEProjectedDecal::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgTEProjectedDecal)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.origin_ != nullptr);
      _impl_.origin_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.angles_ != nullptr);
      _impl_.angles_->Clear();
    }
  }
  if (cached_has_bits & 0x0000000cu) {
    ::memset(&_impl_.index_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.distance_) -
        reinterpret_cast<char*>(&_impl_.index_)) + sizeof(_impl_.distance_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgTEProjectedDecal::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .CMsgVector origin = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_origin(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgQAngle angles = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_angles(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 index = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_index(&has_bits);
          _impl_.index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float distance = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          _Internal::set_has_distance(&has_bits);
          _impl_.distance_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgTEProjectedDecal::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgTEProjectedDecal)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .CMsgVector origin = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::origin(this),
        _Internal::origin(this).GetCachedSize(), target, stream);
  }

  // optional .CMsgQAngle angles = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::angles(this),
        _Internal::angles(this).GetCachedSize(), target, stream);
  }

  // optional uint32 index = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_index(), target);
  }

  // optional float distance = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(4, this->_internal_distance(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgTEProjectedDecal)
  return target;
}

size_t CMsgTEProjectedDecal::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgTEProjectedDecal)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    // optional .CMsgVector origin = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.origin_);
    }

    // optional .CMsgQAngle angles = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.angles_);
    }

    // optional uint32 index = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_index());
    }

    // optional float distance = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 4;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgTEProjectedDecal::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgTEProjectedDecal::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgTEProjectedDecal::GetClassData() const { return &_class_data_; }


void CMsgTEProjectedDecal::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgTEProjectedDecal*>(&to_msg);
  auto& from = static_cast<const CMsgTEProjectedDecal&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgTEProjectedDecal)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_origin()->::CMsgVector::MergeFrom(
          from._internal_origin());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_angles()->::CMsgQAngle::MergeFrom(
          from._internal_angles());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.index_ = from._impl_.index_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.distance_ = from._impl_.distance_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgTEProjectedDecal::CopyFrom(const CMsgTEProjectedDecal& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgTEProjectedDecal)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgTEProjectedDecal::IsInitialized() const {
  return true;
}

void CMsgTEProjectedDecal::InternalSwap(CMsgTEProjectedDecal* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgTEProjectedDecal, _impl_.distance_)
      + sizeof(CMsgTEProjectedDecal::_impl_.distance_)
      - PROTOBUF_FIELD_OFFSET(CMsgTEProjectedDecal, _impl_.origin_)>(
          reinterpret_cast<char*>(&_impl_.origin_),
          reinterpret_cast<char*>(&other->_impl_.origin_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgTEProjectedDecal::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_te_2eproto_getter, &descriptor_table_te_2eproto_once,
      file_level_metadata_te_2eproto[25]);
}

// ===================================================================

class CMsgTESmoke::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgTESmoke>()._impl_._has_bits_);
  static const ::CMsgVector& origin(const CMsgTESmoke* msg);
  static void set_has_origin(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_scale(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::CMsgVector&
CMsgTESmoke::_Internal::origin(const CMsgTESmoke* msg) {
  return *msg->_impl_.origin_;
}
void CMsgTESmoke::clear_origin() {
  if (_impl_.origin_ != nullptr) _impl_.origin_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
CMsgTESmoke::CMsgTESmoke(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgTESmoke)
}
CMsgTESmoke::CMsgTESmoke(const CMsgTESmoke& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgTESmoke* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.origin_){nullptr}
    , decltype(_impl_.scale_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_origin()) {
    _this->_impl_.origin_ = new ::CMsgVector(*from._impl_.origin_);
  }
  _this->_impl_.scale_ = from._impl_.scale_;
  // @@protoc_insertion_point(copy_constructor:CMsgTESmoke)
}

inline void CMsgTESmoke::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.origin_){nullptr}
    , decltype(_impl_.scale_){0}
  };
}

CMsgTESmoke::~CMsgTESmoke() {
  // @@protoc_insertion_point(destructor:CMsgTESmoke)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgTESmoke::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.origin_;
}

void CMsgTESmoke::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgTESmoke::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgTESmoke)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(_impl_.origin_ != nullptr);
    _impl_.origin_->Clear();
  }
  _impl_.scale_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgTESmoke::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .CMsgVector origin = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_origin(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float scale = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _Internal::set_has_scale(&has_bits);
          _impl_.scale_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgTESmoke::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgTESmoke)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .CMsgVector origin = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::origin(this),
        _Internal::origin(this).GetCachedSize(), target, stream);
  }

  // optional float scale = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_scale(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgTESmoke)
  return target;
}

size_t CMsgTESmoke::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgTESmoke)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional .CMsgVector origin = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.origin_);
    }

    // optional float scale = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 + 4;
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgTESmoke::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgTESmoke::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgTESmoke::GetClassData() const { return &_class_data_; }


void CMsgTESmoke::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgTESmoke*>(&to_msg);
  auto& from = static_cast<const CMsgTESmoke&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgTESmoke)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_origin()->::CMsgVector::MergeFrom(
          from._internal_origin());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.scale_ = from._impl_.scale_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgTESmoke::CopyFrom(const CMsgTESmoke& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgTESmoke)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgTESmoke::IsInitialized() const {
  return true;
}

void CMsgTESmoke::InternalSwap(CMsgTESmoke* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgTESmoke, _impl_.scale_)
      + sizeof(CMsgTESmoke::_impl_.scale_)
      - PROTOBUF_FIELD_OFFSET(CMsgTESmoke, _impl_.origin_)>(
          reinterpret_cast<char*>(&_impl_.origin_),
          reinterpret_cast<char*>(&other->_impl_.origin_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgTESmoke::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_te_2eproto_getter, &descriptor_table_te_2eproto_once,
      file_level_metadata_te_2eproto[26]);
}

// ===================================================================

class CMsgTEWorldDecal::_Internal {
 public:
  using HasBits = decltype(std::declval<CMsgTEWorldDecal>()._impl_._has_bits_);
  static const ::CMsgVector& origin(const CMsgTEWorldDecal* msg);
  static void set_has_origin(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::CMsgVector& normal(const CMsgTEWorldDecal* msg);
  static void set_has_normal(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_index(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::CMsgVector&
CMsgTEWorldDecal::_Internal::origin(const CMsgTEWorldDecal* msg) {
  return *msg->_impl_.origin_;
}
const ::CMsgVector&
CMsgTEWorldDecal::_Internal::normal(const CMsgTEWorldDecal* msg) {
  return *msg->_impl_.normal_;
}
void CMsgTEWorldDecal::clear_origin() {
  if (_impl_.origin_ != nullptr) _impl_.origin_->Clear();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
void CMsgTEWorldDecal::clear_normal() {
  if (_impl_.normal_ != nullptr) _impl_.normal_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
CMsgTEWorldDecal::CMsgTEWorldDecal(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:CMsgTEWorldDecal)
}
CMsgTEWorldDecal::CMsgTEWorldDecal(const CMsgTEWorldDecal& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  CMsgTEWorldDecal* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.origin_){nullptr}
    , decltype(_impl_.normal_){nullptr}
    , decltype(_impl_.index_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_origin()) {
    _this->_impl_.origin_ = new ::CMsgVector(*from._impl_.origin_);
  }
  if (from._internal_has_normal()) {
    _this->_impl_.normal_ = new ::CMsgVector(*from._impl_.normal_);
  }
  _this->_impl_.index_ = from._impl_.index_;
  // @@protoc_insertion_point(copy_constructor:CMsgTEWorldDecal)
}

inline void CMsgTEWorldDecal::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.origin_){nullptr}
    , decltype(_impl_.normal_){nullptr}
    , decltype(_impl_.index_){0u}
  };
}

CMsgTEWorldDecal::~CMsgTEWorldDecal() {
  // @@protoc_insertion_point(destructor:CMsgTEWorldDecal)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CMsgTEWorldDecal::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete _impl_.origin_;
  if (this != internal_default_instance()) delete _impl_.normal_;
}

void CMsgTEWorldDecal::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void CMsgTEWorldDecal::Clear() {
// @@protoc_insertion_point(message_clear_start:CMsgTEWorldDecal)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(_impl_.origin_ != nullptr);
      _impl_.origin_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.normal_ != nullptr);
      _impl_.normal_->Clear();
    }
  }
  _impl_.index_ = 0u;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* CMsgTEWorldDecal::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .CMsgVector origin = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_origin(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .CMsgVector normal = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_normal(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional uint32 index = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_index(&has_bits);
          _impl_.index_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CMsgTEWorldDecal::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:CMsgTEWorldDecal)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .CMsgVector origin = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::origin(this),
        _Internal::origin(this).GetCachedSize(), target, stream);
  }

  // optional .CMsgVector normal = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::normal(this),
        _Internal::normal(this).GetCachedSize(), target, stream);
  }

  // optional uint32 index = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteUInt32ToArray(3, this->_internal_index(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:CMsgTEWorldDecal)
  return target;
}

size_t CMsgTEWorldDecal::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:CMsgTEWorldDecal)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .CMsgVector origin = 1;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.origin_);
    }

    // optional .CMsgVector normal = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.normal_);
    }

    // optional uint32 index = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::UInt32SizePlusOne(this->_internal_index());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData CMsgTEWorldDecal::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    CMsgTEWorldDecal::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*CMsgTEWorldDecal::GetClassData() const { return &_class_data_; }


void CMsgTEWorldDecal::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<CMsgTEWorldDecal*>(&to_msg);
  auto& from = static_cast<const CMsgTEWorldDecal&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:CMsgTEWorldDecal)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_mutable_origin()->::CMsgVector::MergeFrom(
          from._internal_origin());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_normal()->::CMsgVector::MergeFrom(
          from._internal_normal());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.index_ = from._impl_.index_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void CMsgTEWorldDecal::CopyFrom(const CMsgTEWorldDecal& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:CMsgTEWorldDecal)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CMsgTEWorldDecal::IsInitialized() const {
  return true;
}

void CMsgTEWorldDecal::InternalSwap(CMsgTEWorldDecal* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CMsgTEWorldDecal, _impl_.index_)
      + sizeof(CMsgTEWorldDecal::_impl_.index_)
      - PROTOBUF_FIELD_OFFSET(CMsgTEWorldDecal, _impl_.origin_)>(
          reinterpret_cast<char*>(&_impl_.origin_),
          reinterpret_cast<char*>(&other->_impl_.origin_));
}

::PROTOBUF_NAMESPACE_ID::Metadata CMsgTEWorldDecal::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_te_2eproto_getter, &descriptor_table_te_2eproto_once,
      file_level_metadata_te_2eproto[27]);
}

// @@protoc_insertion_point(namespace_scope)
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::CMsgTEArmorRicochet*
Arena::CreateMaybeMessage< ::CMsgTEArmorRicochet >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgTEArmorRicochet >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgTEBaseBeam*
Arena::CreateMaybeMessage< ::CMsgTEBaseBeam >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgTEBaseBeam >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgTEBeamEntPoint*
Arena::CreateMaybeMessage< ::CMsgTEBeamEntPoint >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgTEBeamEntPoint >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgTEBeamEnts*
Arena::CreateMaybeMessage< ::CMsgTEBeamEnts >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgTEBeamEnts >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgTEBeamPoints*
Arena::CreateMaybeMessage< ::CMsgTEBeamPoints >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgTEBeamPoints >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgTEBeamRing*
Arena::CreateMaybeMessage< ::CMsgTEBeamRing >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgTEBeamRing >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgTEBSPDecal*
Arena::CreateMaybeMessage< ::CMsgTEBSPDecal >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgTEBSPDecal >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgTEBubbles*
Arena::CreateMaybeMessage< ::CMsgTEBubbles >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgTEBubbles >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgTEBubbleTrail*
Arena::CreateMaybeMessage< ::CMsgTEBubbleTrail >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgTEBubbleTrail >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgTEDecal*
Arena::CreateMaybeMessage< ::CMsgTEDecal >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgTEDecal >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgEffectData*
Arena::CreateMaybeMessage< ::CMsgEffectData >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgEffectData >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgTEEffectDispatch*
Arena::CreateMaybeMessage< ::CMsgTEEffectDispatch >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgTEEffectDispatch >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgTEEnergySplash*
Arena::CreateMaybeMessage< ::CMsgTEEnergySplash >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgTEEnergySplash >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgTEFizz*
Arena::CreateMaybeMessage< ::CMsgTEFizz >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgTEFizz >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgTEShatterSurface*
Arena::CreateMaybeMessage< ::CMsgTEShatterSurface >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgTEShatterSurface >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgTEGlowSprite*
Arena::CreateMaybeMessage< ::CMsgTEGlowSprite >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgTEGlowSprite >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgTEImpact*
Arena::CreateMaybeMessage< ::CMsgTEImpact >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgTEImpact >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgTEMuzzleFlash*
Arena::CreateMaybeMessage< ::CMsgTEMuzzleFlash >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgTEMuzzleFlash >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgTEBloodStream*
Arena::CreateMaybeMessage< ::CMsgTEBloodStream >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgTEBloodStream >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgTEExplosion*
Arena::CreateMaybeMessage< ::CMsgTEExplosion >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgTEExplosion >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgTEDust*
Arena::CreateMaybeMessage< ::CMsgTEDust >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgTEDust >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgTELargeFunnel*
Arena::CreateMaybeMessage< ::CMsgTELargeFunnel >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgTELargeFunnel >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgTESparks*
Arena::CreateMaybeMessage< ::CMsgTESparks >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgTESparks >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgTEPhysicsProp*
Arena::CreateMaybeMessage< ::CMsgTEPhysicsProp >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgTEPhysicsProp >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgTEPlayerDecal*
Arena::CreateMaybeMessage< ::CMsgTEPlayerDecal >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgTEPlayerDecal >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgTEProjectedDecal*
Arena::CreateMaybeMessage< ::CMsgTEProjectedDecal >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgTEProjectedDecal >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgTESmoke*
Arena::CreateMaybeMessage< ::CMsgTESmoke >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgTESmoke >(arena);
}
template<> PROTOBUF_NOINLINE ::CMsgTEWorldDecal*
Arena::CreateMaybeMessage< ::CMsgTEWorldDecal >(Arena* arena) {
  return Arena::CreateMessageInternal< ::CMsgTEWorldDecal >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
